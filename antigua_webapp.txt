### .babelrc
{
  "presets": ["@babel/preset-env"]
}


### main.js
import { Meteor } from "meteor/meteor";
import "../imports/api/books";
import "../imports/api/myBooks";
import "../imports/api/contentBooks";
import "../imports/api/users";
import "../imports/api/rooms";
import "../imports/api/words";
import "../imports/api/dropWall";
import "../imports/api/messages";
import "../imports/api/dropboxContent";
import "../imports/api/comments";
import "../imports/api/readersGroups";
import "../imports/api/email";
import "../imports/api/chatGPTwithJesus";
import "../imports/api/naturalchat";
import { Rooms } from "../imports/api/rooms";
import { Books } from "../imports/api/books";

Meteor.startup(() => {
  // code to run on server at startup
  // to active migration
  Accounts.config({
    forbidClientAccountCreation: false,
  });
  Email.send({
    from: "admin@lalibreriamagica.com",
    to: "fernandomorenoruiz@gmail.com",
    text: "hola",
  });

  Email.send({
    from: "admin@lalibreriamagica.com",
    to: "amortabango@gmail.com",
    text: "hola",
  });

  // update all rooms setting a field pricePerPage to 0.5
  // Rooms.update(
  //   { ownerEmail: "fernandomorenoruiz@gmail.com" },
  //   { $set: { pricePerPage: 0.5, lastPaidIndex: 0 } },
  //   { multi: true }
  // );
});


### nightwatch.conf.js
// Autogenerated by Nightwatch
// Refer to the online docs for more details: https://nightwatchjs.org/gettingstarted/configuration/
const Services = {}; loadServices();

module.exports = {
  // An array of folders (excluding subfolders) where your tests are located;
  // if this is not specified, the test source must be passed as the second argument to the test runner.
  src_folders: [
    "./test/nightwatch"
  ],

  // See https://nightwatchjs.org/guide/working-with-page-objects/
  page_objects_path: './test/pageObjects',

  // See https://nightwatchjs.org/guide/extending-nightwatch/#writing-custom-commands
  custom_commands_path:  '',

  // See https://nightwatchjs.org/guide/extending-nightwatch/#writing-custom-assertions
  custom_assertions_path: '',

  // See https://nightwatchjs.org/guide/#external-globals
  globals_path : '',

  webdriver: {},

  test_settings: {
    default: {
      disable_error_log: false,
      launch_url: 'https://nightwatchjs.org',

      screenshots: {
        enabled: false,
        path: 'screens',
        on_failure: true
      },

      desiredCapabilities: {
        browserName : 'chrome'
      },

      webdriver: {
        start_process: true,
        server_path: (Services.chromedriver ? Services.chromedriver.path : '')
      }

      // webdriver: {
      //   start_process: true,
      //   server_path: (Services.geckodriver ? Services.geckodriver.path : '')
      // }
    },

    

    firefox: {
      desiredCapabilities : {
        browserName : 'firefox',
        alwaysMatch: {
          acceptInsecureCerts: true,
          'moz:firefoxOptions': {
            args: [
              // '-headless',
              // '-verbose'
            ]
          }
        }

      },
      webdriver: {
        start_process: true,
        port: 4444,
        server_path: (Services.geckodriver ? Services.geckodriver.path : ''),
        cli_args: [
          // very verbose geckodriver logs
          // '-vv'
        ]
      }
    },

    chrome: {
      desiredCapabilities : {
        browserName : 'chrome',
        'goog:chromeOptions' : {
          // More info on Chromedriver: https://sites.google.com/a/chromium.org/chromedriver/
          //
          // This tells Chromedriver to run using the legacy JSONWire protocol (not required in Chrome 78)
          w3c: false,
          args: [
            //'--no-sandbox',
            //'--ignore-certificate-errors',
            //'--allow-insecure-localhost',
            //'--headless'
          ]
        }
      },

      webdriver: {
        start_process: true,
        port: 9515,
        server_path: (Services.chromedriver ? Services.chromedriver.path : ''),
        cli_args: [
          // --verbose
        ]
      }
    },

    edge: {
      desiredCapabilities : {
        browserName : 'MicrosoftEdge',
        'ms:edgeOptions' : {
          w3c: false,
          // More info on EdgeDriver: https://docs.microsoft.com/en-us/microsoft-edge/webdriver-chromium/capabilities-edge-options
          args: [
            //'--headless'
          ]
        }
      },

      webdriver: {
        start_process: true,
        // Download msedgedriver from https://docs.microsoft.com/en-us/microsoft-edge/webdriver-chromium/
        //  and set the location below:
        server_path: '',
        cli_args: [
          // --verbose
        ]
      }
    },

    //////////////////////////////////////////////////////////////////////////////////
    // Configuration for when using the browserstack.com cloud service               |
    //                                                                               |
    // Please set the username and access key by setting the environment variables:  |
    // - BROWSERSTACK_USER                                                           |
    // - BROWSERSTACK_KEY                                                            |
    // .env files are supported                                                      |
    //////////////////////////////////////////////////////////////////////////////////
    browserstack: {
      selenium: {
        host: 'hub-cloud.browserstack.com',
        port: 443
      },
      // More info on configuring capabilities can be found on:
      // https://www.browserstack.com/automate/capabilities?tag=selenium-4
      desiredCapabilities: {
        'bstack:options' : {
          userName: '${BROWSERSTACK_USER}',
          accessKey: '${BROWSERSTACK_KEY}',
        }
      },

      disable_error_log: true,
      webdriver: {
        timeout_options: {
          timeout: 15000,
          retry_attempts: 3
        },
        keep_alive: true,
        start_process: false
      }
    },

    'browserstack.local': {
      extends: 'browserstack',
      desiredCapabilities: {
        'browserstack.local': true
      }
    },

    'browserstack.chrome': {
      extends: 'browserstack',
      desiredCapabilities: {
        browserName: 'chrome',
        chromeOptions : {
          w3c: false
        }
      }
    },

    'browserstack.firefox': {
      extends: 'browserstack',
      desiredCapabilities: {
        browserName: 'firefox'
      }
    },

    'browserstack.ie': {
      extends: 'browserstack',
      desiredCapabilities: {
        browserName: 'internet explorer',
        browserVersion: '11.0'
      }
    },

    'browserstack.safari': {
      extends: 'browserstack',
      desiredCapabilities: {
        browserName: 'safari'
      }
    },

    'browserstack.local_chrome': {
      extends: 'browserstack.local',
      desiredCapabilities: {
        browserName: 'chrome'
      }
    },

    'browserstack.local_firefox': {
      extends: 'browserstack.local',
      desiredCapabilities: {
        browserName: 'firefox'
      }
    },
    //////////////////////////////////////////////////////////////////////////////////
    // Configuration for when using the Selenium service, either locally or remote,  |
    //  like Selenium Grid                                                           |
    //////////////////////////////////////////////////////////////////////////////////
    selenium_server: {
      // Selenium Server is running locally and is managed by Nightwatch
      selenium: {
        start_process: true,
        port: 4444,
        server_path: (Services.seleniumServer ? Services.seleniumServer.path : ''),
        cli_args: {
          'webdriver.chrome.driver': (Services.chromedriver ? Services.chromedriver.path : ''),
          'webdriver.gecko.driver': (Services.geckodriver ? Services.geckodriver.path : '')
        }
      }
    },

    'selenium.chrome': {
      extends: 'selenium_server',
      desiredCapabilities: {
        browserName: 'chrome',
        chromeOptions : {
          w3c: false
        }
      }
    },

    'selenium.firefox': {
      extends: 'selenium_server',
      desiredCapabilities: {
        browserName: 'firefox',
        'moz:firefoxOptions': {
          args: [
            // '-headless',
            // '-verbose'
          ]
        }
      }
    }
  }
};

function loadServices() {
  try {
    Services.seleniumServer = require('selenium-server');
  } catch (err) {}

  try {
    Services.chromedriver = require('chromedriver');
  } catch (err) {}

  try {
    Services.geckodriver = require('geckodriver');
  } catch (err) {}
}


### package.json
{
  "name": "realbook",
  "private": true,
  "scripts": {
    "start": "meteor run",
    "testn": "nightwatch",
    "testmain": "nightwatch ./test/nightwatch/main.test.js",
    "testusers": "nightwatch ./test/nightwatch/usersOnline.test.js",
    "test": "meteor test --driver-package meteortesting:mocha --port=3100",
    "test-app": "TEST_WATCH=1 meteor test --full-app --driver-package meteortesting:mocha",
    "visualize": "meteor --production --extra-packages bundle-visualizer"
  },
  "dependencies": {
    "@analytics/google-analytics": "^0.4.1",
    "@babel/runtime": "^7.12.5",
    "@date-io/date-fns": "^1.3.13",
    "@material-ui/core": "^4.11.2",
    "@material-ui/icons": "^4.11.2",
    "@material-ui/pickers": "^3.3.10",
    "@palmabit/react-cookie-law": "^0.3.0",
    "@types/react": "^17.0.38",
    "analytics": "^0.5.5",
    "bootstrap-icons": "^1.3.0",
    "date-fns": "^2.25.0",
    "dropbox-v2-api": "^2.4.32",
    "fibers": "^5.0.0",
    "jquery": "^3.5.1",
    "lodash": "^4.17.21",
    "meteor-node-stubs": "^1.0.1",
    "node-fetch": "^2.6.1",
    "openai": "^3.3.0",
    "openai-api": "^1.3.1",
    "react": "^16.14.0",
    "react-cookie": "^4.0.3",
    "react-cookie-consent": "^5.2.0",
    "react-dom": "^16.14.0",
    "react-flip-move": "^3.0.4",
    "react-ga": "^3.3.0",
    "react-helmet": "^6.1.0",
    "react-material-ui-carousel": "^1.9.2",
    "react-modal": "^3.12.1",
    "react-router": "^5.2.0",
    "react-router-dom": "^5.2.0",
    "react-style": "^0.5.5",
    "react-transition-group": "^4.4.5",
    "simpl-schema": "^1.10.2",
    "styled-components": "^5.0.0"
  },
  "meteor": {
    "mainModule": {
      "client": "client/main.js",
      "server": "server/main.js"
    }
  },
  "devDependencies": {
    "@babel/core": "^7.23.2",
    "@babel/preset-env": "^7.23.2",
    "babel-jest": "^29.7.0",
    "chai": "^4.3.10",
    "chromedriver": "^97.0.0",
    "coffee-script": "^1.12.7",
    "expect": "^27.3.1",
    "geckodriver": "^2.0.4",
    "jest": "^29.7.0",
    "nightwatch": "^1.7.11",
    "sinon": "^17.0.1"
  }
}



### main.html
<head>
  <title>La Librería Mágica</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no"
  />
  <meta
    name="description"
    content="La web donde podrás leer libros de forma gratuita de una forma mágica con tus amigos."
  />
  <link rel="icon" type="image/png" href="/favicon.png" sizes="32x32" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
  <script
    async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0860246275904155"
    crossorigin="anonymous"
  ></script>
</head>

<body>
  <div id="app"></div>
</body>


### main.js
import { Meteor } from "meteor/meteor";
import React from "react";
import ReactDOM from "react-dom";
import { isAuthChange, Routes } from "../imports/routes/routes";
import { Tracker } from "meteor/tracker";
import { MuiPickersUtilsProvider } from '@material-ui/pickers'
import DateFnsUtils from '@date-io/date-fns'
import locale from 'date-fns/locale/es'
import { USERS } from "../imports/api/users";
import SimpleDialog from "../imports/ui/commons/SimpleDialog";
import SimpleConfirm from "../imports/ui/commons/SimpleConfirm";
import SimpleAlert from "../imports/ui/commons/SimpleAlert";

console.log(location.pathname);
Tracker.autorun(() => {
  const isAuthenticated = !!Meteor.userId();
  isAuthChange(isAuthenticated);
});

if(locale){
  locale.options.weekStartsOn = 1
}

function App(){
  return (
    <MuiPickersUtilsProvider utils={DateFnsUtils} locale={locale}>      
      <SimpleAlert /><SimpleConfirm/><SimpleDialog/><Routes />
    </MuiPickersUtilsProvider>
  )
}
Meteor.startup(() => {
  ReactDOM.render( App() , document.getElementById("app"));
});


### main.scss
@import '../imports/client/styles/main';


### constants.js
export const WEB_NAME = "La Librería Mágica";
export const Constants = {
  READING: {
    /*Screen size, is the number of character to appear*/
    SCREEN_SIZE: 500,
    /* length of init text*/
    INIT_TEXT_LENGHT: 35,
    /*Reading time interval*/
    READING_TIME_INTERVAL: 120,
    /*step size, number of character in each interval*/
    STEP_SIZE: 1,
    /*forward, backward time interval*/
    STEP_TIME_INTERVAL: 20,
    /*What is the current index when create mybook*/
    INITIAL_CURRENT_INDEX: 10,
    UPDATE_AT_INDEX: 100,
    LETTERS_PER_PAGE: 1500,
  },
  STORAGE: {
    /* 2048 Kb */
    LIMIT_OF_FREE_USERS: 2048,
  },
};
export const PRICE_PER_CHARACTER = 0.000008;

export const ErrorMessage = {
  NOT_LOGGED: { REASON: "Necesitas iniciar sesión.", TYPE: "no autorizado" },
  NOT_AUTHORIZED: {
    REASON: "No está autorizado a hacer esta operación.",
    TYPE: "no autorizado",
  },
  NOT_EMPTY: {
    REASON: "El campo no puede estar vacío.",
    TYPE: "no autorizado",
  },
  INSERT_ERROR: { REASON: "No se ha podido insertar", TYPE: "acción inválida" },
  REMOVE_ERROR: { REASON: "No se ha podido eliminar", TYPE: "acción inválida" },
};


### Analytics.js
import { useEffect } from "react";
import Analytics from "analytics";
import googleAnalytics from "@analytics/google-analytics";
import { useStatisticsCookies } from "./StatisticsCookies";

export const useAnalytics = () => {
    const { cookie } = useStatisticsCookies();
    let analytics = null;
    useEffect(() => {
        if (cookie.rcl_statistics_consent) {
            analytics = Analytics({
                app: "La Libreria Magica",
                plugins: [
                    googleAnalytics({
                        trackingId: "G-6G82H8YDP8",
                    }),
                ],
            });
        }
    }, [cookie]);
    function createAnalytics() {
        return Analytics({
            app: "La Libreria Magica",
            plugins: [
                googleAnalytics({
                    trackingId: "G-6G82H8YDP8",
                }),
            ],
        });
    }
    return { analytics, cookie, createAnalytics };
};


### StatisticsCookies.js
import { useEffect } from "react";
import { useCookies } from "react-cookie";

export function useStatisticsCookies() {
    const [cookie] = useCookies(["rcl_statistics_consent"]);
    return { cookie };
}


### books.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { MyBooks, MyBooksFunctions } from "./myBooks";
import { ContentBooks } from "./contentBooks";
import { ContentBooksFunctions } from "./contentBooks";
import { ErrorMessage } from "../constants";
import { UsersFunctions } from "./users";
import { Rooms, RoomsFunctions } from "./rooms";
import { Commons } from "./commons";

export const Books = new Mongo.Collection("books");
export const BOOKS = {
  PUBLISH_NAMES: {
    BOOKS: "books",
    BOOK_BY_ID_WITH_CONTENT: "book.byIdWithContent",
  },
  METHOD_NAMES: {
    INSERT_WITH_CONTENT: "books.insertWithContent",
    REMOVE: "books.remove",
    SET_PRICE: "books.setPrice",
    GO_TO_READ: "books.goToRead",
    GO_TO_READ_READERSGROUP: "books.goToReadReadersGroup",
    GO_TO_READ_GROUP_READING: "books.goToReadReading",
    TAKE: "books.take",
    SET_ONLY_ADMIN: "books.setOnlyAdmin",
  },
};

if (Meteor.isServer) {
  Meteor.publish(BOOKS.PUBLISH_NAMES.BOOKS, function () {
    if (Commons.isAdmin(this.userId)) {
      return Books.find({}, { sort: { title: 1 } });
    } else {
      return Books.find(
        {
          onlyAdmin: { $ne: true },
        },
        { sort: { title: 1 } }
      );
    }
  });

  Meteor.publish(BOOKS.PUBLISH_NAMES.BOOK_BY_ID_WITH_CONTENT, function (_id) {
    let book = Books.findOne({ _id });
    return [Books.find({ _id }), ContentBooks.find({ _id: book.contentId })];
  });

  Meteor.methods({
    [BOOKS.METHOD_NAMES.INSERT_WITH_CONTENT](book, content) {
      UsersFunctions.Checks.isLogged(this.userId);
      UsersFunctions.Checks.isAdmin(this.userId);
      const contentId = ContentBooksFunctions.insert(content);
      book.contentId = contentId;
      book.length = content.length;
      const bookId = BooksFunctions.insert(book);
      return bookId;
    },
    [BOOKS.METHOD_NAMES.REMOVE](bookId) {
      UsersFunctions.Checks.isLogged(this.userId);
      UsersFunctions.Checks.isAdmin(this.userId);
      const book = Books.findOne(bookId);
      ContentBooksFunctions.remove(book.contentId);
      BooksFunctions.remove(bookId);
      MyBooks.remove({ bookId });
      RoomsFunctions.removeAllRoomsBookId(bookId);
      return true;
    },
    [BOOKS.METHOD_NAMES.SET_PRICE](bookId, price) {
      UsersFunctions.Checks.isLogged(this.userId);
      UsersFunctions.Checks.isAdmin(this.userId);
      const book = Books.findOne(bookId);
      console.log(price);
      if (!book) return;
      Books.update(
        { _id: bookId },
        {
          $set: {
            price: price,
          },
        }
      );
      return true;
    },
    [BOOKS.METHOD_NAMES.GO_TO_READ_GROUP_READING](
      bookId,
      readersGroupId,
      readingId
    ) {
      UsersFunctions.Checks.isLogged(this.userId);
      let myBook = MyBooksFunctions.myBookOfBook(bookId, this.userId);
      let myBookId;
      if (!myBook) {
        myBookId = MyBooksFunctions.createMyBookOfBook(bookId, this.userId);
        myBook = MyBooks.findOne({ _id: myBookId });
      } else {
        myBookId = myBook._id;
      }
      //check for rooms
      let myRooms = RoomsFunctions.getRoomsByParticipantBookIdReadingId(
        this.userId,
        bookId,
        readingId
      );
      let roomId;
      if (myRooms.length === 0) {
        const user = Meteor.users.findOne({ _id: this.userId });
        roomId = Rooms.insert(
          RoomsFunctions.createRoom(user, myBook, readersGroupId, readingId)
        );
      } else if (myRooms.length === 1) {
        roomId = myRooms[0]._id;
      } else {
        roomId = myRooms[0]._id;
      }
      return roomId;
    },
    [BOOKS.METHOD_NAMES.GO_TO_READ_READERSGROUP](bookId, readersGroupId) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("userId:" + this.userId);
      console.log("bookId:" + bookId);
      let myBook = MyBooksFunctions.myBookOfBook(bookId, this.userId);
      console.log(myBook);
      let myBookId;
      if (!myBook) {
        myBookId = MyBooksFunctions.createMyBookOfBook(bookId, this.userId);
        myBook = MyBooks.findOne({ _id: myBookId });
      } else {
        myBookId = myBook._id;
      }
      console.log("myBookId:" + myBookId);
      //check for rooms
      //let myRooms = Rooms.find({myBookId}).fetch()
      let myRooms = RoomsFunctions.getRoomsByParticipantBookIdReadersGroupId(
        this.userId,
        bookId,
        readersGroupId
      );
      console.log(myRooms);
      let roomId;
      if (myRooms.length === 0) {
        const user = Meteor.users.findOne({ _id: this.userId });
        roomId = Rooms.insert(
          RoomsFunctions.createRoom(user, myBook, readersGroupId)
        );
      } else if (myRooms.length === 1) {
        roomId = myRooms[0]._id;
      } else {
        roomId = myRooms[0]._id;
      }
      return roomId;
    },
    [BOOKS.METHOD_NAMES.GO_TO_READ](bookId) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("userId:" + this.userId);
      console.log("bookId:" + bookId);
      let myBook = MyBooksFunctions.myBookOfBook(bookId, this.userId);
      console.log(myBook);
      let myBookId;
      if (!myBook) {
        myBookId = MyBooksFunctions.createMyBookOfBook(bookId, this.userId);
        myBook = MyBooks.findOne({ _id: myBookId });
      } else {
        myBookId = myBook._id;
      }
      console.log("myBookId:" + myBookId);
      //check for rooms
      //let myRooms = Rooms.find({myBookId}).fetch()
      let myRooms = RoomsFunctions.getRoomsByParticipantAndBookId(
        this.userId,
        bookId
      );
      console.log(myRooms);
      let roomId;
      if (myRooms.length === 0) {
        const user = Meteor.users.findOne({ _id: this.userId });
        roomId = Rooms.insert(RoomsFunctions.createRoom(user, myBook));
      } else if (myRooms.length === 1) {
        roomId = myRooms[0]._id;
      } else {
        roomId = myRooms[0]._id;
      }
      return roomId;
    },
    [BOOKS.METHOD_NAMES.TAKE](bookId) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("userId:" + this.userId);
      console.log("bookId:" + bookId);
      let myBook = MyBooksFunctions.myBookOfBook(bookId, this.userId);
      console.log(myBook);
      let myBookId;
      if (!myBook) {
        myBookId = MyBooksFunctions.createMyBookOfBook(bookId, this.userId);
        myBook = MyBooks.findOne({ _id: myBookId });
      } else {
        myBookId = myBook._id;
      }
      return MyBooksFunctions.setActived(myBookId, true);
    },
    [BOOKS.METHOD_NAMES.SET_ONLY_ADMIN](bookId, onlyAdmin) {
      UsersFunctions.Checks.isAdmin(this.userId);
      // log
      console.log("userId:" + this.userId);
      BooksFunctions.setOnlyAdmin(bookId, onlyAdmin);
      // log
      console.log("bookId:" + bookId + " onlyAdmin:" + onlyAdmin + " setted");
    },
  });
}
export const BooksFunctions = {
  remove(bookId) {
    if (!Books.remove(bookId)) {
      throw new Meteor.Error(
        ErrorMessage.REMOVE_ERROR.TYPE,
        ErrorMessage.REMOVE_ERROR.REASON + " Books"
      );
    }
  },
  insert(book) {
    const bookId = Books.insert(book);
    if (!bookId) {
      ContentBooks.remove(book.contentId);
      throw new Meteor.Error(
        ErrorMessage.INSERT_ERROR.TYPE,
        ErrorMessage.INSERT_ERROR.REASON + " Books"
      );
    }
  },
  setOnlyAdmin(bookId, onlyAdmin) {
    Books.update(
      { _id: bookId },
      {
        $set: {
          onlyAdmin,
        },
      }
    );
  },
};


### books.test.js
// import { Meteor } from "meteor/meteor";
// import { Random } from "meteor/random";
import { assert } from "chai";
import sinon from "sinon";
import { Books, BOOKS } from "./books";

// if (Meteor.isServer) {
//   describe("Books", () => {
//     describe("methods", () => {
//       const userId = Random.id();
//       let bookId;

//       beforeEach(() => {
//         Books.remove({});
//         bookId = Books.insert({
//           title: "Test Book",
//           author: "Test Author",
//           createdAt: new Date(),
//           owner: userId,
//           username: "testuser",
//         });
//       });

//       it("can remove owned book", () => {
//         const removeBook = Meteor.methods[BOOKS.METHOD_NAMES.REMOVE];
//         const invocation = { userId };
//         removeBook.apply(invocation, [bookId]);
//         assert.equal(Books.find().count(), 0);
//       });

//       it("cannot remove book without ownership", () => {
//         const removeBook = Meteor.methods[BOOKS.METHOD_NAMES.REMOVE];
//         const invocation = { userId: Random.id() };
//         assert.throw(
//           () => {
//             removeBook.apply(invocation, [bookId]);
//           },
//           Meteor.Error,
//           "books.remove.accessDenied"
//         );
//         assert.equal(Books.find().count(), 1);
//       });

//       it("can set onlyAdmin flag on owned book", () => {
//         const setOnlyAdmin = Meteor.methods[BOOKS.METHOD_NAMES.SET_ONLY_ADMIN];
//         const invocation = { userId };
//         setOnlyAdmin.apply(invocation, [bookId, true]);
//         const book = Books.findOne(bookId);
//         assert.isTrue(book.onlyAdmin);
//       });

//       it("cannot set onlyAdmin flag on book without ownership", () => {
//         const setOnlyAdmin = Meteor.methods[BOOKS.METHOD_NAMES.SET_ONLY_ADMIN];
//         const invocation = { userId: Random.id() };
//         assert.throw(
//           () => {
//             setOnlyAdmin.apply(invocation, [bookId, true]);
//           },
//           Meteor.Error,
//           "books.setOnlyAdmin.accessDenied"
//         );
//         const book = Books.findOne(bookId);
//         assert.isFalse(book.onlyAdmin);
//       });

//       it("can insert book with content", () => {
//         const insertWithContent =
//           Meteor.methods[BOOKS.METHOD_NAMES.INSERT_WITH_CONTENT];
//         const invocation = { userId };
//         const book = {
//           title: "Test Book",
//           author: "Test Author",
//           createdAt: new Date(),
//           owner: userId,
//           username: "testuser",
//         };
//         const content = "This is the content of the book";
//         insertWithContent.apply(invocation, [book, content]);
//         assert.equal(Books.find().count(), 2);
//       });

//       it("can set price on owned book", () => {
//         const setPrice = Meteor.methods[BOOKS.METHOD_NAMES.SET_PRICE];
//         const invocation = { userId };
//         const price = 10.99;
//         setPrice.apply(invocation, [bookId, price]);
//         const book = Books.findOne(bookId);
//         assert.equal(book.price, price);
//       });

//       it("cannot set price on book without ownership", () => {
//         const setPrice = Meteor.methods[BOOKS.METHOD_NAMES.SET_PRICE];
//         const invocation = { userId: Random.id() };
//         const price = 10.99;
//         assert.throw(
//           () => {
//             setPrice.apply(invocation, [bookId, price]);
//           },
//           Meteor.Error,
//           "books.setPrice.accessDenied"
//         );
//         const book = Books.findOne(bookId);
//         assert.isUndefined(book.price);
//       });

//       it("can go to read book", () => {
//         const goToRead = Meteor.methods[BOOKS.METHOD_NAMES.GO_TO_READ];
//         const invocation = { userId };
//         goToRead.apply(invocation, [bookId]);
//         const book = Books.findOne(bookId);
//         assert.equal(book.readers.length, 1);
//         assert.equal(book.readers[0].userId, userId);
//       });

//       it("can go to read book with readers group", () => {
//         const goToReadReadersGroup =
//           Meteor.methods[BOOKS.METHOD_NAMES.GO_TO_READ_READERSGROUP];
//         const invocation = { userId };
//         const readersGroupId = Random.id();
//         goToReadReadersGroup.apply(invocation, [bookId, readersGroupId]);
//         const book = Books.findOne(bookId);
//         assert.equal(book.readers.length, 1);
//         assert.equal(book.readers[0].readersGroupId, readersGroupId);
//       });

//       it("can go to read book with group reading", () => {
//         const goToReadGroupReading =
//           Meteor.methods[BOOKS.METHOD_NAMES.GO_TO_READ_GROUP_READING];
//         const invocation = { userId };
//         const readersGroupId = Random.id();
//         const readingId = Random.id();
//         goToReadGroupReading.apply(invocation, [
//           bookId,
//           readersGroupId,
//           readingId,
//         ]);
//         const book = Books.findOne(bookId);
//         assert.equal(book.readers.length, 1);
//         assert.equal(book.readers[0].readersGroupId, readersGroupId);
//         assert.equal(book.readers[0].readingId, readingId);
//       });

//       it("can take book", () => {
//         const take = Meteor.methods[BOOKS.METHOD_NAMES.TAKE];
//         const invocation = { userId };
//         take.apply(invocation, [bookId]);
//         const book = Books.findOne(bookId);
//         assert.equal(book.takenBy, userId);
//       });

//       it("cannot take book that is already taken", () => {
//         const take = Meteor.methods[BOOKS.METHOD_NAMES.TAKE];
//         const invocation = { userId: Random.id() };
//         const takenBy = Random.id();
//         Books.update(bookId, { $set: { takenBy } });
//         assert.throw(
//           () => {
//             take.apply(invocation, [bookId]);
//           },
//           Meteor.Error,
//           "books.take.alreadyTaken"
//         );
//         const book = Books.findOne(bookId);
//         assert.equal(book.takenBy, takenBy);
//       });
//     });
//   });
// }

describe("Books", function () {
  describe("methods", function () {
    let userId;
    let bookId;

    beforeEach(function () {
      // Stub the database operations
      sinon.stub(Books, "remove");
      sinon.stub(Books, "insert").returns(Random.id());
      sinon.stub(Books, "findOne").returns({
        _id: bookId,
        title: "Test Book",
        author: "Test Author",
        createdAt: new Date(),
        owner: userId,
        username: "testuser",
        onlyAdmin: false,
      });
      sinon.stub(Books, "find").returns({
        count: () => 1,
      });
      sinon.stub(Books, "update");

      userId = Random.id();
      bookId = Random.id(); // simulate the _id of a book
    });

    afterEach(function () {
      // Restore the database operations
      Books.remove.restore();
      Books.insert.restore();
      Books.findOne.restore();
      Books.find.restore();
      Books.update.restore();
    });

    it("can remove owned book", function () {
      const removeBook = Meteor.methods[BOOKS.METHOD_NAMES.REMOVE];
      const invocation = { userId };
      removeBook.apply(invocation, [bookId]);
      assert.isTrue(Books.remove.calledWith(bookId));
    });

    // ... other tests

    it("can set price on owned book", function () {
      const setPrice = Meteor.methods[BOOKS.METHOD_NAMES.SET_PRICE];
      const invocation = { userId };
      const price = 10.99;
      setPrice.apply(invocation, [bookId, price]);
      assert.isTrue(Books.update.calledWith(bookId, { $set: { price } }));
    });

    it("cannot set price on book without ownership", function () {
      const setPrice = Meteor.methods[BOOKS.METHOD_NAMES.SET_PRICE];
      const invocation = { userId: Random.id() }; // different user
      const price = 10.99;

      assert.throw(
        () => {
          setPrice.apply(invocation, [bookId, price]);
        },
        Meteor.Error,
        "books.setPrice.accessDenied"
      );

      assert.isFalse(Books.update.calledWith(bookId, { $set: { price } }));
    });

    // ... additional tests
  });
});


### chatGPTwithJesus.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { UsersFunctions } from "./users";
import { OpenAIApi, Configuration } from "openai";

function replaceQuotes(text) {
  return text.replace(/["`]/g, "'");
}

export const messagesGPT = new Mongo.Collection("messagesGPT");
const PROMPT_BOT =
  "Eres un predicador de la religión cristiana católica. Predicas el mandamiento de Jesús. Por cada frase que aconsejes debes buscar el capítulo y versículo asociado de la Biblia para razonar la respuesta y mostrar el pedazo de la biblia entre comillas. Siempre debes dar una respuesta que tenga sentido y que sea coherente con la religión. Siempre haz la respuesta sobre todo referente al último mensaje. Los mensajes anteriores solo te sirvan de contexto. Contempla en la respuesta la manera de corregir el comportamiento no Cristiano, guiando a través de la palabra de la Biblia. En vez de decir Jehová, di Señor.";
const PROMPT_SUGGERENCES = (userInput) =>
  `Proporciona 5 temas, cada uno de 5 a 10 palabras, relacionados con la enseñanza de Jesucristo y con \`${replaceQuotes(
    userInput
  )}\`. Los temas deben ser distintos, conectados, y no deben contener comas ni terminar con puntuación. Los temas deben listarse en una única línea, cada uno separado del siguiente solo por una coma.`;

export const MESSAGES_GPT = {
  PUBLISH_NAME: {
    MESSAGESGPT: "messagesGPT",
  },
  METHOD_NAME: {
    SEND_MESSAGES: "messagesGPT.sendMessages",
    GET_SUGGERENCES: "messagesGPT.getSuggerences",
    DELETE: "messagesGPT.delete",
  },
};

if (Meteor.isServer) {
  Meteor.publish(MESSAGES_GPT.PUBLISH_NAME.MESSAGESGPT, function () {
    UsersFunctions.Checks.isLogged(this.userId);
    return messagesGPT.find({ userId: this.userId });
  });

  Meteor.methods({
    async [MESSAGES_GPT.METHOD_NAME.SEND_MESSAGES](userInput) {
      console.log(
        "MESSAGES_GPT.METHOD_NAME.SEND_MESSAGES userInput.length:" +
          userInput.length
      );
      //UsersFunctions.Checks.isLogged(this.userId);

      let messages = await getChatResponse(userInput);

      return messages;
    },
    async [MESSAGES_GPT.METHOD_NAME.GET_SUGGERENCES](userInput) {
      console.log(
        "MESSAGES_GPT.METHOD_NAME.GET_SUGGERENCES userInput.length:" +
          userInput.length
      );
      UsersFunctions.Checks.isLogged(this.userId);

      let suggerences = await getSugerences(userInput);

      return suggerences;
    },
    [MESSAGES_GPT.METHOD_NAME.DELETE](messageId) {
      UsersFunctions.Checks.isLogged(this.userId);
      messagesGPT.remove(messageId);
      return true;
    },
  });

  const getChatResponse = async (userInput) => {
    const API_KEY = process.env.OPENAI_API_KEY;
    const ORGANIZATION_ID = process.env.OPENAI_ORGANIZATION;
    const configuration = new Configuration({
      apiKey: API_KEY,
      organization: ORGANIZATION_ID,
    });
    const openai = new OpenAIApi(configuration);

    // Define los mensajes iniciales
    let messages = [
      {
        role: "system",
        content: PROMPT_BOT,
      },
    ];
    // Añade la entrada a los mensajes
    messages.push({ role: "user", content: userInput });

    console.log("sending request to openai...");
    // Configura los parámetros de la petición a GPT-3
    const gptResponse = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      messages: messages,
    });
    console.log("is gptResponse:" + !!gptResponse);
    // Obtiene la respuesta del modelo
    const response = gptResponse.data.choices[0].message.content.trim();
    console.log("openai response length:" + response.length);
    // Añade la respuesta a los mensajes
    messages.push({ role: "assistant", content: response });

    return messages;
  };

  const getSugerences = async (userInput) => {
    const API_KEY = process.env.OPENAI_API_KEY;
    const ORGANIZATION_ID = process.env.OPENAI_ORGANIZATION;
    const configuration = new Configuration({
      apiKey: API_KEY,
      organization: ORGANIZATION_ID,
    });
    const openai = new OpenAIApi(configuration);
    console.log("getChatUserResponse:" + userInput);
    let task = PROMPT_SUGGERENCES(userInput);
    // Define los mensajes iniciales
    let messages = [];
    // Añade la entrada a los mensajes
    messages.push({ role: "user", content: task });

    console.log("sending request to openai...");
    // Configura los parámetros de la petición a GPT-3
    const gptResponse = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      messages: messages,
      temperature: 0.4,
    });

    console.log("is gptResponse:" + !!gptResponse);
    // Obtiene la respuesta del modelo
    const response = gptResponse.data.choices[0].message.content.trim();
    console.log("openai response:" + response);
    return response;
  };
}


### comments.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { UsersFunctions } from "./users";

export const Comments = new Mongo.Collection("comments");

const COMMENT_DEFAULT_LENGTH = 300;
export const COMMENTS = {
  PUBLISH_NAME: {
    COMMENTS: "comments",
  },
  METHOD_NAME: {
    CREATE: "comments.create",
    DELETE: "comments.delete",
    UPDATE_TEXT: "comments.update_text",
    UPDATE_END_INDEX: "comments.update_end_index",
    UPDATE_FIRST_INDEX: "comments.update_first_index",
    REPLY: "commments.reply",
  },
};
if (Meteor.isServer) {
  Comments.rawCollection().createIndex({ roomId: -1 });

  Meteor.publish(COMMENTS.PUBLISH_NAME.COMMENTS, function (roomId) {
    return Comments.find({ roomId: roomId });
  });
}
Meteor.methods({
  [COMMENTS.METHOD_NAME.CREATE](roomId, currentIndex, text) {
    UsersFunctions.Checks.isLogged(this.userId);
    return Comments.insert(
      CommentsFunctions.createComment(roomId, text, currentIndex, this.userId)
    );
  },
  [COMMENTS.METHOD_NAME.UPDATE_TEXT](_id, text) {
    UsersFunctions.Checks.isLogged(this.userId);
    return Comments.update({ _id }, { $set: { text } });
  },
  [COMMENTS.METHOD_NAME.UPDATE_END_INDEX](_id, endIndex) {
    UsersFunctions.Checks.isLogged(this.userId);
    return Comments.update({ _id }, { $set: { endIndex } });
  },
  [COMMENTS.METHOD_NAME.UPDATE_FIRST_INDEX](_id, firstIndex) {
    UsersFunctions.Checks.isLogged(this.userId);
    return Comments.update({ _id }, { $set: { firstIndex } });
  },
  [COMMENTS.METHOD_NAME.DELETE](_id) {
    UsersFunctions.Checks.isLogged(this.userId);
    return Comments.remove({ _id });
  },
  [COMMENTS.METHOD_NAME.REPLY](commentId, text) {
    UsersFunctions.Checks.isLogged(this.userId);
    const comment = Comments.findOne({ _id: commentId });
    CommentsFunctions.replyComment(comment, text);
  },
});

export const CommentsFunctions = {
  createComment(roomId, text, currentIndex, userId) {
    const email = UsersFunctions.getEmailById(userId);
    return {
      roomId: roomId,
      userId: userId,
      email: email,
      text: text,
      firstIndex: currentIndex - COMMENT_DEFAULT_LENGTH,
      endIndex: currentIndex,
      date_creation: Date.now(),
    };
  },
  replyComment(comment, text) {
    Comments.update(
      { _id: comment.commentId },
      {
        $push: {
          comments: CommentsFunctions.createComment(
            comment.roomId,
            text,
            comment.currentIndex
          ),
        },
      }
    );
  },
};


### commons.js
import { Meteor } from "meteor/meteor";
import { ErrorMessage } from "../constants";
export const Commons = {
  getUserById(userId) {
    return Meteor.users.findOne(userId);
  },
  isAdmin(userId) {
    const user = Meteor.users.findOne(userId);
    return user.admin === true;
  },
  Checks: {
    isEmpty(id) {
      if (!id) {
        throw new Meteor.Error(
          ErrorMessage.NOT_EMPTY.TYPE,
          ErrorMessage.NOT_EMPTY.REASON
        );
      }
    },
    isAdmin(userId) {
      if (!Commons.isAdmin(userId)) {
        throw new Meteor.Error(
          ErrorMessage.NOT_AUTHORIZED.TYPE,
          ErrorMessage.NOT_AUTHORIZED.REASON
        );
      }
    },
  },
  calculateStringSize(string) {
    return (string.length * 2) / 1024;
  },
  lengthToKBytesSize(length) {
    return (length * 2) / 1024;
  },
  getTextFromUrl(url, callback) {
    fetch(url).then(function (response) {
      response.text().then(function (text) {
        callback(text);
      });
    });
  },
  getUserIdAdmin() {
    const user = Meteor.users.findOne({ admin: true });
    return user._id;
  },
};


### contentBooks.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { ErrorMessage } from "../constants";

export const ContentBooks = new Mongo.Collection("contentBooks");

export const ContentBooksFunctions = {
  insert(content) {
    const contentId = ContentBooks.insert({
      content,
      ownerId: this.userId,
    });

    if (!contentId) {
      throw new Meteor.Error(
        ErrorMessage.INSERT_ERROR.TYPE,
        ErrorMessage.INSERT_ERROR.REASON + " ContentBooks"
      );
    }
    return contentId;
  },
  remove(contentId) {
    const removeContents = ContentBooks.remove({ _id: contentId });
    console.log("removeContents:" + removeContents);
    if (!removeContents) {
      throw new Meteor.Error(
        ErrorMessage.REMOVE_ERROR.TYPE,
        ErrorMessage.REMOVE_ERROR.REASON + " ContentBook"
      );
    }
    return removeContents;
  },
};


### dropboxContent.js
import { Meteor } from "meteor/meteor";
import { Books } from "../api/books";
import { ContentBooks } from "./contentBooks";
import { Commons } from "../api/commons";
import { MyBooks } from "./myBooks";
import { Rooms } from "./rooms";
import { Photos } from "./dropWall";
import { calculatePrice } from "../ui/commons/CommonsFunctions";
if (Meteor.isServer) {
  const dropboxV2Api = require("dropbox-v2-api");

  // create session ref:    
  const dropbox = dropboxV2Api.authenticate({
    token: process.env.DROPBOX_API,
  });
  //dropboxSync()
  function dropboxSync() {
    dropbox(
      {
        resource: "files/list_folder",
        parameters: {
          path: "/books",
        },
      },
      (err, result, response) => {
        if (err) {
          return console.log(err);
        }

        // to create shared links and books
        createSharedLinksAndBooks(result.entries);
      }
    );
  }

  function dropboxWallSync() {
    Photos.remove({});
    dropbox(
      {
        resource: "files/list_folder",
        parameters: {
          path: "/dropWall",
        },
      },
      (err, result, response) => {
        if (err) {
          return console.log(err);
        }
        console.log(result.entries);
        // to create shared links and books
        createSharedLinksAndPhotos(result.entries);
      }
    );
  }

  function changeLastCharacterTo1(str) {
    return str.substring(0, str.length - 1) + "1";
  }
  function getBookByLink(link) {
    const path = Npm.require("path");
    let names = path.parse(link.name).name.split("#");
    // console.log({ title: names[0], author: names[1] })
    return Books.findOne({ title: names[0], author: names[1] });
  }
  function createSharedLinksAndPhotos(photos) {
    photos.forEach((photo) => {
      dropbox(
        {
          resource: "sharing/create_shared_link_with_settings",
          parameters: {
            path: photo.path_display,
            settings: {
              requested_visibility: "public",
              audience: "public",
              access: "viewer",
            },
          },
        },
        (err, result, response) => {
          err && console.log(err);
          let sharedLink = null;
          if (result) {
            //add new link in the photo
            sharedLink = result;
            // set link in the photo
            addPhotoLink(sharedLink);
          } else if (err.error[".tag"] === "shared_link_already_exists") {
            // get the shared link and set in the photo
            getSharedLinkFromPhoto(photo, (link) => {
              console.log("getSharedLinkFromPhoto");
              addPhotoLink(link);
            });
          }
        }
      );
    });
  }
  function addPhotoLink(sharedLink) {
    console.log("addPhotoLink");
    //console.log(sharedLink);
    let Fiber = Npm.require("fibers");
    Fiber(() => {
      const photoUrl = replaceDropboxUrlCORS(
        changeLastCharacterTo1(sharedLink.url)
      );
      Photos.insert({ url: photoUrl }, (err, _id) => {
        err && console.log(err);
        console.log("photo inserted:" + _id);
      });
    }).run();
  }
  function createSharedLinksAndBooks(books) {
    books.forEach((book) => {
      dropbox(
        {
          resource: "sharing/create_shared_link_with_settings",
          parameters: {
            path: book.path_display,
            settings: {
              requested_visibility: "public",
              audience: "public",
              access: "viewer",
            },
          },
        },
        (err, result, response) => {
          err && console.log(err);
          let sharedLink = null;
          if (result) {
            sharedLink = result;
            setContentUrl(sharedLink);
          } else if (err.error[".tag"] === "shared_link_already_exists") {
            // get the shared link and set in the book
            getSharedLinkFromBook(book, (link) => {
              setContentUrl(link);
            });
          }
        }
      );
    });
  }

  function createBookByLink(link, callback) {
    const path = Npm.require("path");
    let names = path.parse(link.name).name.split("#");
    let book = {
      title: names[0],
      author: names[1],
      length: names[2],
      sharedLink: replaceDropboxUrlCORS(changeLastCharacterTo1(link.url)),
    };
    const contentId = ContentBooks.insert({
      sharedUrl: book.sharedLink,
      ownerId: Commons.getUserIdAdmin(),
    });
    book.contentId = contentId;
    console.log("entra")
    book.price = calculatePrice(book.length)
    const bookId = Books.insert(book);
    console.log("Inserted Book bookId:" + bookId);
  }

  function getSharedLinkFromPhoto(photo, callback) {
    let link = null;
    dropbox(
      {
        resource: "sharing/list_shared_links",
        parameters: {
          path: photo.path_display,
        },
      },
      (err, result, response) => {
        if (err) {
          return console.log(err);
        }
        // console.log("shared link-.")
        // console.log(result)
        link = result.links[0];
        callback(link);
      }
    );
  }

  function getSharedLinkFromBook(book, callback) {
    let link = null;
    dropbox(
      {
        resource: "sharing/list_shared_links",
        parameters: {
          path: book.path_display,
        },
      },
      (err, result, response) => {
        if (err) {
          return console.log(err);
        }
        // console.log("shared link-.")
        // console.log(result)
        link = result.links[0];
        callback(link);
      }
    );
  }

  function replaceDropboxUrlCORS(url) {
    return url.replace("www.dropbox.com", "dl.dropboxusercontent.com");
  }
  function setContentUrl(link) {
    let Fiber = Npm.require("fibers");
    Fiber(() => {
      let book = getBookByLink(link);
      console.log("...................");
      console.log("book name:" + link.name);
      if (book) {
        // update content url
        const path = Npm.require("path");
        console.log("link url####:" + replaceDropboxUrlCORS(link.url));
        const names = path.parse(link.name).name.split("#");
        //update length from books and mybooks and rooms
        Books.update(
          { _id: book._id },
          { $set: { length: parseInt(names[2]) } }
        );
        MyBooks.update(
          { bookId: book._id },
          { $set: { length: parseInt(names[2]) } }
        );
        Rooms.update(
          { contentId: book.contentId },
          { $set: { length: parseInt(names[2]) } }
        );
        ContentBooks.update(
          { _id: book.contentId },
          {
            $set: {
              sharedUrl: changeLastCharacterTo1(
                replaceDropboxUrlCORS(link.url)
              ),
            },
          }
        );
        console.log("contentId:" + book.title);
      } else {
        // create book and content url
        createBookByLink(link);
        console.log("No está");
        console.log("...................");
      }
    }).run();
  }
  Meteor.methods({
    dropboxSync: function () {
      if (Commons.isAdmin(this.userId)) {
        dropboxSync();
        // dropboxWallSync();
      }
    },
    dropboxWallSync: function () {
      if (Commons.isAdmin(this.userId)) {
        dropboxWallSync();
      }
    },
  });
}


### dropWall.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";

export const Photos = new Mongo.Collection("photos");

if (Meteor.isServer) {
  Meteor.publish("photos.dropWall", () => {
    return Photos.find({});
  });
}


### email.js
import { Meteor } from 'meteor/meteor'
import { UsersFunctions } from './users'

export const EMAIL = {
    METHOD_NAMES:{
        SEND_READERS_GROUP: "email.sendReadersGroup",
        SEND_TEST: "email.sendTest"
    }
}
if(Meteor.isServer){

    Meteor.methods({
        [EMAIL.METHOD_NAMES.SEND_TEST](){
            UsersFunctions.Checks.isAdmin(this.userId)
            Email.send({from:"admin@lalibreriamagica.com",to:"fernandomorenoruiz@gmail.com",text:"si te llega funciona bien el envio de emails"})
            Email.send({from:"admin@lalibreriamagica.com",to:"amortabango@gmail.com",text:"si te llega, funciona bien el envio de emails"})
        },
        [EMAIL.METHOD_NAMES.SEND_READERS_GROUP](sendConfig, readersGroup){
            UsersFunctions.Checks.isAdmin(this.userId)
            sendConfig.html = `<html>
                <body>
                    <div>
                        <h1 style="text-align:center">
                            <a href='${Meteor.absoluteUrl()+"readersGroup/" +readersGroup._id }'>Club de Lectura: ${readersGroup.name}</a>
                        </h1>
                        <div style="font-size:1.5rem;max-width:700px;margin:auto;white-space:pre-line">
                            ${sendConfig.text}
                        </div>
                        <div style="text-align:center;font-size:1.5rem;margin-top:1rem">
                            <a href='${Meteor.absoluteUrl()+"readersGroup/" +readersGroup._id }'>Haz click aquí para Ir a la Lectura</a>
                        </div>
                        <div style="text-align:center;font-size:1.2rem;margin-top:1rem">
                            <a href="www.lalibreriamagica.com">www.lalibreriamagica.com</a> tu lugar de lectura online.
                        </div>
                        <p style="text-align:center">
                            Si no quieres recibir más correos como este haz click <a href='${Meteor.absoluteUrl() + "readersGroup/" + readersGroup._id + "/unsubscribe"}/'>aquí</a>
                        </p>
                        <p style="text-align:center">
                            Si pulsando el enlace anterior aún sigues recibiendo emails, por favor, escribe al administrador directamente: fernandomorenoruiz@gmail.com
                        </p>
                    </div>
                </body>
            </html>`       
            sendConfig.from = "La Libreria Mágica <admin@lalibreriamagica.com>"
            return Email.send(sendConfig)
        }
    })

}

### messages.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { UsersFunctions } from "./users";

/* Los mensajes se guardan de uno en uno con el id del roomId
   porque así cuando el ddp de meteor se actualiza, solo se actualiza
   un nuevo registro y no todo el chat entero.
*/ 
export const Messages = new Mongo.Collection("messages");

export const MESSAGES = {
  PUBLISH_NAMES:{
    BY_ROOM_ID: "messages.byRoomId"
  },
  METHOD_NAMES:{
    SEND: "messages.send"
  }
}
if (Meteor.isServer) {
  Messages.rawCollection().createIndex({ roomId: -1 });

  Meteor.publish(MESSAGES.PUBLISH_NAMES.BY_ROOM_ID, function (roomId) {
    return Messages.find({ roomId: roomId });
  });
}

Meteor.methods({
  [MESSAGES.METHOD_NAMES.SEND](roomId, currentIndex, message, readingId) {
    UsersFunctions.Checks.isLogged(this.userId);
    let user = Meteor.users.findOne({_id:this.userId})
    let _message = {
      roomId: roomId,
      userId: this.userId,
      username:user.username,
      text: message,
      currentIndex: currentIndex,
      readingId:readingId,
      date: Date.now(),
    };
    return Messages.insert(_message);
  },
});


### messages.test.js
import { Meteor } from 'meteor/meteor'

import expect from 'expect'
import { MESSAGES, Messages } from './messages'

if(Meteor.isServer){
    describe('messages', function(){
        let newUser = {username:"fer",email:"fernandomorenoruiz@gmail.com",password:"hola"};
        beforeEach(function(){        
            Messages.remove({})  
            Meteor.users.remove({})
            newUser._id = Accounts.createUser(newUser)                      
        })

        it('should insert a message',function(){            
            const message = {
                userId: "HiaGReN7eTqpNzFHE",
                roomId: "1",
                text: " hola ",
                currentIndex: 12

            }
            expect(Meteor.server.method_handlers[MESSAGES.METHOD_NAMES.SEND].apply({userId:newUser._id},[message.roomId,message.currentIndex,message.text])).toBeDefined()
            
        })        
    })
}

### myBooks.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { ContentBooks, ContentBooksFunctions } from "./contentBooks";
import { Rooms } from "./rooms";
import { Commons } from "./commons";
import { Constants } from "../constants";
import { UsersFunctions } from "./users";
import { Books } from "./books";

export const MyBooks = new Mongo.Collection("myBooks");
export const MY_BOOKS = {
  METHOD_NAMES: {
    INSERT_WITH_CONTENT: "myBooks.insertWithContent",
    UPDATE_INDEX: "myBooks.updateIndex",
    INSERT: "myBooks.insert",
    REMOVE: "myBooks.remove",
    SET_ACTIVE: "myBooks.setActive",
    INC_TIMEINTERVAL: "myBooks.incTimeInterval",
    FIND_BY_BOOKID: "myBooks.findByBookId",
  },
  PUBLISH_NAMES:{
    ALL_ADMIN:"allMyBooks",
    USER:"myBooks",
    USER_WITH_CONTENT:"myBooks.byIdWithContent"
  }
};
if (Meteor.isServer) {
  Meteor.publish(MY_BOOKS.PUBLISH_NAMES.ALL_ADMIN, function () {
    if (Commons.isAdmin(this.userId)) {
      return MyBooks.find({}, { sort: { title: 1 } });
    } else {
      return [];
    }
  });
  Meteor.publish(MY_BOOKS.PUBLISH_NAMES.USER, function () {
    return MyBooks.find({ userId: this.userId }, { sort: { title: 1 } });
  });
  Meteor.publish(MY_BOOKS.PUBLISH_NAMES.USER_WITH_CONTENT, function (_id) {
    let myBook = MyBooks.findOne({ _id, userId: this.userId });
    return [
      MyBooks.find({ _id, userId: this.userId }),
      ContentBooks.find({ _id: myBook.contentId }),
    ];
  });
}

/*Attributes:
  _id
  userId
  bookId
  contenId
  active
  title
  speedReading
  length
  currentIndex
  intervalId
  trial
*/

var intervalsIdClient = {};

Meteor.methods({
  [MY_BOOKS.METHOD_NAMES.UPDATE_INDEX](myBookId, index) {
    UsersFunctions.Checks.isLogged(this.userId);
    //TODO check values myBook
    return MyBooks.update(
      { _id: myBookId, userId: this.userId },
      { $set: { currentIndex: index } }
    );
  },
  [MY_BOOKS.METHOD_NAMES.INSERT](myBook) {
    UsersFunctions.Checks.isLogged(this.userId);
    //TODO check values myBook
    myBook.userId = this.userId;
    myBook.trial = false;
    return MyBooks.insert(myBook);
  },
  [MY_BOOKS.METHOD_NAMES.REMOVE](myBookId) {
    UsersFunctions.Checks.isLogged(this.userId);
    //TODO check values myBook
    const myBook = MyBooks.findOne({ _id: myBookId, userId: this.userId });
    if (ContentBooks.remove(myBook.contentId) && MyBooks.remove(myBookId)) {
      Meteor.users.update(this.userId, {
        $inc: {
          storageUsed: -Commons.lengthToKBytesSize(myBook.length),
        },
      });
    }
    Rooms.remove({myBookId:myBookId})
    return true;
  },
  [MY_BOOKS.METHOD_NAMES.INSERT_WITH_CONTENT](myBook, content) {
    UsersFunctions.Checks.isLogged(this.userId);
    const sizeContent = Commons.calculateStringSize(content);
    UsersFunctions.Checks.isSpaceAvailable(this.userId, sizeContent);
    const contentId = ContentBooksFunctions.insert(content);
    try {
      UsersFunctions.incUsedStorage(this.userId, sizeContent);
    } catch (error) {
      ContentBooks.remove({ _id: contentId });
      throw error;
    }
    myBook.contentId = contentId;
    myBook.length = content.length;
    myBook.userId = this.userId;
    myBook.active = true;
    myBook.trial = false;
    myBook.speedReading = Constants.READING.READING_TIME_INTERVAL;
    myBook.currentIndex = Constants.READING.INITIAL_CURRENT_INDEX;

    return MyBooks.insert(myBook);
  },
  [MY_BOOKS.METHOD_NAMES.SET_ACTIVE](_id, activeValue) {
    UsersFunctions.Checks.isLogged(this.userId);
    return MyBooks.update({ _id }, { $set: { active: activeValue } });
  },
  [MY_BOOKS.METHOD_NAMES.INC_TIMEINTERVAL](_id, inc) {
    UsersFunctions.Checks.isLogged(this.userId);
    console.log("myBooks.incTimeInterval: id:" + _id);
    const result = MyBooks.update({ _id }, { $inc: { speedReading: inc } });
    console.log(result);
    return result;
  },
  [MY_BOOKS.METHOD_NAMES.FIND_BY_BOOKID](bookId) {
    UsersFunctions.Checks.isLogged(this.userId);
    return MyBooks.findOne({ bookId, userId: this.userId });
  },
});

export const MyBooksFunctions = {
  myBookOfBook(bookId,userId){
    return MyBooks.findOne({ bookId, userId: userId });
  },
  createMyBookOfBook(bookId,userId,index,actived){
    book = Books.findOne({_id:bookId})        
    let myBook = book;
    myBook.bookId = bookId
    myBook.userId = userId;    
    if(actived!==undefined){
      myBook.active = actived;
    }
    // myBook.active = true;
    myBook.speedReading = Constants.READING.READING_TIME_INTERVAL
    if(index){
      myBook.currentIndex = index  
    }else{
      myBook.currentIndex = Constants.READING.INITIAL_CURRENT_INDEX
    }
    myBook.trial = true;
    delete myBook._id
    return MyBooks.insert(myBook);
  },
  setActived(myBookId,actived){
    console.log("myBookId:" + myBookId)
    return MyBooks.update({ _id:myBookId }, { $set: { active: actived } });
    //return !!MyBooks.update({_id:myBookId},{$set:{active:actived}})
  }
}


### naturalchat.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { UsersFunctions } from "./users";

export const NaturalChat = new Mongo.Collection("naturalchat");

export const NATURAL_CHAT = {
  PUBLISH: {
    NATURAL_CHAT: "naturalchat",
  },
  METHODS: {
    SEND_MESSAGE: "naturalchat.sendMessage",
    CREATE_ROOM: "naturalchat.createRoom",
    CLEAN_CURRENT_USER: "naturalchat.cleanCurrentUser",
  },
};

if (Meteor.isServer) {
  NaturalChat.rawCollection().createIndex({ roomId: -1 });

  Meteor.publish(NATURAL_CHAT.PUBLISH.NATURAL_CHAT, function (id) {
    return NaturalChat.find({ roomId: id });
  });

  Meteor.methods({
    [NATURAL_CHAT.METHODS.SEND_MESSAGE](roomId, text) {
      UsersFunctions.Checks.isLogged(this.userId);
      let username = UsersFunctions.getUsernameById(this.userId);
      let room = NaturalChat.findOne({ roomId: roomId });
      if (room) {
        if (checkIfRoomIsAvailableToWriteByUser(room, this.userId)) {
          return NaturalChat.update(
            { roomId: roomId },
            {
              $set: {
                text: text,
                currentUser: Meteor.userId(),
                currentUsername: username,
              },
            }
          );
        }
        return null;
      }
      createNewRoom(roomId, text, this.userId);
    },
    [NATURAL_CHAT.METHODS.CREATE_ROOM](roomId) {
      if (!this.userId) {
        throw new Meteor.Error("not-authorized");
      }
      createNewRoom(roomId, "", this.userId);
    },
    [NATURAL_CHAT.METHODS.CLEAN_CURRENT_USER](roomId) {
      if (!this.userId) {
        throw new Meteor.Error("not-authorized");
      }
      NaturalChat.update(
        { roomId: roomId },
        { $set: { currentUser: "", currentUsername: "" } }
      );
    },
  });

  function checkIfRoomIsAvailableToWriteByUser(room, userId) {
    if (room.currentUser === userId || room.currentUser === "") {
      return true;
    } else {
      return false;
    }
  }

  function createNewRoom(roomId, text, userId) {
    let _id = NaturalChat.insert({
      text: text,
      roomId: roomId,
      users: [userId],
      currentUser: userId,
      currentUsername: UsersFunctions.getUsernameById(userId),
      bgColor: "white",
      fontColor: "black",
      createdAt: new Date(),
    });
    return NaturalChat.findOne({ _id });
  }
}


### readersGroups.js
import { Mongo } from 'meteor/mongo'
import { Meteor } from 'meteor/meteor'
import { Random } from 'meteor/random'
import { UsersFunctions } from './users'
import _ from 'lodash'

export const ReadersGroups = new Mongo.Collection("readersGroup")

export const READERS_GROUPS = {
    PUBLISH_NAMES:{
        MINE:"readersGroups.mine",
        BY_ID: "readersGroups.byId",
        ALL: "readersGroups.all",
        ALL_NAMES: "readersGroups.allNames"
    },
    METHODS_NAMES:{
        CREATE: "readersGroups.create",
        UPDATE: "readersGroups.update",
        RESET_READING: "readersGroups.resetReading",
        DELETE: "readersGroups.delete",
        JOIN: "readersGroups.join",
        ADD_MEETING_TIME: "readersGroups.addMeetingTime",
        REMOVE_MEETING_TIME: "readersGroups.removeMeetingTime",
        JOIN_TO_MEETING: "readersGroups.joinToMeeting",
        QUIT_TO_MEETING: "readersGroups.quitToMeeting",
        ARCHIVE_READING: "readersGroups.archiveReading",
        UNSUBSCRIBE_EMAIL: "readersGroups.unsubscribeEmail"
    }
}
if(Meteor.isServer){
    
    Meteor.publish(READERS_GROUPS.PUBLISH_NAMES.ALL,function(){
        UsersFunctions.Checks.isAdmin(this.userId)
        return ReadersGroups.find({})
    })

    Meteor.publish(READERS_GROUPS.PUBLISH_NAMES.ALL_NAMES,function(){        
        return ReadersGroups.find({},{fields:{_id:1,name:1}})
    })

    Meteor.publish(READERS_GROUPS.PUBLISH_NAMES.BY_ID,function(id){
        return ReadersGroups.find({_id:id})
    })
    
    Meteor.publish(READERS_GROUPS.PUBLISH_NAMES.MINE,function(){
        return ReadersGroups.find({
            members:{$elemMatch:{userId:this.userId}}
        })
    })

    Meteor.methods({

        [READERS_GROUPS.METHODS_NAMES.CREATE](name){  

            UsersFunctions.Checks.isAdmin(this.userId)
            
            //if name exist throw an exception          
            ReadersGroupsDBFunctions.Checks.duplicatedName(name)
            
            return ReadersGroupsDBFunctions.create(name,this.userId)

        },
        [READERS_GROUPS.METHODS_NAMES.UPDATE](readersGroup){  

            UsersFunctions.Checks.isAdmin(this.userId)        
            
            return ReadersGroupsDBFunctions.update(readersGroup)

        },
        [READERS_GROUPS.METHODS_NAMES.RESET_READING](_id){  

            UsersFunctions.Checks.isAdmin(this.userId)        
            
            return ReadersGroupsDBFunctions.resetReading(_id)

        },
        [READERS_GROUPS.METHODS_NAMES.DELETE](readersGroupId){  

            UsersFunctions.Checks.isAdmin(this.userId)        
            
            return ReadersGroupsDBFunctions.delete(readersGroupId)

        },
        [READERS_GROUPS.METHODS_NAMES.JOIN_TO_MEETING](readersGroupId, meetingId){  

            UsersFunctions.Checks.isLogged(this.userId)        
            
            return ReadersGroupsDBFunctions.joinToMeeting(readersGroupId,meetingId,this.userId)

        },
        [READERS_GROUPS.METHODS_NAMES.QUIT_TO_MEETING](readersGroupId, meetingId){  

            UsersFunctions.Checks.isLogged(this.userId)        
            
            return ReadersGroupsDBFunctions.quitToMeeting(readersGroupId,meetingId,this.userId)

        },
        [READERS_GROUPS.METHODS_NAMES.JOIN](readersGroupId){  

            UsersFunctions.Checks.isLogged(this.userId)        
            
            return ReadersGroupsDBFunctions.join(readersGroupId,this.userId)

        },
        [READERS_GROUPS.METHODS_NAMES.ADD_MEETING_TIME](readersGroupId,date,duration){  

            UsersFunctions.Checks.isAdmin(this.userId)        
            let meetingTime = ReadersGroupsFunctions.createMeetingTime(date,duration)
            return ReadersGroupsDBFunctions.addMeetingTime(readersGroupId, meetingTime)

        },
        [READERS_GROUPS.METHODS_NAMES.REMOVE_MEETING_TIME](readersGroupId,meetingTimeId){  

            UsersFunctions.Checks.isAdmin(this.userId)                    
            return ReadersGroupsDBFunctions.removeMeetingTime(readersGroupId, meetingTimeId)

        }
        ,
        [READERS_GROUPS.METHODS_NAMES.ARCHIVE_READING](readersGroup){  

            UsersFunctions.Checks.isAdmin(this.userId)    
            let archivedReading = ReadersGroupsFunctions.getCurrentReading(readersGroup)                         
            archivedReading.createdAt = new Date()
            return ReadersGroupsDBFunctions.pushPastReading(readersGroup._id,archivedReading)

        },
        [READERS_GROUPS.METHODS_NAMES.UNSUBSCRIBE_EMAIL](readersGroupId){  
            UsersFunctions.Checks.isLogged(this.userId)
            return ReadersGroups.update({_id:readersGroupId,"members.userId":this.userId}
            , {$set:{"members.$.unsubscribeEmail":true, "members.$.unsubscribeEmailDate":new Date()}})                        
        }

    })

}

export const ReadersGroupsFunctions = {
    create(name,ownerId){
        const result = {name}
        result.book = {_id:"",title:"",author:""}
        result.readingId = Random.id()
        result.myBook = {_id:"",title:"",author:""}
        result.ownerId = ownerId
        result.members = []
        result.meetingTimes = []
        result.pastReadings = []
        result.startDate = null
        result.endDate = null
        result.createdAt = new Date();     
        return result   
    },
    createMeetingTime(date , duration){
        return {_id:Random.id(), date, duration,people:[]}
    },
    addMeetingTime(readersGroup,date){
        const meetingTime = {date}
        readersGroup.meetingTimes.push(meetingTime)
    },
    addMember(readersGroup,user){
        return readersGroup.members.push(this.createMemberFromUser(user))
    },
    createMemberFromUser(user){

        const member = {
            userId:user._id,
            username:user.username,
            email: user.emails[0].address,
            admin: user.admin,
            createdAt: new Date()
        }
        return member
    },
    getCurrentReading(readersGroup){
        const {readingId, startDate, endDate, book, members, meetingTimes} = readersGroup
        return {_id: readingId, startDate, endDate, book, members, meetingTimes}
    }
}

export const ReadersGroupsDBFunctions = {
    create(name,userId){        
        if(!this.existByName(name)){            
            const readersGroup = ReadersGroupsFunctions.create(name,userId)            
            const user = UsersFunctions.getUserById(userId)
            ReadersGroupsFunctions.addMember(readersGroup,user)            
            return ReadersGroups.insert(readersGroup)
        }
    },
    update(groupReader){
        const _id = groupReader._id        
        return ReadersGroups.update({_id},groupReader)
    },
    resetReading(_id){              
        return ReadersGroups.update({_id},{$set:{
            startDate:Date.now(),
            endDate:Date.now(),
            readingId: Random.id(),
            meetingTimes:[],
            book:{},
            myBook:{},

        }})
    },
    pushPastReading(_id,pastReading){
        return ReadersGroups.update({_id},{$push:{pastReadings:pastReading}})
    },
    join(groupReaderId,userId){
        let user = UsersFunctions.getUserById(userId)
        let member = ReadersGroupsFunctions.createMemberFromUser(user)
        return ReadersGroups.update({_id:groupReaderId},{$push:{members:member}})
    },
    joinToMeeting(groupReaderId, meetingId, userId){
        console.log("meetingId:" + meetingId)  
        let readersGroup = ReadersGroups.findOne({_id:groupReaderId})         
        if(!this.meetingContainsUser(readersGroup.meetingTimes,meetingId,userId)   ){
            let user = UsersFunctions.getUserById(userId)            
            let member = ReadersGroupsFunctions.createMemberFromUser(user)            
            return ReadersGroups.update({_id:groupReaderId, "meetingTimes._id":meetingId},{$push:{"meetingTimes.$.people":member}})
        }
    },
    meetingContainsUser(meetings, meetingId, userId){
        let meeting = _.find(meetings,(m)=>{return m._id===meetingId})        
        return !!_.find(meeting.people,(p)=>{ return p-userId===userId})
    },
    quitToMeeting(groupReaderId, meetingId, userId){                            
        console.log("meetingId:" + meetingId)
        console.log(userId)          
        return ReadersGroups.update(
            {_id:groupReaderId, "meetingTimes._id":meetingId },
            { $pull : {"meetingTimes.$.people":{"meetingTimes.$.people.$.userId":userId}}}
        )
    },
    delete(readersGroupId){
        return ReadersGroups.remove({_id:readersGroupId})
    },
    existByName(name){
        return !!ReadersGroups.findOne({name})
    },
    addMember(readersGroupId,user){
        const member = ReadersGroupsFunctions.createMemberFromUser(user)
        ReadersGroups.update({_id:readersGroupId},{$push:{members:member}})
    },
    addMeetingTime(readersGroupId,meetingTime){
        return ReadersGroups.update({_id:readersGroupId},{$push:{meetingTimes:meetingTime}})
    },
    removeMeetingTime(readersGroupId,meetingTimeId){
        return ReadersGroups.update({_id:readersGroupId},{$pull:{meetingTimes:{_id:meetingTimeId}}})
    },
    Checks:{
        duplicatedName(name){
            if(ReadersGroupsDBFunctions.existByName(name)){
                throw new Meteor.Error("Grupo Duplicado","El nombre del grupo ya existe.")
            }
        },
        isGroupMember(readersGroupId,userId){
            if(!ReadersGroups.findOne({_id:readersGroupId, members:{$elemMatch:{userId:userId}}})){
                throw new Meteor.Error("No perteneces al grupo","Debes unirte al grupo de lectura para hacer esta acción.")
            }
        }
    }
}

### rooms.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
import { MyBooks, MyBooksFunctions } from "./myBooks";
import { Constants } from "../constants";
import { ContentBooks } from "./contentBooks";
import { Commons } from "./commons";
import { UsersFunctions } from "./users";
import { READER_STATUS } from "../ui/reading/Reader";
import { Comments } from "./comments";
import { Messages } from "./messages";
import { Words } from "./words";

export const Rooms = new Mongo.Collection("rooms");

const STEP_SIZE = Constants.READING.STEP_SIZE;
const STEP_TIME_INTERVAL = Constants.READING.STEP_TIME_INTERVAL;

export const ROOMS = {
  PUBLISH_NAME: {
    INVITATIONS: "invitations",
    ROOMS: "rooms",
    READERSGROUP: "rooms.readersGroup",
    READERSGROUP_OF_USER: "rooms.readersGroupOfUser",
    ALL_ROOMS: "allRooms",
    BY_ID_WITH_CONTENT: "rooms.byIdWithContent",
  },
  METHOD_NAMES: {
    START_READING: "startReadingOnServer",
    SEND_MESSAGE: "room.sendMessage",
    CREATE_FROM_BOOK: "room.createOfBook",
    CREATE_FROM_BOOKS: "room.createOfBooks",
    CREATE_FROM_MY_BOOK: "room.createOfMyBook",
    INVITE: "room.invite",
    ACCEPT_INVITATION: "rooms.acceptInvitation",
    REJECT_INVITATION: "rooms.rejectInvitation",
    REWIND: "rewind",
    REMOVE: "rooms.remove",
    EXIT: "room.exit",
    SET_USERSTATUS: "rooms.setUserStatus",
    INC_TIMEINTERVAL: "room.incTimeInterval",
    SET_ARCHIVED: "room.archive",
    PAUSE_READING: "pauseReading",
    SET_NIGHTMODE: "room.nightMode",
    UPDATE_INDEX: "room.updateIndex",
    UPDATE_PROGRESS: "room.updateProgress",
    CHANGE_STATUS: "room.changeStatus",
    SET_PRICE_PER_PAGE: "room.setPricePerPage",
    SET_LAST_PAID_INDEX: "room.setLastPaidIndex",
  },
  USER_STATUS: {
    ON: {
      value: "on",
      description: "Estoy listo",
      color: "#57F052",
    },
    OFF: {
      value: "off",
      description: "No estoy listo",
      color: "#F96666",
    },
    ONE_MOMENT: {
      value: "onemoment",
      description: "Un momento",
      color: "orange",
    },
    RE_READING: {
      value: "reReading",
      description: "Estoy Releyendo",
      color: "orange",
    },
  },
  STATUS: {
    READY: "ready",
    PAUSED: "paused",
    RE_READING: "reReading",
  },
};
var intervalsIdServer = {};
/*
--Room--
  participants -> array of users participants {userId,email,status} (status : [on] [off] [meaning])
  bookId -> Id of the book
  myBookId -> Id of myBook
  invitations -> array of user invitations
  currentIndex -> reading index
  contentId -> content id of the book or mybook
  title -> title of the book
  length -> length of the book
  speed -> Speed reading in the room
  state -> 'ready','notready','running','stopped','locked' ?¿??
  on Invitation accepted the userId is removed from invitations
  and added to participants
*/
export const userStatusToString = (status) => {
  const toString = {
    on: ROOMS.USER_STATUS.ON.description,
    off: ROOMS.USER_STATUS.OFF.description,
    onemoment: ROOMS.USER_STATUS.ONE_MOMENT.description,
    reReading: ROOMS.USER_STATUS.RE_READING.description,
  };
  return toString[status];
};
export const statusToColor = (status) => {
  const toString = {
    on: ROOMS.USER_STATUS.ON.color,
    off: ROOMS.USER_STATUS.OFF.color,
    onemoment: ROOMS.USER_STATUS.ONE_MOMENT.color,
    reReading: ROOMS.USER_STATUS.RE_READING.color,
  };
  return toString[status];
};

export const statusToRoomState = (status) => {
  const toString = {
    on: ROOMS.STATUS.READY,
    off: ROOMS.STATUS.PAUSED,
    onemoment: ROOMS.STATUS.PAUSED,
    reReading: ROOMS.STATUS.RE_READING,
  };
  return toString[status];
};

if (Meteor.isServer) {
  Meteor.publish(ROOMS.PUBLISH_NAME.INVITATIONS, function () {
    return Rooms.find({
      invitations: { $elemMatch: { userId: this.userId } },
    });
  });

  Meteor.publish(ROOMS.PUBLISH_NAME.ROOMS, function () {
    return Rooms.find({
      participants: { $elemMatch: { userId: this.userId } },
    });
  });
  Meteor.publish(ROOMS.PUBLISH_NAME.READERSGROUP, function (readersGroupId) {
    return Rooms.find({
      readersGroupId,
    });
  });
  Meteor.publish(
    ROOMS.PUBLISH_NAME.READERSGROUP_OF_USER,
    function (readersGroupId) {
      return Rooms.find({
        readersGroupId,
        participants: { $elemMatch: { userId: this.userId } },
      });
    }
  );

  Meteor.publish(ROOMS.PUBLISH_NAME.ALL_ROOMS, function () {
    if (Commons.isAdmin(this.userId)) {
      return Rooms.find({});
    }
    return [];
  });

  Meteor.publish(ROOMS.PUBLISH_NAME.BY_ID_WITH_CONTENT, function (roomId) {
    let room = Rooms.findOne({
      _id: roomId,
    });
    if (room.isOwnControl === true || room.readersGroupId) {
      return [
        Rooms.find({
          _id: roomId,
        }),
        ContentBooks.find({ _id: room.contentId }),
      ];
    } else {
      return [
        Rooms.find({
          _id: roomId,
          participants: { $elemMatch: { userId: this.userId } },
        }),
        ContentBooks.find({ _id: room.contentId }),
      ];
    }
  });
}
if (Meteor.isServer) {
  Meteor.methods({
    [ROOMS.METHOD_NAMES.UPDATE_PROGRESS](roomId, progress, currentIndex) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("currentIndex:" + typeof currentIndex);
      console.log(roomId);
      return Rooms.update(
        { _id: roomId, ownerId: this.userId },
        { $set: { progress: progress, currentIndex: parseInt(currentIndex) } }
      );
    },
    [ROOMS.METHOD_NAMES.UPDATE_INDEX](roomId, index) {
      UsersFunctions.Checks.isLogged(this.userId);
      return Rooms.update(
        { _id: roomId, ownerId: this.userId },
        { $set: { currentIndex: index } }
      );
    },
    [ROOMS.METHOD_NAMES.CREATE_FROM_BOOK](bookId, isOwnControl) {
      UsersFunctions.Checks.isLogged(this.userId);
      let myBook = MyBooksFunctions.myBookOfBook(bookId, this.userId);
      console.log(myBook);
      let myBookId;
      if (!myBook) {
        myBookId = MyBooksFunctions.createMyBookOfBook(
          bookId,
          this.userId,
          true
        );
        myBook = MyBooks.findOne({ _id: myBookId });
      } else {
        myBookId = myBook._id;
      }
      const user = Meteor.users.findOne({ _id: this.userId });
      let room = RoomsFunctions.createRoom(user, myBook);
      room.isOwnControl = isOwnControl;
      return !!Rooms.insert(room);
    },
    [ROOMS.METHOD_NAMES.CREATE_FROM_BOOKS](booksWithIndex) {
      console.log("CREATE_FROM_BOOKS");
      UsersFunctions.Checks.isLogged(this.userId);
      const user = Meteor.users.findOne({ _id: this.userId });
      let result = [];
      console.log(booksWithIndex);
      booksWithIndex.map((bookIdAndIndex) => {
        let bookId = bookIdAndIndex.bookId;
        let index = parseInt(bookIdAndIndex.currentIndex);
        myBookId = MyBooksFunctions.createMyBookOfBook(
          bookId,
          this.userId,
          index,
          true
        );
        myBook = MyBooks.findOne({ _id: myBookId });
        let room = RoomsFunctions.createRoom(user, myBook);
        room.isOwnControl = false;
        result.push(Rooms.insert(room));
      });
      return result;
    },
    [ROOMS.METHOD_NAMES.CREATE_FROM_MY_BOOK](myBookId, isOwnControl) {
      UsersFunctions.Checks.isLogged(this.userId);
      const myBook = MyBooks.findOne(
        { _id: myBookId },
        { fields: { length: 1, title: 1, contentId: 1, folder: 1 } }
      );
      // if (
      //   Rooms.findOne({
      //     participants: { $elemMatch: { userId: this.userId } },
      //     contentId: myBook.contentId,
      //   })
      // ) {
      //   throw new Meteor.Error(400, "Ya estás en una sala con este libro");
      // }
      const user = Meteor.users.findOne({ _id: this.userId });
      let room = RoomsFunctions.createRoom(user, myBook);
      room.isOwnControl = isOwnControl;
      return Rooms.insert(room);
    },
    [ROOMS.METHOD_NAMES.INVITE](myRoomId, _user) {
      let { username, email } = _user;
      console.log("email:" + email);
      console.log("username:" + username);
      if (Meteor.isServer) {
        UsersFunctions.Checks.isLogged(this.userId);
        let roomFound;
        if (email) {
          roomFound = RoomsFunctions.getRoomByIdAndEmail(myRoomId, email);
        }
        if (username) {
          roomFound = RoomsFunctions.getRoomByIdAndUsername(myRoomId, username);
        }
        if (roomFound) {
          throw new Meteor.Error(400, "El usuario ya ha sido invitado.");
        }
        //TODO check values

        let user = null;
        const userProjection = {
          fields: { _id: 1, emails: 1, username: 1, admin: 1 },
        };
        if (email) {
          console.log("email:" + email);
          user = UsersFunctions.getUserByEmail(email, userProjection);
        }
        if (username) {
          user = UsersFunctions.getUserByUsername(username, userProjection);
        }
        console.log(user);

        let invitation = {};
        invitation.userId = user._id;
        invitation.email = user.emails[0].address;
        if (user.username) {
          invitation.username = user.username;
        }
        if (user.admin) {
          invitation.admin = user.admin;
        }
        invitation.date = Date.now();
        Rooms.update(
          { _id: myRoomId },
          { $addToSet: { invitations: invitation } }
        );
      }
    },
    [ROOMS.METHOD_NAMES.ACCEPT_INVITATION](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      const room = Rooms.findOne({
        _id: roomId,
        invitations: { $elemMatch: { userId: this.userId } },
      });
      let invitation = _.findWhere(room.invitations, { userId: this.userId });
      let participant = {};
      participant.userId = invitation.userId;
      participant.email = invitation.email;
      participant.username = invitation.username;
      participant.status = "off";
      participant.archived = false;
      if (invitation) {
        participant.admin = invitation.admin;
      }
      let result = Rooms.update(
        {
          _id: roomId,
          invitations: { $elemMatch: { userId: this.userId } },
        },
        { $push: { participants: participant } },
        { $pull: { invitations: { userId: this.userId } } }
      );
      result = Rooms.update(
        {
          _id: roomId,
          invitations: { $elemMatch: { userId: this.userId } },
        },
        { $pull: { invitations: { userId: this.userId } } }
      );

      return result;
    },
    [ROOMS.METHOD_NAMES.REJECT_INVITATION](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      const result = Rooms.update(
        {
          _id: roomId,
          invitations: { $elemMatch: { userId: this.userId } },
        },
        { $pull: { invitations: { userId: this.userId } } }
      );
      return result;
    },
    [ROOMS.METHOD_NAMES.EXIT](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      return Rooms.update(
        { _id: roomId },
        { $pull: { participants: { userId: this.userId } } }
      );
    },
    [ROOMS.METHOD_NAMES.REMOVE](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      return Rooms.remove({ _id: roomId, ownerId: this.userId });
    },
    [ROOMS.METHOD_NAMES.SET_USERSTATUS](roomId, status) {
      UsersFunctions.Checks.isLogged(this.userId);
      if (userStatusToString(status) === undefined) {
        throw new Meteor.Error(400, "El status es incorrecto.");
      }
      return Rooms.update(
        { _id: roomId, "participants.userId": this.userId },
        {
          $set: {
            "participants.$.status": status,
            state: statusToRoomState(status),
          },
        }
      );
    },
    [ROOMS.METHOD_NAMES.INC_TIMEINTERVAL](_id, inc) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("Rooms.incTimeInterval: id:" + _id);
      const result = Rooms.update({ _id }, { $inc: { speedReading: inc } });
      console.log(result);
      return result;
    },
    [ROOMS.METHOD_NAMES.SET_ARCHIVED](roomId, value) {
      UsersFunctions.Checks.isLogged(this.userId);
      return Rooms.update(
        { _id: roomId, "participants.userId": this.userId },
        { $set: { "participants.$.archived": value } }
      );
    },
    [ROOMS.METHOD_NAMES.CHANGE_STATUS](roomId, status) {
      UsersFunctions.Checks.isLogged(this.userId);
      const room = Rooms.findOne({
        _id: roomId,
        participants: { $elemMatch: { userId: this.userId } },
      });
      if (room) {
        const result = Rooms.update(
          { _id: roomId },
          {
            $set: {
              state: status,
            },
          }
        );
      }
    },
    [ROOMS.METHOD_NAMES.START_READING](roomId, timeInterval) {
      UsersFunctions.Checks.isLogged(this.userId);
      RoomsFunctions.stopIndexInterval(roomId);
      const step = STEP_SIZE;
      if (timeInterval <= 80) {
        timeInterval = 80;
      }
      const room = Rooms.findOne({
        _id: roomId,
        participants: { $elemMatch: { userId: this.userId } },
      });

      if (room) {
        console.log("startReading");
        let trialParticipants = RoomsFunctions.trialChecking(room.participants);
        const result = Rooms.update(
          { _id: roomId },
          {
            $set: {
              state: READER_STATUS.RUNNING,
              trialParticipants: trialParticipants,
            },
          }
        );
        console.log("result: " + result + " timeInterval:" + room.speedReading);

        ReadingFunctions.linealReading(room, step);
      }
    },
    [ROOMS.METHOD_NAMES.PAUSE_READING](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      RoomsFunctions.stopIndexInterval(roomId);
      Rooms.update({ _id: roomId }, { $set: { state: READER_STATUS.PAUSED } });
    },
    [ROOMS.METHOD_NAMES.REWIND](roomId) {
      UsersFunctions.Checks.isLogged(this.userId);
      //changeIndexWithInterval(roomId, STEP_TIME_INTERVAL, -STEP_SIZE);
      const room = Rooms.findOne({
        _id: roomId,
        participants: { $elemMatch: { userId: this.userId } },
      });
      if (room.currentIndex <= 0) {
        return;
      }
      if (room) {
        console.log("startReadingOnServerAux");
        //console.log("result: " + result + " timeInterval:" + timeInterval);
        let currentIndex = room.currentIndex;
        intervalsIdServer[roomId] = Meteor.setInterval(() => {
          if (currentIndex <= 0) {
            RoomsFunctions.stopIndexInterval(roomId);
            return;
          }
          Rooms.update({ _id: roomId }, { $inc: { currentIndex: -1 } });
          currentIndex -= 1;
        }, STEP_TIME_INTERVAL);
      }
    },
    [ROOMS.METHOD_NAMES.SET_NIGHTMODE](roomId, value) {
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("nightMode:" + value);
      const room = Rooms.findOne({ _id: roomId });
      if (value) {
        if (!room.currentIndexBack || room.currentIndexBack === -1) {
          Rooms.update(
            { _id: roomId },
            { $set: { currentIndexBack: room.currentIndex } }
          );
        }
      } else {
        if (room.currentIndexBack) {
          Rooms.update(
            { _id: roomId },
            {
              $set: {
                currentIndex: room.currentIndexBack,
                currentIndexBack: -1,
              },
            }
          );
        }
      }
    },
    [ROOMS.METHOD_NAMES.SET_PRICE_PER_PAGE](roomId, pricePerPage) {
      UsersFunctions.Checks.isLogged(this.userId);
      return Rooms.update(
        { _id: roomId },
        { $set: { pricePerPage: pricePerPage } }
      );
    },
    [ROOMS.METHOD_NAMES.SET_LAST_PAID_INDEX](roomId, lastPaidIndex) {
      UsersFunctions.Checks.isLogged(this.userId);

      console.log("roodId:" + roomId + " lastPaidIndex: " + lastPaidIndex);
      return Rooms.update(
        { _id: roomId },
        { $set: { lastPaidIndex: lastPaidIndex } }
      );
    },
  });
}
export const ReadingFunctions = {
  linealReading(room, step) {
    intervalsIdServer[room._id] = Meteor.setInterval(() => {
      if (room.currentIndex >= room.length) {
        console.log(room);
        if (room.isOwnControl) {
          Rooms.update({ _id: room._id }, { currentIndex: 0 });
        } else {
          stopIndexInterval(room._id);
        }
        return;
      }
      Rooms.update({ _id: room._id }, { $inc: { currentIndex: step } });
    }, room.speedReading);
  },
  waveReading(room, step) {
    console.log("wave reading");
    intervalsIdServer[room._id] = { wave: true };

    function waveReadingAux(room, step) {
      console.log("waveReadingAux");
      if (room.currentIndex >= room.length) {
        stopIndexInterval(room._id);
        return;
      }
      Rooms.update({ _id: room._id }, { $inc: { currentIndex: step } });
      // let findRoom = Rooms.findOne({ _id: room._id });

      // const frecuencia = 0.1;
      if (intervalsIdServer[room._id]) {
        console.log(room.currentIndex);
        // let speedInWave =
        //   (Math.abs(Math.sin(frecuencia * findRoom.currentIndex)) *
        //     room.speedReading) /
        //     2 +
        //   room.speedReading / 2;
        // console.log(speedInWave);
        Meteor.setTimeout(() => {
          waveReadingAux(room, step);
        }, room.speedReading);
      }
    }

    Meteor.setTimeout(() => {
      waveReadingAux(room, step);
    }, room.speedReading);
  },
};
export const RoomsFunctions = {
  stopIndexInterval(roomId) {
    if (Meteor.isServer) {
      Meteor.clearInterval(intervalsIdServer[roomId]);
      delete intervalsIdServer[roomId];
    }
  },
  changeRoomStatus(roomId, status) {
    return Rooms.update(
      { _id: roomId },
      {
        $set: {
          state: status,
        },
      }
    );
  },
  getRoomByIdAndEmail(myRoomId, email) {
    return Rooms.findOne({
      $or: [
        {
          _id: myRoomId,
          invitations: { $elemMatch: { email } },
        },
        {
          _id: myRoomId,
          participants: {
            $elemMatch: { email, archived: false },
          },
        },
      ],
    });
  },
  getRoomByIdAndUsername(myRoomId, username) {
    return Rooms.findOne({
      $or: [
        {
          _id: myRoomId,
          invitations: { $elemMatch: { username } },
        },
        {
          _id: myRoomId,
          participants: {
            $elemMatch: { username, archived: false },
          },
        },
      ],
    });
  },
  createRoom(user, myBook, readersGroupId, readingId) {
    let room = myBook;
    room.myBookId = room._id;
    delete room._id;
    room.ownerId = user._id;
    room.pricePerPage = 0.5;
    room.setLastPaidIndex = 0;
    room.ownerEmail = user.emails[0].address;
    room.participants = [
      {
        userId: user._id,
        email: user.emails[0].address,
        username: user.username,
        admin: user.admin,
        status: ROOMS.USER_STATUS.OFF.value,
        archived: false,
      },
    ];
    room.readersGroupId = readersGroupId;
    room.readingId = readingId;
    if (myBook.currentIndex) {
      room.currentIndex = myBook.currentIndex;
    } else {
      room.currentIndex = Constants.READING.INITIAL_CURRENT_INDEX;
    }
    room.currentIndexBack = -1;
    room.invitations = [];
    room.createdAt = new Date();
    room.speedReading = Constants.READING.READING_TIME_INTERVAL;
    room.state = READER_STATUS.PAUSED;
    room.trialParticipants = RoomsFunctions.trialChecking(
      room.participants,
      myBook.bookId
    );
    return room;
  },
  trialChecking(participants, bookId) {
    let noTrialParticipants = [];
    for (let participant in participants) {
      let myBook = MyBooks.find({
        userId: participants[participant].userId,
        bookId: bookId,
      });
      if (!myBook.trial) {
        noTrialParticipants.push(participants[participant]);
      }
    }
    return noTrialParticipants;
  },
  getRoomsByParticipantAndBookId(userId, bookId) {
    const rooms = Rooms.find({
      bookId: bookId,
      participants: { $elemMatch: { userId: userId } },
    }).fetch();
    return rooms;
  },
  getRoomsByParticipantBookIdReadersGroupId(userId, bookId, readersGroupId) {
    const rooms = Rooms.find({
      bookId: bookId,
      readersGroupId,
      participants: { $elemMatch: { userId: userId } },
    }).fetch();
    return rooms;
  },
  getRoomsByParticipantBookIdReadingId(userId, bookId, readingId) {
    const rooms = Rooms.find({
      bookId: bookId,
      readingId,
      participants: { $elemMatch: { userId: userId } },
    }).fetch();
    return rooms;
  },
  removeAllRoomsBookId(bookId) {
    Rooms.find({ bookId })
      .fetch()
      .map((room) => {
        Comments.remove({ roomId: room._id });
        Messages.remove({ roomId: room._id });
        Words.remove({ roomId: room._id });
      });
    return Rooms.remove({ bookId });
  },
};


### users.js
import { Meteor } from "meteor/meteor";
import { Accounts } from "meteor/accounts-base";
import SimpleSchema from "simpl-schema";
import { Constants, ErrorMessage } from "../constants";
import { Commons } from "./commons";
import { MyBooks } from "./myBooks";
import { Messages } from "./messages";
import { ContentBooks } from "./contentBooks";
import { Rooms } from "./rooms";
import { Words } from "./words";
import { Comments } from "./comments";

export const USERS = {
  PUBLISH_NAMES: {
    ALL_USERS_NAMES: "users.all_user_names",
    CONNECTED: "users.connected"
  }
}

export const validateNewUser = (user) => {
  const email = user.emails[0].address;
  try {
    new SimpleSchema({
      email: {
        type: String,
        regEx: SimpleSchema.RegEx.Email,
      },
    }).validate({ email });
  } catch (e) {
    throw new Meteor.Error(400, e.message);
  }
  return true;
}
if (Meteor.isServer) {
  
  Accounts.urls.resetPassword = function(token){
    return Meteor.absoluteUrl('reset-password/' + token)
  }

  Accounts.emailTemplates.siteName = "La Librería Mágica"

  Accounts.emailTemplates.from = "admin@lalibreriamagica.com"

  Accounts.emailTemplates.resetPassword = {
      subject(){
        return "Recupera tu cuenta de La Librería Mágica"
      },
      text(user,url){
        return `Haz click en este enlace para poder acceder a tu cuenta. \n${url}`

      }
  }

  Meteor.publish("allUsers", function () {
    if (Commons.isAdmin(this.userId)) {
      return Meteor.users.find({});
    } else {
      return [];
    }
  });

  Meteor.publish(USERS.PUBLISH_NAMES.ALL_USERS_NAMES, function () {
    return Meteor.users.find({},      
      { fields: { username: 1, status: 1, admin:1 } }
    );
  });
  
  Accounts.validateNewUser(validateNewUser);

  Accounts.onCreateUser((options, user) => {
    let customizedUser = Object.assign(
      {
        storageUsed: 0,
        storageLimit: Constants.STORAGE.LIMIT_OF_FREE_USERS,
      },
      user
    );

    // We still want the default hook's 'profile' behavior.
    if (options.profile) {
      customizedUser.profile = options.profile;
    }
    return customizedUser;
  });

  Meteor.methods({
    "users.remove"(id) {
      if (Commons.isAdmin(this.userId)) {
        Meteor.users.remove({ _id: id });
        MyBooks.remove({ userId: id });
        Messages.remove({ userId: id });
        ContentBooks.remove({ ownerId: id });
        Rooms.remove({ ownerId: id });
        Rooms.update(
          { invitations: { $elemMatch: { userId: id } } },
          { $pull: { invitations: { userId: id } } }
        );
        Rooms.update(
          { participants: { $elemMatch: { userId: id } } },
          { $pull: { participants: { userId: id } } }
        );
        Comments.remove({ userId: id });
        Words.remove({ userId: id });
        console.log("removed user: " + id);
      }
    },
    "users.status.setCurrentPath"(currentPath) {
      console.log(this.userId);
      UsersFunctions.Checks.isLogged(this.userId);
      console.log("update user currentPath");
      const result = Meteor.users.update(
        { _id: this.userId },
        { $set: { "status.currentPath": currentPath } }
      );
      console.log(result);
      return result;
    },
  });
}
export const UsersFunctions = {
  incUsedStorage(userId, sizeContent) {
    Meteor.users.update(userId, {
      $inc: { storageUsed: sizeContent },
    });
  },
  getUserByEmail(email,projection){
    let user;
    if(projection){
      user = Meteor.users.findOne(
        { emails: { $elemMatch: { address:email } } },
        projection
      );
      
    }
    return Meteor.users.findOne({emails:{ $elemMatch:{address:email}}})
  },
  getUserByUsername(username,projection){
    if(projection){
      return Meteor.users.findOne({username},projection)
    }
    return Meteor.users.findOne(username)
  }
  ,
  getEmailById(userId) {
    console.log("getEmailById:" + userId);
    return Meteor.users.findOne({ _id: userId }).emails[0].address;
  },
  getUserById(userId) {    
    return Meteor.users.findOne({ _id: userId });
  },
  getUsernameById(userId) {    
    return Meteor.users.findOne({ _id: userId }).username;
  },  
  Checks: {
    isSpaceAvailable(userId, sizeContent) {
      const user = Meteor.users.findOne(userId);
      if (!user) {
        throw new Meteor.Error(404, "El usuario no existe.");
      }
      if (sizeContent < 0) {
        throw new Meteor.Error(400, "El tamaño del contenido no puede ser negativo.");
      }
      if (user.storageLimit < user.storageUsed + sizeContent) {
        throw new Meteor.Error(
          400,
          "No hay espacio libre suficiente en tu librería."
        );
      }
    },
    isLogged(userId) {
      if (!userId) {
        throw new Meteor.Error(
          ErrorMessage.NOT_LOGGED.TYPE,
          ErrorMessage.NOT_LOGGED.REASON
        );
      }
    },
    isAdmin(userId) {
      if (!Commons.isAdmin(userId)) {
        throw new Meteor.Error(
          ErrorMessage.NOT_AUTHORIZED.TYPE,
          ErrorMessage.NOT_AUTHORIZED.REASON
        );
      }
    },
  }
};


### users.test.js
import { Meteor } from 'meteor/meteor'
import expect from 'expect';

import { validateNewUser } from './users'

describe('users',function(){
    if(Meteor.isServer){
        it('should allow valid email address',function(){
            const testUser = {
                emails: [
                        { 
                        address: "fernandomorenoruiz@gmail.com"
                        }
                ]
            }
            const res = validateNewUser(testUser)
            expect(res).toBe(true);
        })

        it('should reject invalid email',function(){
            const testUser = {
                emails: [
                        { 
                        address: "fernandomorenoruizgmail.com"
                        }
                ]
            }
            expect(()=>{
                validateNewUser(testUser)
            }).toThrow()
        })
    }
})

### words.js
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";

export const Words = new Mongo.Collection("words");

export const WORDS = {
  PUBLISH_NAMES: {
    BY_ROOM_ID: "words.byId"
  },
  METHOD_NAMES:{
    SEND:"words.send"
  }
}
if (Meteor.isServer) {
  Words.rawCollection().createIndex({ roomId: -1 });

  Meteor.publish(WORDS.PUBLISH_NAMES.BY_ROOM_ID, function (roomId) {
    return Words.find({ roomId: roomId });
  });
}

Meteor.methods({
  [WORDS.METHOD_NAMES.SEND](roomId, currentIndex, word) {
    if (!this.userId) {
      throw new Meteor.Error(
        ErrorMessage.NOT_LOGGED.TYPE,
        ErrorMessage.NOT_LOGGED.REASON
      );
    }
    let _word = {
      word: word.word,
      userId: this.userId,
      meaning: word.meaning,
      roomId,
      currentIndex: currentIndex,
      date: Date.now(),
    };
    return Words.insert(_word);
  },
});


### removeCollections.js
// this is a file with notes
// removed history collection

### roomsMigrations.js
import { Rooms } from "../rooms";

export function migrationArchivedFalse() {
  Rooms.update(
    {},
    { $set: { "participants.$[].archived": false } },
    { multi: true }
  );
}


### RoomFunctions.js
import { ROOMS } from "../../api/rooms";
import { isEmail } from "../../ui/commons/CommonsFunctions";
import { openSimpleDialog } from "../../ui/commons/SimpleDialog"

export const RoomFunctionsClient = {
    inviteUsernameToRoom(roomId,username,successCallback){        
        const user = {username: username.trim()}             
        if(username===""){          
          openSimpleDialog("Indica el nombre de usuario o email.")          
          return false;
        }
        Meteor.call(
          ROOMS.METHOD_NAMES.INVITE,
          roomId,
          user,
          (err,res) => {
            if(!err){
                successCallback()
            }else{
              openSimpleDialog(err.message)              
            }
          }
        );
    },
    inviteUserToRoom(roomId,usernameOrEmail,successCallback){
        let value = usernameOrEmail.trim()
        let user;
        if(isEmail(value)){
          user = {email:value.toLowerCase()}
        }else{
          user = {username: value.trim()}
        }        
        if(value===""){
          openSimpleDialog("Indica el nombre de usuario o email.")
          return false;
        }
        Meteor.call(
          ROOMS.METHOD_NAMES.INVITE,
          roomId,
          user,
          (err,res) => {
            if(!err){
                successCallback()
            }else{
              openSimpleDialog(err.message)
            }
          }
        );
    }
}

### UsersFuntions.js
import { Meteor } from 'meteor/meteor'

export const UsersFunctionsClient ={
    isMe(userId){
        return Meteor.userId()===userId    
    }
}

### _base.scss
@import "./variables";

:root {
  --size-text: 2.75rem;
  --backgrount-color: #13758d91;
}
* {
  margin: 0;
  padding: 0;
}
html {
  font-size: 62.5%;
}
body {
  font-size: $base-font-size;
  background-color: var(--backgrount-color);
}
a {
  color: black;
}

.header__title a {
  color: white;
  font-size: 2.4rem;
}
.header__title {
  color: white;
  font-size: 2.4rem;
}
h1 {
  font-weight: 300;
  font-size: 3.1rem;
  margin-bottom: $space;
}
h2 {
  margin-bottom: $space;
}
p {
  margin-bottom: $space;
}

input[type="text"],
input[type="username"],
input[type="password"],
input[type="email"],
textarea {
  font-size: $base-font-size;
  margin-bottom: $space;
  padding: $input-spacing;
  border: 1px solid $input-border;
}


### _main.scss
@import './base';
@import './variables';
/*Components*/
@import './components/page-content';
@import './components/header';
@import './components/magic-text';
@import './components/book-list';
@import './components/boxed-view';
@import './components/button';
@import './components/reading-my-book';

/* Pages */
@import './pages/my-books';


### _variables.scss
// Colors
$grey: #dddddd;
$brand-primary: #4352aa;
// Font sizes
$base-font-size: 1.4rem;

// Form input
$input-border: $grey;
$input-spacing: 0.6rem;

//Spacing
$space: 1.4rem;
$site-max-width: 60rem;

// boxed-view
$boxed-view-overlay-bg: $grey;
$boxed-view-bg: white;

$magic-text-bg: white;

//Button
$button-bg: $brand-primary;
$button-color: white;
$button-pill-color: $brand-primary;
$button-secondary-bg: #f9f9f9;
$button-secondary-color: #777777;
$button-secondary-border: $grey;

// header
$header-bg: $brand-primary;
$header-color: white;


### _book-list.scss
.book-item {
  width: 10rem;
  height: 18rem;
  display: flex;
  justify-content: space-between;
  flex-direction: column;
  margin: $space;
  margin-bottom: 0.8rem;
  padding: 1rem;
  background: white;
  box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2),
    0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12);
}

.book-item__title {
  font-size: 1.8rem;
  font-weight: bold;
  margin: 0;
  text-align: center;
}
.book-item__author {
  font-size: 1.6rem;
  text-align: center;
  margin-bottom: 0;
  text-decoration: none;
}
.book-list {
  display: flex;
  flex-flow: row wrap;
  justify-content: center;
}

.book-item__buttons {
  display: flex;
  margin: 0;
  padding: 0;
  flex-direction: column;
  text-align: center;
}


### _boxed-view.scss
.boxed-view {
  background: $boxed-view-overlay-bg;
  height: 100vh;
  width: 100vw;
  display: flex;
  align-items: center;
  justify-content: center;
}
.boxed-view--modal{
  background: fade-out($boxed-view-overlay-bg, .3);
  position: fixed;
  top:0;
  left: 0;
  right: 0;
  bottom: 0;
}
.boxed-view__box{
  background-color: $boxed-view-bg;
  padding: 2.4rem;
  text-align: center;
  width: 24rem;
}

.boxed-view__form{
  display: flex;
  flex-direction: column;
}


### _button.scss
.button {
  background-color: $button-bg;
  border: none;
  padding: $input-spacing;
  margin-bottom: $space;
  color: $button-color;
  text-transform: uppercase;
  font-size: $base-font-size;
  line-height: 1.2;
  cursor: pointer;
}
.button-controls {
  background-color: $button-bg;
  border: none;
  padding: $input-spacing;
  margin-bottom: 0.2rem;
  color: $button-color;
}
.button-controls-big {
  background-color: $button-bg;
  border: none;
  color: $button-color;
  width: 3em;
  height: 3em;
  margin-left: 0.1rem;
}

.button--link {
  display: inline-block;
  text-decoration: none;
}
.button--pill {
  background-color: transparent;
  border: 1px solid $button-pill-color;
  color: $button-pill-color;
  padding: 0.3rem 0.8rem;
}
.button--secondary {
  background: $button-secondary-bg;
  color: $button-secondary-color;
  border: 1px solid $button-secondary-border;
}
.button--link-text {
  background: none;
  margin: 0;
  padding: 0;
  text-decoration: underline;
  text-transform: none;
}


### _header.scss
.header {
  background: $header-bg;
  color: white;
}

.header__content {
  display: flex;
  justify-content: space-between;
  max-width: $site-max-width;
  margin: 0 auto;
  padding: $space;
  height: 3rem;
  color: white;
}

.header__title {
  color: white;
}


### _magic-text.scss
.w3-animate-opacity {
  animation: opac 1s;
}
@keyframes opac {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.magic-text {
  font-size: var(--size-text);
  // -webkit-user-select: none;
  // -khtml-user-select: none;
  // -moz-user-select: none;
  // -ms-user-select: none;
  // -o-user-select: none;
  // user-select: none;
}


### _page-content.scss
.page-content {
  max-width: $site-max-width;
  margin: 0 auto;
  text-align: center;
}


### _reading-my-book.scss
#end-block {
  height: 50vh;
}
#hide-text {
  position: fixed;
  top: -20px;
  height: 35vh;
  width: 100vw;
  background-image: linear-gradient(to top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1));
}
#hide-end-block {
  position: fixed;
  bottom: 0px;
  width: 100vw;
  height: 40vh;
  background-image: linear-gradient(
    to bottom,
    rgba(0, 0, 0, 0),
    rgba(0, 0, 0, 1)
  );
}
#visualizer__content {
  margin-top: 35vh;
  background-color: white;
}
.controls-bottom {
  position: fixed;
  bottom: 0px;
  height: 90px;
  width: 100vw;
  text-align: center;
  color: white;
  background-color: transparent;
}

.animated-color-arcoiris {
  $time-color: 480s;

  -webkit-animation: color_arcoiris_change $time-color infinite alternate;
  -moz-animation: color_arcoiris_change $time-color infinite alternate;
  -ms-animation: color_arcoiris_change $time-color infinite alternate;
  -o-animation: color_arcoiris_change $time-color infinite alternate;
  animation: color_arcoiris_change $time-color infinite alternate;

  @-webkit-keyframes color_arcoiris_change {
    0% {
      background-color: rgb(254, 93, 93);
    }
    16% {
      background-color: rgb(255, 203, 106);
    }
    33% {
      background-color: rgb(255, 255, 144);
    }
    50% {
      background-color: rgb(143, 238, 154);
    }
    66% {
      background-color: rgb(120, 136, 252);
    }
    83% {
      background-color: rgb(162, 105, 203);
    }
    100% {
      background-color: white;
    }
  }
  @-moz-keyframes color_arcoiris_change {
    0% {
      background-color: rgb(252, 125, 150);
    }
    16% {
      background-color: rgb(255, 203, 106);
    }
    33% {
      background-color: rgb(255, 255, 144);
    }
    50% {
      background-color: rgb(143, 238, 154);
    }
    66% {
      background-color: rgb(120, 136, 252);
    }
    83% {
      background-color: rgb(162, 105, 203);
    }
    100% {
      background-color: white;
    }
  }
  @-ms-keyframes color_arcoiris_change {
    0% {
      background-color: rgb(252, 125, 150);
    }
    16% {
      background-color: rgb(255, 203, 106);
    }
    33% {
      background-color: rgb(255, 255, 144);
    }
    50% {
      background-color: rgb(143, 238, 154);
    }
    66% {
      background-color: rgb(120, 136, 252);
    }
    83% {
      background-color: rgb(162, 105, 203);
    }
    100% {
      background-color: white;
    }
  }
  @-o-keyframes color_arcoiris_change {
    0% {
      background-color: rgb(252, 125, 150);
    }
    16% {
      background-color: rgb(255, 203, 106);
    }
    33% {
      background-color: rgb(255, 255, 144);
    }
    50% {
      background-color: rgb(143, 238, 154);
    }
    66% {
      background-color: rgb(120, 136, 252);
    }
    83% {
      background-color: rgb(162, 105, 203);
    }
    100% {
      background-color: white;
    }
  }
  @keyframes color_arcoiris_change {
    0% {
      background-color: rgb(252, 125, 150);
    }
    16% {
      background-color: rgb(255, 203, 106);
    }
    33% {
      background-color: rgb(255, 255, 144);
    }
    50% {
      background-color: rgb(143, 238, 154);
    }
    66% {
      background-color: rgb(120, 136, 252);
    }
    83% {
      background-color: rgb(162, 105, 203);
    }
    100% {
      background-color: white;
    }
  }
}
.animated-color-yellow {
  $time-color: 10s;
  $color1: rgb(255, 253, 137);
  $color2: rgb(248, 246, 99);
  -webkit-animation: color_yellow_change $time-color infinite alternate;
  -moz-animation: color_yellow_change $time-color infinite alternate;
  -ms-animation: color_yellow_change $time-color infinite alternate;
  -o-animation: color_yellow_change $time-color infinite alternate;
  animation: color_yellow_change $time-color infinite alternate;

  @-webkit-keyframes color_yellow_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-moz-keyframes color_yellow_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-ms-keyframes color_yellow_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-o-keyframes color_yellow_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @keyframes color_yellow_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
}
.animated-color-violet {
  $time-color: 10s;
  $color1: rgb(210, 137, 255);
  $color2: rgb(209, 168, 255);
  -webkit-animation: color_violet_change $time-color infinite alternate;
  -moz-animation: color_violet_change $time-color infinite alternate;
  -ms-animation: color_violet_change $time-color infinite alternate;
  -o-animation: color_violet_change $time-color infinite alternate;
  animation: color_violet_change $time-color infinite alternate;

  @-webkit-keyframes color_violet_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-moz-keyframes color_violet_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-ms-keyframes color_violet_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-o-keyframes color_violet_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @keyframes color_violet_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
}
.animated-color-purple {
  $time-color: 10s;
  $color1: rgb(96, 18, 145);
  $color2: rgb(40, 3, 82);
  -webkit-animation: color_purple_change $time-color infinite alternate;
  -moz-animation: color_purple_change $time-color infinite alternate;
  -ms-animation: color_purple_change $time-color infinite alternate;
  -o-animation: color_purple_change $time-color infinite alternate;
  animation: color_purple_change $time-color infinite alternate;
  color: white;
  @-webkit-keyframes color_purple_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-moz-keyframes color_purple_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-ms-keyframes color_purple_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-o-keyframes color_purple_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @keyframes color_purple_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
}
.animated-color-darkblue {
  $time-color: 10s;
  $color1: rgb(33, 9, 118);
  $color2: rgb(4, 3, 82);
  -webkit-animation: color_darkblue_change $time-color infinite alternate;
  -moz-animation: color_darkblue_change $time-color infinite alternate;
  -ms-animation: color_darkblue_change $time-color infinite alternate;
  -o-animation: color_darkblue_change $time-color infinite alternate;
  animation: color_darkblue_change $time-color infinite alternate;
  color: rgb(189, 234, 255);
  @-webkit-keyframes color_darkblue_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-moz-keyframes color_darkblue_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-ms-keyframes color_darkblue_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-o-keyframes color_darkblue_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @keyframes color_darkblue_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
}
.animated-color-green {
  $time-color: 10s;
  $color1: rgb(5, 116, 29);
  $color2: rgb(3, 82, 33);
  -webkit-animation: color_green_change $time-color infinite alternate;
  -moz-animation: color_green_change $time-color infinite alternate;
  -ms-animation: color_green_change $time-color infinite alternate;
  -o-animation: color_green_change $time-color infinite alternate;
  animation: color_green_change $time-color infinite alternate;
  color: rgb(189, 255, 216);
  @-webkit-keyframes color_green_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-moz-keyframes color_green_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-ms-keyframes color_green_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @-o-keyframes color_green_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
  @keyframes color_green_change {
    from {
      background-color: $color1;
    }
    to {
      background-color: $color2;
    }
  }
}
.read-color-black {
  color: white;
  background-color: black !important;
}
.read-color-pink {
  color: rgb(126, 21, 118);
  background-color: rgb(247, 182, 242) !important;
}
.read-color-dark-orange {
  color: rgb(243, 243, 243);
  background-color: #a24304 !important;
}
.read-color-orange {
  color: black;
  background-color: rgb(250, 188, 90) !important;
}
.animated-color-red {
  color: white;
  background-color: rgb(179, 11, 11) !important;
}

.read-color-dark {
  color: #abb2bf;
  background-color: #282c34 !important;
}

.read-color-space {
  color: #f8f8f2;
  background-color: transparent !important;
}

.read-color-space-terminal {
  color: #00ff00;
  background-color: transparent !important;
}

.animated-color-celeste-cielo {
  color: rgb(4, 3, 82);
  background-color: #2eccfa !important;
}

.controls-buttons-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
}

.fast-slow-container {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  margin-left: 0.1rem;
  padding: 0;
}


### _my-books.scss
.no-books-container {
  width: 100%;
}
.no-books-message {
  font-size: 2rem;
  background-color: white;
  padding: 5rem;
  margin: 5rem;
  margin-top: 2rem;
}


### routes.js
import React from "react";
import { Router, Route, Switch, Redirect } from "react-router-dom";
import { createBrowserHistory } from "history";
import { BooksPage } from "../ui/books/BooksPage";
import Rooms from "../ui/rooms/Rooms";
import { BookAdmin } from "../ui/admin/booksAdmin/BookAdmin";
import { MyBooks } from "../ui/myBooks/MyBooks";
import ReadingBook from "../ui/reading/ReadingBook";
import ReadingRoom from "../ui/reading/ReadingRoom";
import ReadingDocument from "../ui/reading/ReadingDocument";
import { Signup } from "../ui/signup/Signup";
import { Login } from "../ui/signup/Login";
import { NotFound } from "../ui/NotFound";
import DashboardAdmin from "../ui/admin/dashboard/DashboardAdmin";
import SexyGame from "../ui/sexyGame/SexyGame";
import Gracias from "../ui/donate/Gracias";
import DonacionCancelada from "../ui/donate/DonacionCancelada";
import { BookRooms } from "../ui/rooms/BookRooms";
import { MyBookRooms } from "../ui/rooms/MyBookRooms";
import FullReadingRoom from "../ui/reading/FullReadingRoom";
import ReadersGroupAdmin from "../ui/admin/readersGroup/ReadersGroupAdmin";
import ReadersGroup from "../ui/readersGroup/ReadersGroup";
import ForgotPassword from "../ui/signup/ForgotPassword";
import { ResetPassword } from "../ui/signup/ResetPassword";
import { ChatGPTWithJesus } from "../ui/chatGPTWithJesus/ChatGPTWithJesus";
import { NaturalChatUI } from "../ui/naturalchat/NaturalChatUI";
export const browserHistory = createBrowserHistory();
const unAuthenticadedPages = ["/", "/signup", "/login"];
const authenticadedPages = ["/my_books", "/rooms"];

export const isAuthChange = (isAuthenticated) => {
  const pathname = browserHistory.location.pathname;
  const isUnAuthenticatedPage = unAuthenticadedPages.includes(pathname);
  const isAuthenticatedPage = authenticadedPages.includes(pathname);
  if (isAuthenticatedPage && !isAuthenticated) {
    browserHistory.replace("/");
  } else if (isUnAuthenticatedPage && isAuthenticated) {
    browserHistory.replace("/books");
  }
};

export const Routes = () => {
  // const { createAnalytics } = useAnalytics();

  function ifNotAuthRedirectTo(component, pathRedirection, location) {
    const isAuthenticated = !!Meteor.userId();
    if (isAuthenticated) {
      return component;
    } else {
      return (
        <Redirect
          to={{
            pathname: pathRedirection,
            state: { from: location },
          }}
        />
      );
    }
  }

  function ifAuthRedirectTo(component, pathRedirection, location) {
    const isAuthenticated = !!Meteor.userId();
    if (!isAuthenticated) {
      return component;
    } else {
      return (
        <Redirect
          to={{
            pathname: pathRedirection,
            state: { from: location },
          }}
        />
      );
    }
  }

  return (
    <Router history={browserHistory}>
      <Switch>
        <Route
          exact
          path="/"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BooksPage />, "/login", location)
          }
        />
        <Route exact path="/forgot-password" children={<ForgotPassword />} />
        <Route
          exact
          path="/reset-password/:token"
          children={<ResetPassword />}
        />
        <Route
          exact
          path="/login"
          render={({ location }) =>
            ifAuthRedirectTo(<Login />, "/books", location)
          }
        />
        <Route
          exact
          path="/signup"
          render={({ location }) =>
            ifAuthRedirectTo(<Signup />, "/my_books", location)
          }
        />
        <Route
          exact
          path="/books"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BooksPage />, "/login", location)
          }
        />
        <Route
          exact
          path="/books/author/:author"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BooksPage />, "/login", location)
          }
        />
        <Route
          exact
          path="/book/:title"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BooksPage />, "/login", location)
          }
        />
        <Route
          exact
          path="/book/reading/:id/:startIndex?/:stopIndex?"
          children={<ReadingBook />}
        />
        <Route
          exact
          path="/my_books"
          render={({ location }) =>
            ifNotAuthRedirectTo(<MyBooks />, "/", location)
          }
        />
        <Route
          exact
          path="/my_books/:folder"
          render={({ location }) =>
            ifNotAuthRedirectTo(<MyBooks />, "/login", location)
          }
        />
        <Route
          exact
          path="/rooms"
          render={({ location }) =>
            ifNotAuthRedirectTo(<Rooms />, "/login", location)
          }
        />
        <Route
          exact
          path="/rooms/myBook/:myBookId"
          render={({ location }) =>
            ifNotAuthRedirectTo(<MyBookRooms />, "/login", location)
          }
        />
        <Route
          exact
          path="/rooms/:book_id"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BookRooms />, "/login", location)
          }
        />
        <Route
          exact
          path="/room/fullreading/:id"
          children={<FullReadingRoom />}
        />
        <Route
          exact
          path="/room/reading/:id/:showControls?"
          children={<ReadingRoom />}
        />
        {/* <Route exact path="/readersGroup/:id/:action?" children={<ReadersGroup />} />    */}
        <Route exact path="/document/reading" children={<ReadingDocument />} />
        <Route
          exact
          path="/dashboard"
          render={({ location }) =>
            ifNotAuthRedirectTo(<DashboardAdmin />, "/login", location)
          }
        />
        <Route
          exact
          path="/readersGroupAdmin"
          children={<ReadersGroupAdmin />}
        />
        <Route
          exact
          path="/booksAdmin"
          render={({ location }) =>
            ifNotAuthRedirectTo(<BookAdmin />, "/login", location)
          }
        />
        <Route exact path="/gracias" children={<Gracias />} />
        <Route
          exact
          path="/donacioncancelada"
          children={<DonacionCancelada />}
        />
        <Route exact path="/chatGPTWithJesus" children={<ChatGPTWithJesus />} />
        <Route exact path="/naturalchat/:roomId" children={<NaturalChatUI />} />
        <Route component={NotFound} />
      </Switch>
      {/* <CookieBanner
        showMarketingOption={false}
        showPreferencesOption={false}
        // styles={{
        //     dialog: {
        //         position: "fixed",
        //         bottom: 5,
        //         backgroundColor: "white",
        //     },
        // }}
        necessaryOptionText="Necesarias"
        statisticsOptionText="Estadísticas"
        privacyPolicyLinkText="Política de Cookies"
        acceptButtonText="Aceptar"
        policyLink="/privacyCookies.html"
        message="Utilizamos cookies propias y de terceros para mejorar su experiencia y nuestros servicios analizando su navegación en nuestra web y cómo interactúa con nosotros. Para consentir su utilización, pulse el botón “Aceptar. Puede obtener más información consultando nuestra Política de Cookies."
        onAcceptStatistics={() => {
          console.log("accepts statistics");
          createAnalytics().page();
        }}
        onDeclineStatistics={() => {
          console.log("decline statistics");
        }}
      /> */}
    </Router>
  );
};


### Footer.js
import React from 'react'

export default function Footer(){
    return <>
            <div style={{textAlign:"center", marginTop:"3rem", marginBottom:"3rem"}}>
                <div>
                    Web Creada y Desarrollada por <a href="https://www.fernandomorenoruiz.com">Fernando Moreno Ruiz</a>
                </div>
                <div>
                    Icons made by <a href="https://www.freepik.com/" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
                </div>
            </div>
        </>
}

### Home.js
import React from "react";
import {
  Container,  
  Button,  
} from "@material-ui/core";

import { PrivateHeader } from "./PrivateHeader";
import { Link } from "react-router-dom";
import SignUpForm from "./signup/SignUpForm";

export default () => {

  return (
    <>
      <PrivateHeader title="La Librería Mágica" showUsersOnline={false}/>
      <Container style={{marginTop: "2vh"}}>
        <div
          style={{
            flex: 1,
            textAlign: "center",            
            justifyContent: "center",            
            maxWidth:"500px",
            margin:"auto"
          }}
        >                          
          <div style={{color:"white",fontSize:"2rem"}}>
            <p>¡Os presentamos la novedosa forma de lectura!</p>                        
            <p>¡Lee el texto a la vez que tus amigos Online!</p>                        
            <p style={{color:"#500C5F"}}>Alicia en el País de las Maravillas, EL Principito, Drácula, El Diario de Ana Frank...</p>
            <p>Son algunos de nuestros libros.</p>
            <p>Crea tu cuenta completamente GRATIS y crea tu sala de lectura con tus amigos.</p>
          </div>
          <Container className="boxed-view__box" style={{maxWidth:"50vw",marginBottom:"2rem"}}>
            <SignUpForm />            
          </Container>                    
          <Container style={{topMargin:"1vh"}}>
          <div style={{color:"white",fontSize:"2rem"}}>
            <p>También puedes entrar como invitado para probar "La lectura centrada" y ver nuestros libros.</p>
            <p>Pero no tendrás la opción de leer con tus amigos de forma simultánea.</p>
          </div>
            <Button style={{fontSize:"1.2rem",marginBottom:"3rem"}} variant="contained" color="inherit" href="/books">
              Entrar como invitado
            </Button>
          </Container>
        </div>
      </Container>
    </>
  );
};


### NotFound.js
import React from 'react';
import { Link } from 'react-router-dom';

export const NotFound = () => {
  return (
    <div className="boxed-view">
      <div className="boxed-view__box">
        <h1>Page Not Found</h1>
        <Link to='/' className="button button--link">Ir al Inicio</Link>
      </div>
    </div>
  )
}


### PrivateHeader.js
import React, { useEffect, useState } from "react";
import PropTypes from "prop-types";
import { Tracker } from "meteor/tracker";
import { browserHistory } from "../routes/routes";
import InvitationsList from "./rooms/InvitationsList";
import AmigosConnected from "./users/AmigosConnected";
import { Button } from "@material-ui/core";

export const PrivateHeader = (props) => {
  const { showUsersOnline, title } = props;
  const [isAuth, setIsAuth] = useState(!!Meteor.user());
  const [isAdmin, setIsAdmin] = useState(false);

  useEffect(() => {
    let trackerUser = Tracker.autorun(() => {
      setIsAuth(!!Meteor.user());
      if (Meteor.user()) {
        setIsAdmin(Meteor.user().admin);
      }
    });
    return () => {
      trackerUser.stop();
    };
  }, []);

  function adminOptions() {
    if (isAdmin) {
      return (
        <Button
          onClick={() => {
            browserHistory.push("/booksAdmin");
          }}
        >
          Opciones de Administrador
        </Button>
      );
    }
    return <></>;
  }

  function showAmigosConnected(show) {
    if (show === false) {
      return <></>;
    }
    return <AmigosConnected />;
  }

  if (!!Meteor.user()) {
    return (
      <>
        <div className="header">
          <div className="header__content">
            <h1 className="header__title">
              <a style={{ color: "white" }} href="/">
                {title}
              </a>
            </h1>
            <LoginButton isAuth={isAuth} />
          </div>
        </div>
        <div style={{ textAlign: "center" }}>
          {showAmigosConnected(showUsersOnline)}
          <InvitationsList />
          {/* <p>
            <a href="/chatGPTwithJesus">ChatGPT with Jesus</a>
          </p> */}
          {adminOptions()}
        </div>
      </>
    );
  } else {
    return (
      <>
        <div className="header">
          <div className="header__content">
            <h1 className="header__title">
              <a href="/">{props.title}</a>
            </h1>
            <LoginButton isAuth={isAuth} />
          </div>
        </div>
        {showAmigosConnected(showUsersOnline)}
      </>
    );
  }
};

function LoginButton(props) {
  const { isAuth } = props;

  if (isAuth) {
    return (
      <button
        className="button button--link-text"
        onClick={() => {
          Accounts.logout((err) => {
            !err && browserHistory.push("/");
          });
        }}
      >
        Cerrar Sesión
      </button>
    );
  }
  return (
    <button
      id="login_button"
      className="button button--link-text"
      onClick={() => {
        browserHistory.push("/login");
      }}
    >
      Iniciar Sesión
    </button>
  );
}
PrivateHeader.propTypes = {
  title: PropTypes.string.isRequired,
};


### BookSelector.js
import React, { useRef, useState } from 'react'
import { Meteor } from 'meteor/meteor'
import { useTracker } from 'meteor/react-meteor-data'
import { Books, BOOKS } from '../../api/books'
import { Button, Dialog, DialogContent, DialogTitle, Input } from '@material-ui/core'
import { calculateNumberOfPages } from '../reading/controls/Controls'

export default ({onBookSelected})=>{
    const [visible, setVisible] = useState(false)    
    const [search, setSearch] = useState("")
    const { books } = useTracker(()=>{
        Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOKS)                
        return {books: Books.find({}).fetch()}    

    },[])
    console.log(search)
    return <>
        <Button variant="contained" onClick={()=>{setVisible(true)}}>Elegir Libro</Button>
        <Dialog open={visible} onClose={()=>{setVisible(false)}}>
            <DialogTitle>Selecciona un libro:</DialogTitle>
            <DialogContent>
                <Input placeholder="Titulo" onChange={(e)=>{setSearch(e.target.value)}}/>
                {books.filter((b)=>{return b.title.toUpperCase().includes(search.toUpperCase())}).map((book)=>{
                    return <div key={book._id}>{book.title} || {calculateNumberOfPages(book.length)} Páginas  
                        <Button variant="contained" onClick={()=>{onBookSelected(book);setVisible(false);setSearch("")}}>Seleccionar</Button>
                    </div>
                })}
            </DialogContent>
        </Dialog>
    </>
}

### BookAdmin.js
import React from "react";
import { Accounts } from 'meteor/accounts-base'
import { Button } from "@material-ui/core";
import { Link } from "react-router-dom";
import BooksListAdmin from "./BooksListAdmin";
import { PrivateHeader } from "../../PrivateHeader";
import { browserHistory } from "../../../routes/routes";
import { EMAIL } from "../../../api/email";
import { openSimpleDialog } from "../../commons/SimpleDialog";

export const BookAdmin = () => {
  return (
    <div>
      <PrivateHeader title="Books Admin" />
      <div className="page-content">
        <p>
          <Link className="button button--link" to="/my_books">
            Mis Libros
          </Link>
          <div>
            <Button variant="contained" onClick={()=>{
              Meteor.call(EMAIL.METHOD_NAMES.SEND_TEST,(err)=>{
                if(err){
                  openSimpleDialog("Error en el test del email:" + err.message,"Error");
                }else{
                  openSimpleDialog("Test sin errores","Test Email");
                }
              })
            }}>Test Email</Button>
          </div>
        </p>
        <Button variant="contained"
          onClick={() => {
            Meteor.call("dropboxSync");
          }}
        >
          Sync Dropbox
        </Button>
        <div style={{margin:"1rem"}}>
          <Button onClick={()=>{browserHistory.push("/dashboard")}} variant="contained">
            Ir al Dashboard
          </Button>
        </div>
        <Button variant="contained" style={{marginBottom:"1rem"}} onClick={()=>{
          browserHistory.push("/readersGroupAdmin")
        }}>Admin Grupos de Lectura</Button>
        <BooksListAdmin />
      </div>
    </div>
  );
};


### BookAdminItem.js
import { Button } from "@material-ui/core";
import React from "react";
import { BOOKS } from "../../../api/books";
import { openSimpleDialog } from "../../commons/SimpleDialog";

export default (props) => {
  const { book, onClickRemove } = props;

  const handleOnlyAdmin = () => {
    // get value only admin from book
    let onlyAdmin = book.onlyAdmin;
    if (onlyAdmin) {
      onlyAdmin = !onlyAdmin;
    } else {
      onlyAdmin = true;
    }

    Meteor.call(
      BOOKS.METHOD_NAMES.SET_ONLY_ADMIN,
      book._id,
      onlyAdmin,
      (err, res) => {
        if (err) {
          openSimpleDialog(err.reason);
        } else {
          openSimpleDialog("Se ha cambiado el estado de solo admin del libro");
        }
      }
    );
  };

  return (
    <div
      style={{
        marginBottom: "0.5rem",
        backgroundColor: "#D5DBDB",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        marginLeft: "0.5rem",
      }}
    >
      <div>
        <div>
          <Title book={book} />
        </div>
        <div>
          <Author book={book} />
        </div>
        <div>
          <Price book={book} />
        </div>
      </div>

      <div
        style={{
          width: "10rem",
          flexDirection: "column",
          display: "flex",
          bottom: "0px",
          backgroundColor: "white",
          justifyContent: "spaceAround",
        }}
      >
        <Button
          onClick={() => {
            onClickRemove(book);
          }}
        >
          Eliminar
        </Button>
        <Button>Editar</Button>
        <Button onClick={handleOnlyAdmin}>Solo admin</Button>
        {book.onlyAdmin == true && <p>Solo admin true</p>}
      </div>
    </div>
  );
};

function Title(props) {
  const { book } = props;
  return (
    <>
      <a
        style={{ textDecoration: "none" }}
        className="book-item__title"
        href={"/book/" + book.title}
      >
        {book.title}
      </a>
    </>
  );
}

function Author(props) {
  const { book } = props;
  return (
    <>
      <a className="book-item__author" href={"/books/author/" + book.author}>
        {book.author}
      </a>
    </>
  );
}
function Price(props) {
  // if (props.book.price) {
  //   return <><p>{/*<span style={{textDecoration:"line-through"}}>{props.book.price}</span>*/} {"(Gratis)"}</p> </>;
  // }
  return <></>;
}

function ButtonItem(props) {
  let myBook = props.myBook;
  if (myBook.bookId) {
    return (
      <button
        className="button button--pill"
        style={{ backgroundColor: "white", marginBottom: "0.2rem" }}
        onClick={(e) => {
          props.onClickReturn(myBook, e);
        }}
      >
        Devolver
      </button>
    );
  } else {
    return (
      <button
        className="button button--pill"
        style={{ backgroundColor: "#F5B7B1", marginBottom: "0.2rem" }}
        onClick={(e) => {
          props.onClickRemove(myBook, e);
        }}
      >
        Eliminar
      </button>
    );
  }
}


### BooksListAdmin.js
import React from 'react';
import { Tracker } from 'meteor/tracker';
import { Books } from '../../../api/books';
import { Meteor } from 'meteor/meteor';
import BookEdit from '../../books/BookEdit';
import { openSimpleDialog } from '../../commons/SimpleDialog';
import { openSimpleConfirm } from '../../commons/SimpleConfirm';
import BookAdminItem from './BookAdminItem';

export default class BooksListAdmin extends React.Component{
  constructor(props){
    super(props);
    this.state = {
      books:[]
    }
  }
  componentDidMount(){
    Meteor.subscribe('books');
    this.booksTracker = Tracker.autorun(()=>{
      const books = Books.find({}).fetch();
      this.setState({books})
      // console.log(books)
    });
    // console.log("componentDidMount hello!.")
  }
  componentWillUnmount(){
    this.booksTracker.stop();
  }

  onClickRemove(book,e){
    if(confirm("Desea borrar el libro de verdad???")){
      Meteor.call('books.remove',book._id,(err,res)=>{
        if(err){
          openSimpleDialog(err.reason)
        }
      });
    }
    // console.log("onClickRemove:" + book._id)
    // openSimpleConfirm("Desea eliminar el libro " + book.title),
    // "Eliminar Libro",
    // ()=>{
    //   Meteor.call('books.remove',book._id,(err,res)=>{
    //     if(err){
    //       openSimpleDialog(err.reason)
    //     }
    //   });
    // }
  }
  onEdit(book,e){
    
    
  }

  renderBooksListItems(){
    return this.state.books.map((book)=>{
      return <>
          <div className="book-item" key={book._id}>
            <BookAdminItem book={book} onEdit={this.onEdit.bind(this)} onClickRemove={this.onClickRemove.bind(this)}/>
            <BookEdit book={book} />
          </div>
          </>
    });
  }
  render(){
    return (
      <div>
        <h2>Lista de Libros</h2>
        <div className="book-list">
          {this.renderBooksListItems()}
        </div>
      </div>
    );
  }
}


### DashboardAdmin.js
import React, { useEffect, useState } from "react";
import { MY_BOOKS } from "../../../api/myBooks";
import { PrivateHeader } from "../../PrivateHeader";
import UserInfo from "./UserInfo";

export default () => {
    const [users, setUsers] = useState(null);
    useEffect(() => {
        const subsAllUsers = Meteor.subscribe("allUsers");
        const subsMyBooks = Meteor.subscribe(MY_BOOKS.PUBLISH_NAMES.ALL_ADMIN);
        const subsRooms = Meteor.subscribe("allRooms");

        const trackerUsers = Tracker.autorun(() => {
            if (
                subsMyBooks.ready() &&
                subsAllUsers.ready() &&
                subsRooms.ready()
            ) {
                setUsers(Meteor.users.find({},{sort:{"status.lastLogin.date":-1}}).fetch());
            }
        });
        return () => {
            trackerUsers.stop();
        };
    }, []);
    if (users === null) {
        return <div>Cargando...</div>;
    }
    return (
        <>
            <PrivateHeader title="Dashboard Admin" />
            <div>
                <div style={{textAlign:"center"}}>Hay: {users.length} usuarios registrados</div>
                {users.map((user) => {
                    return (
                        <UserInfo
                            key={user._id}
                            userObject={user}
                            id={user._id}
                            username={user.username}
                            email={user.emails[0].address}

                        />
                    );
                })}
            </div>
        </>
    );
};


### MyBookList.js
import { LinearProgress } from '@material-ui/core';
import React, { useState } from 'react'
import { Link } from 'react-router-dom';

export default function MyBooksList({myBooks}){
    const [showMyBooks, setShowMyBooks] = useState(false)
    function showListMyBooks(myBooks){
      if(showMyBooks){
        return myBooks.map((book) => {
            
          const percentage = (book.currentIndex * 100) / book.length;
          return (
            <div style={{marginBottom:"0.5rem"}} key={book._id}>
              <a href={`/book/reading/${book.bookId}/${book.currentIndex}`}>{book.title}{" "} </a>
              <LinearProgress style={{marginBottom:"0.5rem"}} variant="determinate" value={percentage} />
            </div>
          );
        })
      }else{
        return <></>
      }
    }
  
    return <>
        <div style={{textAlign:"center"}}><Link onClick={()=>{setShowMyBooks((show)=>(!show))}}>MyBooks ({myBooks.length})</Link>
          {showListMyBooks(myBooks)}
        </div>
    </>
  }
  

### RoomList.js
import { LinearProgress } from '@material-ui/core'
import React, { useEffect, useState } from 'react'
import { Link } from 'react-router-dom'

export default function RoomList(props){
    const {rooms} = props
    const [showRooms, setShowRooms] = useState(rooms.length===1)    
    useEffect(() => {
        if(rooms.length===1){
            setShowRooms(true)
        }        
    }, [rooms])
    function showListRooms(rooms){
      if(showRooms){
        return <>
        {
          rooms.map((book) => {
            let percentage = (book.currentIndex * 100) / book.length;
            return (
              <div style={{marginBottom:"0.5rem"}} key={book._id}>
                <a href={`/book/reading/${book.bookId}/${book.currentIndex}`}>{book.title}{" "} </a>
                <LinearProgress style={{marginBottom:"0.5rem"}} variant="determinate" value={percentage} />
              </div>
            );
          })
        }
        </>
      }else{
        return <></>
      }
    }
  
    return <>
        <div style={{ marginTop: "1rem", textAlign:"center" }}><Link onClick={()=>{setShowRooms((show)=>(!show))}}>Rooms ({rooms.length})</Link>
          {showListRooms(rooms)}
        </div>
    </>
  
  }

### UserInfo.js
import React, { useState, useEffect } from "react";
import { MyBooks } from "../../../api/myBooks";
import { Rooms } from "../../../api/rooms";
import { formatDistance, format } from 'date-fns'
import locale from 'date-fns/locale/es'
import RoomList from "./RoomList";
import MyBooksList from "./MyBookList";

export default function UserInfo(props) {
  const [myBooks, setMyBooks] = useState([]);
  const [rooms, setRooms] = useState([]);   
  const user = props.userObject

  useEffect(() => {
    setMyBooks(MyBooks.find({ userId: props.id }).fetch());
    setRooms(Rooms.find({ ownerId: props.id }).fetch());
  }, []);

  return (
    <div style={{marginTop:"0.5rem", marginBottom:"0.5rem", backgroundColor:"#F5C166", width:"80%", margin:"auto"}}>
      <hr/>      
      <UserNameInfo user={user}/>
      <UserTimeDateInfo user={user}/>      
      <MyBooksList myBooks={myBooks}/>
      <RoomList rooms={rooms} />
      <button
          onClick={() => {
            if (confirm("seguro?")) {
              Meteor.call("users.remove", user._id);
            }
          }}
        >
          Eliminar
        </button>
    </div>
  );  
}

function UserNameInfo({user}){
  const username= user.username
  const email = user.emails[0].address
  return <>
    <div style={{ marginTop: "0.5rem",marginBottom:"0.5rem", textAlign:"center"}}><span style={{fontWeight: "bold"}}>{username}</span> || {email}</div>        
  </>
}

function UserTimeDateInfo({user}){
  function showDateCreation(user){
    return <span>{format(user.createdAt,"dd/MM/yyyy")}</span>
  }
  function sinceTimeConnected(user){
    if(user.status && user.status.lastLogin){
      let date = user.status.lastLogin.date
      return <span>conectado {formatDistance(date,new Date(),{addSuffix:true,locale:locale})}</span>
    }
  }
  return <div style={{textAlign:"center"}}> Fecha de registro: {showDateCreation(user)} | {sinceTimeConnected(user)}</div>      
}





### DateTimePicker.js
import { DatePicker, TimePicker } from '@material-ui/pickers'
import React from 'react'

export default function DateTimePicker(props){
    const { date, setDate } = props
    return (<>
            <DatePicker style={{maxWidth:"110px"}} value={date} onChange={setDate} />
            <TimePicker style={{maxWidth:"80px"}} value={date} onChange={setDate} />
            </>)
}

### ListReadersGroups.js
import React from 'react'
import { Meteor } from 'meteor/meteor'
import { useTracker } from 'meteor/react-meteor-data'
import { ReadersGroups, READERS_GROUPS } from '../../../api/readersGroups'
import { Books, BOOKS } from '../../../api/books'
import ReadersGroupsItem from './ReadersGroupItem'

export default function ListReadersGroups(){
    const {groups, books} = useTracker(()=>{
        Meteor.subscribe(READERS_GROUPS.PUBLISH_NAMES.ALL)
        Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOKS)
        const groups = ReadersGroups.find({}).fetch()
        const books = Books.find().fetch();
        return { groups, books }
    })
    
    return <>
        <h1>Grupos de Lectura</h1>
        {groups.map((group)=>{
            return <ReadersGroupsItem key={group._id} group={group} books={books}/>
        })}
    </>
}


### MeetingTimes.js
import React from 'react'
import { Meteor } from 'meteor/meteor'
import { READERS_GROUPS } from '../../../api/readersGroups'
import { openSimpleDialog } from '../../commons/SimpleDialog'
import { openSimpleConfirm } from '../../commons/SimpleConfirm'
import { Button, Card } from '@material-ui/core'
import DateTimePicker from './DateTimePicker'

export default function MeetingTimes(props){
    const { meetingTimes, readersGroupId } = props       
    function removeMeetingGroup(readersGroupId, meetingTimeId){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.REMOVE_MEETING_TIME,readersGroupId,meetingTimeId,(err,res)=>{
            err && openSimpleDialog(err.message)
            res && openSimpleDialog(res)
        })
    }
    return <>
        <div>    
            <Card style={{maxWidth:"350px", margin:"auto"}}>
                <h2>Últimos 4 Encuentros creados</h2>
                {meetingTimes.reverse().slice(0,4).map((meeting)=>(
                <div key={meeting._id}>                    
                    <DateTimePicker date={meeting.date} setDate={(date)=>{meeting.date = date}} />
                    <Button variant="contained" color="secondary" onClick={()=>{
                        openSimpleConfirm(`Estas seguro de eliminar el encuentro: ${meeting.date.toString()}`,"Eliminar Encuentro",()=>{
                            removeMeetingGroup(readersGroupId,meeting._id)
                        })
                    }}>Eliminar Encuentro</Button>
                </div>))
                }
            </Card>        
        </div>
    </>  
}

### MembersReadersGroup.js
import { Button, Dialog, DialogContent, DialogTitle } from '@material-ui/core'
import React, { useState } from 'react'

export default ({members})=>{
    const [showDialog, setShowDialog] = useState(false)
    return <>
        <Button onClick={()=>{setShowDialog(true)}}>Ver Miembros ({members.length})</Button>
        <Dialog open={showDialog} onClose={()=>{setShowDialog(false)}}>
            <DialogTitle>Miembros del grupo</DialogTitle>
            <DialogContent>
                {members.map((member)=>{
                    return <div key={member._id}>
                            <p>{member.username}</p>
                            <p>{member.email}</p>
                            <p style={{color:"red"}}>{member.unsubscribeEmail?"baja en emails":""}</p>
                            <p style={{color:"red"}}>{member.unsubscribeEmailDate?member.unsubscribeEmailDate.toString():""}</p>
                            <hr/>
                        </div>
                })}
            </DialogContent>
        </Dialog>
    </>
}

### ReadersGroupAdmin.js
import { Button, Card, Input } from '@material-ui/core'
import React, { useRef } from 'react'
import { Meteor } from 'meteor/meteor'
import { READERS_GROUPS } from '../../../api/readersGroups'
import { openSimpleDialog } from '../../commons/SimpleDialog'
import Column from '../../commons/Column'
import ListReadersGroups from './ListReadersGroups'


export default function ReadersGroupAdmin(){
    const name = useRef("")

    function crearGrupo(name){

        Meteor.call(READERS_GROUPS.METHODS_NAMES.CREATE,name,(err,res)=>{
            res && openSimpleDialog(res,"Grupo Creado")
            err && openSimpleDialog(err.message, "Error")
        })
    }

    return (<div style={{textAlign:"center"}}>   
        <div style={{marginTop:"3rem"}}><h1>Administración de Grupos de Lectura</h1> </div> 
        <Card style={{maxWidth:"300px", margin:"auto"}}>
            <h2>Crear Nuevo Grupo de Lectura</h2>    
            <Column style={{padding:"1rem", justifyContent:"center"}}>
                <Input placeholder="Nombre del Grupo" inputRef={name}></Input>
                <Button variant="contained" style={{margin:"auto"}} onClick={()=>{
                    console.log(name.current.value.trim())
                    {crearGrupo(name.current.value.trim())}
                }}>Crear Nuevo Grupo</Button>
            </Column>
        </Card>
        <ListReadersGroups />
    </div>)
}








### ReadersGroupItem.js
import React, { useRef, useState } from 'react'
import { Button, Card, Input } from '@material-ui/core'
import { Random } from 'meteor/random'
import { Link } from 'react-router-dom'
import { Books } from '../../../api/books'
import { READERS_GROUPS } from '../../../api/readersGroups'
import { openSimpleConfirm } from '../../commons/SimpleConfirm'
import BookSelector from '../BookSelector'
import DateTimePicker from './DateTimePicker'
import MeetingTimes from './MeetingTimes'
import { openSimpleDialog } from '../../commons/SimpleDialog'
import MembersReadersGroup from './MembersReadersGroup'
import SendEmail from './SendEmail'

export default function ReadersGroupsItem(props){
    const [showGroupItem, setShowGroupItem] = useState(false)
    const { group } = props    
    const { _id, name, book, members, startDate, endDate, meetingTimes } = group
    const [_startDate, set_StartDate] = useState(startDate?startDate:new Date())
    const [_endDate, set_EndDate] = useState(endDate?endDate:new Date())
    const [_meetingDate, set_MeetingDate] = useState(new Date())
    const [bookId, setBookId] = useState(book?book._id:"")
    const refs = { bookId:useRef(book?book._id:"") }    

    function showBookTitle(){
        if(book && book._id===bookId){
            return <p>{book?book.title:""}</p>
        }
        return <></>
    }

    function updateReadersGroup(){        
        group.startDate = _startDate
        group.endDate = _endDate
        group.book = Books.findOne({_id:refs.bookId.current.value.trim()})
        updateGroup(group)        
                
    }
    function archiveReading(readersGroup, onFinish){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.ARCHIVE_READING,readersGroup,(err,res)=>{
            res && openSimpleDialog(res,"Lectura archivada")
            err && openSimpleDialog(err.message, "Error")
            if(res){
                onFinish()
            }
        })
    }    

    function resetReading(_id){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.RESET_READING,_id,(err,res)=>{
            res && openSimpleDialog("Grupo de Lectura actualizado","Lectura Reseteada")
            err && openSimpleDialog(err.message, "Error")
            if(res){
                refs.bookId.current.value =""
            }
        })
    }

    function updateGroup(readersGroup){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.UPDATE,readersGroup,(err,res)=>{
            res && openSimpleDialog("Grupo de Lectura actualizado","Grupo actualizado")
            err && openSimpleDialog(err.message, "Error")
        })
    }

    function addMeetingGroup(readersGroupId){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.ADD_MEETING_TIME,readersGroupId,_meetingDate,1,(err,res)=>{
            err && openSimpleDialog(err.message)
            res && openSimpleDialog("Encuentro creado correctamente")
        })
    }

    if(!showGroupItem){
        return <>
        <div style={{backgroundColor:"#F7DC6F", maxWidth:"400px", margin:"auto", marginTop:"1rem", padding:"1rem"}}>
            <h1><Link to={'/readersGroup/' + _id}>{name} </Link>
                <Button style={{marginLeft:"1rem"}} variant="contained" onClick={()=>{setShowGroupItem(true)}}>Configurar</Button>
            </h1>   
        </div>
        </>
    }
    return <>
        <div style={{backgroundColor:"#F7DC6F", maxWidth:"400px", margin:"auto", marginTop:"1rem", padding:"1rem"}}>
            <h1><Link to={'/readersGroup/' + _id}>{name} </Link> 
                <Button style={{marginLeft:"1rem"}} variant="contained" onClick={()=>{setShowGroupItem(false)}}>Cerrar</Button>
            </h1>   
            <Card style={{maxWidth:"350px", margin:"auto"}}>
                <h2>Lectura Actual</h2>
                <h2>Libro</h2>
                {showBookTitle()}
                <div>BookId <Input inputRef={refs.bookId} placeholder="book id" defaultValue={book?book._id:""}/></div>                            
                <BookSelector onBookSelected={(book)=>{
                    refs.bookId.current.value = book._id
                    setBookId(book._id)
                }}/>
                <h2>Fechas de Lectura</h2>
                <div>Lectura empieza <DateTimePicker date={_startDate} setDate={set_StartDate} /></div>
                <div>Lectura termina <DateTimePicker date={_endDate} setDate={set_EndDate} /></div>
                
            </Card>
            <Button color="primary" variant="contained" onClick={()=>{
                openSimpleConfirm("¿Desea actualizar el libro y la fecha de lectura?","Actualizar lectura",()=>{
                    updateReadersGroup()
                })
            }}>Actualizar Lectura</Button>
            <Button color="secondary" variant="contained" onClick={()=>{
                openSimpleConfirm("¿Seguro que deseas archivar la lectura actual y crear una lectura nueva?. La lectura actual desaparecerá y tendrás que añadir un libro y una fecha nueva y pulsar Actualizar Lectura.","Archivar lectura",
                ()=>{
                    archiveReading(group, ()=>{
                        resetReading(group._id)                           
                    })
                }) 
            }}>Archivar lectura actual y Crear Nueva Lectura</Button>            
            <Card style={{margin:"auto", maxWidth:"350px", marginTop:"0.5rem", marginBottom:"0.5rem", padding:"1rem"}}>
                <h2>Miembros del grupo</h2>
                <MembersReadersGroup members={members}/>
                <SendEmail readersGroup={group} />
            </Card>
            <Card style={{margin:"auto", maxWidth:"350px", marginTop:"0.5rem", marginBottom:"0.5rem", padding:"1rem"}}>
                <h2>Crear encuentro de lectura</h2>
                <div>Fecha del Encuentro: 
                    <DateTimePicker date={_meetingDate} setDate={set_MeetingDate} />
                </div>
                <Button variant="contained" color="primary" style={{marginTop:"0.5rem"}} onClick={()=>{
                    console.log("hnola")
                    addMeetingGroup(group._id,_meetingDate,1)
                }}>Crear Encuentro</Button>
            </Card>

            <MeetingTimes meetingTimes={meetingTimes} readersGroupId={group._id}/>                                
            <RemoveReadersGroup _id={_id}/>
        </div>
    </>
}

function RemoveReadersGroup({_id}){
    const [showRemove, setShowRemove] = useState(false)
    const checkMessage = useRef("")
    function eliminarGrupo(readersGroupId){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.DELETE, readersGroupId,(err,res)=>{
            res && openSimpleDialog("Grupo de Lectura Eliminado correctamente.","Grupo eliminado")
            err && openSimpleDialog("Error eliminando grupo.", "Error")
        })
    }
    function showButtonRemove(){
        if(showRemove){
            return <>
                <div>                    
                    <p>¡Pulsando este botón eliminarás el grupo de lectura completo, todos sus miembros y todas las lecturas realizadas!</p>
                    <Button variant="contained" color="secondary" onClick={()=>{
                        openSimpleConfirm(
                            "Es muy peligroso eliminar el grupo de lectura, se perderán todas las lecturas realizadas y todos los miembros del grupo, estás seguro?","Eliminar Grupo",
                            ()=>{
                                eliminarGrupo(_id)        
                            })                
                    }}>Eliminar Grupo de Lectura</Button>            
                </div>
            </>
        }else{
            return <></>
        }
    }
    return <>

        <Card style={{maxWidth:"300px", margin:"auto", marginTop:"0.5rem"}}>
            <h2>
                Eliminar grupo de lectura
            </h2>
            <p>Debes escribir "Quiero eliminar este grupo de lectura" para poder eliminarlo.</p>
            <Input inputRef={checkMessage}/> 
            <Button style={{margin:"0.5rem"}} variant="contained" onClick={
                ()=>{
                    console.log(checkMessage.current.value)
                    if(checkMessage.current.value === "Quiero eliminar este grupo de lectura") {
                        setShowRemove(true)
                    }else{
                        openSimpleDialog("Debes escribir correctamente 'Quiero eliminar este grupo de lectura'")
                    }
                }
            }>Quiero eliminar el grupo de lectura</Button>
            {showButtonRemove()}                
        </Card>
    </>

}

### SendEmail.js
import React, { useRef, useState } from 'react'
import { Meteor } from 'meteor/meteor'
import { Button, Dialog, DialogContent, DialogTitle, Input, TextField } from '@material-ui/core'
import { EMAIL } from '../../../api/email'
import { openSimpleDialog } from '../../commons/SimpleDialog'
import { openSimpleConfirm } from '../../commons/SimpleConfirm'

export default ({readersGroup})=>{
    const [visible, setVisible] = useState(false)            

    const subject = useRef("")
    const body = useRef("")    
    function getEmailsMembers(members){
        let emails = []
        members.map((m)=>{
            if(!m.unsubscribeEmail){
                emails.push(m.email)
            }
        })
        return emails
    }
    function sendEmail(props){ 
        let emails = []
        if(props){
            if(props.test){
                emails = ['fernandomorenoruiz@gmail.com','amortabango@gmail.com']
            }
        }else{
            emails = getEmailsMembers(readersGroup.members)
        }
        Meteor.call(EMAIL.METHOD_NAMES.SEND_READERS_GROUP,{                       
            bcc:emails, 
            replyTo:"fernandomorenoruiz@gmail.com",
            subject:subject.current.value,
            text:body.current.value
        },readersGroup,(err,res)=>{
            err && console.log(err.message)
            if(!err){
                openSimpleDialog("Email enviado correctamente!","Email enviado")
            }else{
                openSimpleDialog("Error enviando los emails.","Email error")
            }
        })
        setVisible(false)
    }
    return <>
        <Button variant="contained" onClick={()=>{setVisible(true)}}>Enviar Email</Button>
        <Dialog open={visible} onClose={()=>{setVisible(false)}}>
            <DialogTitle style={{textAlign:"center"}}>Enviar email al grupo:</DialogTitle>
            <DialogContent>
                <div style={{display:"flex",flexDirection:"column",justifyContent:"center"}}>
                    <p style={{textAlign:"center"}}>Asunto:</p>
                    <Input inputRef={subject}/>
                    <p style={{textAlign:"center", marginTop:"1rem"}}>Cuerpo:</p>
                    <TextField variant="outlined" inputRef={body} style={{minWidth:"300px"}} multiline rows={6}/>   
                    <div style={{textAlign:"center"}}>
                        <Button variant="contained" color="primary" style={{margin:"auto", marginTop:"1rem",marginBottom:"1rem"}} 
                            onClick={()=>{
                                openSimpleConfirm('¿Quieres enviar el email?',"Confirmación",()=>{
                                    sendEmail()
                                })
                            }
                            }>
                            Enviar Email
                        </Button>  
                        <Button variant="contained" color="primary" style={{margin:"auto", marginTop:"1rem",marginBottom:"1rem"}} 
                            onClick={()=>{
                                openSimpleConfirm('¿Quieres enviar el email de Test?',"Confirmación",()=>{
                                    sendEmail({test:true})
                                })
                            }
                            }>
                            Enviar Test Email
                        </Button>          
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    </>
}

### AddBook.js
import React, { useRef, useState } from "react";
import Modal from "react-modal";
import { Meteor } from 'meteor/meteor'
import { BOOKS } from "../../api/books";
import { MY_BOOKS } from "../../api/myBooks";
import { openSimpleDialog } from "../commons/SimpleDialog";

export default (props) => {
  const refs = {
    title: useRef(""),
    author: useRef(""),
    content: useRef(""),
  };
  const [isOpen, setIsOpen] = useState(false);

  var onSubmit = (e) => {
    e.preventDefault();

    if (!dataValidation()) {
      return;
    }
    const title = refs.title.current.value;
    const author = refs.author.current.value;
    const content = refs.content.current.value;
    const folder = props.folder;

    if (props.myBooks) {
      Meteor.call(
        MY_BOOKS.METHOD_NAMES.INSERT_WITH_CONTENT,
        { title, author, folder },
        content,
        (err, res) => {
          if (err) {
            openSimpleDialog(err.reason);
          } else {
            refs.title.current.value = "";
            refs.author.current.value = "";
            refs.content.current.value = "";
            setIsOpen(false);
          }
        }
      );
    } else {
      Meteor.call(
        BOOKS.METHOD_NAMES.INSERT_WITH_CONTENT,
        { title, author },
        content,
        (err, res) => {
          if (err) {
            openSimpleDialog(err.reason);
          } else {
            handleModalClose();
          }
        }
      );
    }
  };
  function showUploadMyBook(){    
    if(!Meteor.user()){
      return <></>
    }
    return (<button
      className="button"
      onClick={() => {
        setIsOpen(true);
      }}
    >
      + Sube un libro
    </button>) 
    // if(Meteor.user().admin){
      // return (<button
      //   className="button"
      //   onClick={() => {
      //     setIsOpen(true);
      //   }}
      // >
      //   + Sube un libro
      // </button>) 
    // }else{
    //   return <></>
    // }
  }

  function dataValidation() {
    const title = refs.title.current.value;
    const content = refs.content.current.value;

    if (!title) {
      openSimpleDialog("El título no puede estar vacio.");
      return false;
    }
    if (!content) {
      openSimpleDialog("El texto no puede estar vacio.");
      return false;
    }
    return true;
  }

  function onDrop(event) {
    event.preventDefault();
    if (event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      console.log(file);
    }
  }

  function handleModalClose() {
    refs.title.current.value = "";
    refs.author.current.value = "";
    refs.content.current.value = "";
    setIsOpen(false);
  }

  return (
    <div>
      {showUploadMyBook()}
      <Modal
        isOpen={isOpen}
        contentLabel="Add book"
        ariaHideApp={false}
        onRequestClose={handleModalClose.bind(this)}
        overlayClassName="boxed-view boxed-view--modal"
      >
        <h2>{props.title}</h2>

        <form
          className="boxed-view__form"
          onSubmit={(e) => {
            onSubmit(e);
          }}
        >
          <input
            name="title"
            ref={refs.title}
            type="text"
            placeholder="Título"
          />
          <input
            name="author"
            ref={refs.author}
            type="text"
            placeholder="Autor"
          />
          <textarea
            onDrop={(event) => {
              onDrop(event);
            }}
            onDragOver={(e) => {
              e.preventDefault();
            }}
            name="content"
            ref={refs.content}
            placeholder="Texto"
            rows="5"
          />
          <button className="button">Subir Libro</button>
          <button
            type="button"
            className="button button--secondary"
            onClick={() => {
              handleModalClose();
            }}
          >
            Cancelar
          </button>
        </form>
      </Modal>
    </div>
  );
};


### BookEdit.js
import React, { useRef, useState } from "react";
import Modal from "react-modal";
import { BOOKS } from "../../api/books";
import { calculatePrice } from "../commons/CommonsFunctions";
import { openSimpleDialog } from "../commons/SimpleDialog";


export default (props) => {    
  const refs = { 
    title: useRef(props.book.title), 
    author: useRef(props.book.author), 
    price: useRef(props.book.price?props.book.price:4) 
  };
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState(props.book.title)
  const [author, setAuthor] = useState(props.book.author)
  var onSubmit = (e) => {
    e.preventDefault();

    if (!dataValidation()) {
      return;
    }
    
    let _price = refs.price.current.value;
    if(_price===""){
        _price = calculatePrice(props.book.length)
    }

    Meteor.call(
        BOOKS.METHOD_NAMES.SET_PRICE,
        props.book._id,
        _price,
        (err) => {
            if (err) {
                openSimpleDialog(err.reason);
            } else {
                handleModalClose();
            }
        }
    );

  };

  function dataValidation() {
    const title = refs.title.current.value;
    // const content = refs.content.current.value;

    if (!title) {
      openSimpleDialog("El título no puede estar vacio.");
      return false;
    }
    // if (!content) {
    //   alert("El texto no puede estar vacio.");
    //   return false;
    // }
    return true;
  }

  function onDrop(event) {
    event.preventDefault();
    if (event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      console.log(file);
    }
  }

  function handleModalClose() {
    refs.title.current.value = "";
    refs.author.current.value = "";
    setIsOpen(false);
  }
function renderPrice(book){
    if(book.price){
        return book.price + " €"
    }else{
        return "Precio"
    }
}
  return (
    <div>
      <button
        className="button"
        onClick={() => {
          setIsOpen(true);
        }}
      >
        {renderPrice(props.book)}
      </button>
      <Modal
        isOpen={isOpen}
        contentLabel="Add book"
        ariaHideApp={false}
        onRequestClose={handleModalClose.bind(this)}
        overlayClassName="boxed-view boxed-view--modal"
      >
        <h2>{props.title}</h2>
        <form
          className="boxed-view__form"
          onSubmit={(e) => {
            onSubmit(e);
          }}
        >
          <input
            name="title"
            ref={refs.title}
            value = {title}
            type="text"
            placeholder="Título"
          />
          <input
            name="author"
            value={author}
            ref={refs.author}
            type="text"
            placeholder="Autor"
          />
          <span>Price</span>
          <input
            name="price"
            ref={refs.price}
            type="text"
            placeholder="Price"
          />
          {/* <textarea
            onDrop={(event) => {
              onDrop(event);
            }}
            onDragOver={(e) => {
              e.preventDefault();
            }}
            name="content"
            value={content}
            ref={refs.content}
            placeholder="Texto"
            rows="5"
          /> */}
          <button className="button">Editar Libro</button>
          <button
            type="button"
            className="button button--secondary"
            onClick={() => {
              handleModalClose();
            }}
          >
            Cancelar
          </button>
        </form>
      </Modal>
    </div>
  );
};


### BookItem.js
import React from "react";
import { BOOKS } from "../../api/books";
import { ROOMS } from "../../api/rooms";
import { browserHistory } from "../../routes/routes";
import { openSimpleDialog } from "../commons/SimpleDialog";
import { calculateNumberOfPages } from "../reading/controls/Controls";

export default (props) => {
  const { book, myBook } = props
  const length = book?book.length:myBook.length
  function chooseButtons() {

    if (!props.myBook) {      
      if (props.onClickAdd && props.onClickRead) {
        return (
          <div>
            <button
              className="button button--pill"
              onClick={(e) => props.onClickRead(props.book, e)}
              style={{backgroundColor:"#A9DFBF",marginBottom:"0.2rem"}}          
            >
              Leer
            </button>
            <button
              className="button button--pill"
              onClick={(e) => props.onClickAdd(props.book, e)}
              style={{backgroundColor:"#F4F6F6",marginBottom:"0.2rem"}} 
            >
              Coger
            </button>
          </div>
        );
      }
      if (props.onClickRead) {
        return (
          <button
            className="button button--pill"
            onClick={(e) => props.onClickRead(props.book, e)}
            style={{backgroundColor:"#A9DFBF",marginBottom:"0.2rem"}}          
          >
            Leer
          </button>
        );
      }
      if (props.onClickRemove) {
        console.log("entra aqui")
        return (
          <div>
            <button
              className="button button--pill"
              onClick={(e) => props.onClickRead(props.book, e)}
              style={{backgroundColor:"#A9DFBF",marginBottom:"0.2rem"}}          
            >
              Leer
            </button>
            <button
              className="button button--pill"
              onClick={(e) => props.onClickRemove(props.book, e)}
              style={{backgroundColor:"#F4F6F6",marginBottom:"0.2rem"}} 
            >
              Coger
            </button>
          </div>
        );
      }
    }
    if (props.myBook) {
      return (
        <div>
          <button
            className="button button--pill"
            style={{backgroundColor:"#A9DFBF",marginBottom:"0.2rem"}}         
            onClick={()=>{
              if(props.myBook.bookId){
                Meteor.call(BOOKS.METHOD_NAMES.GO_TO_READ, props.myBook.bookId, (err, res) => {
                  console.log(res);
                  if (res) {
                    browserHistory.push(`/rooms/${props.myBook.bookId}`);        
                  }
                  console.log(err);
                });                
              }else{
                browserHistory.push('/rooms/myBook/'+props.myBook._id)
              }
            }}
          >
            Leer
          </button>
          <ButtonItem
              myBook={props.myBook}
              onClickReturn={props.onClickReturn.bind(this)}
              onClickRemove={props.onClickRemove.bind(this)}
            />
        </div>
      );      
    }
  }


  // main return
  return (
    <div style={{marginBottom:"0.5rem", backgroundColor:"#D5DBDB",display:"flex",flexDirection:"column",justifyContent:"center",marginLeft:"0.5rem"}}>
      <div style={{display:"flex",flexDirection:"column",justifyContent:"space-beetwen"}} className="book-item">
        <div>
          <div>
            <Title book={props.myBook ? props.myBook : props.book} />
          </div>
          <p>
            <Author book={props.myBook ? props.myBook : props.book} />      
          </p>
          <div>
            <Price book={props.myBook ? props.myBook : props.book} />        
          </div>
        </div>
        <div>{calculateNumberOfPages(length)} páginas</div>                  
      </div>
        {chooseButtons()}        
      <div style={{width:"10rem",flexDirection:"column",display:"flex",bottom:"0px",backgroundColor:"white",justifyContent:"spaceAround"}}>
      </div>      
    </div>
  );
};

function Title(props) {
  return (
    <>
      <a
        style={{ textDecoration: "none" }}
        className="book-item__title"
        href={"/book/" + props.book.title}
      >
        {props.book.title}
      </a>
    </>
  );
}

function Author(props) {
  return (
    <>
      <a
        className="book-item__author"
        href={"/books/author/" + props.book.author}
      >
        {props.book.author}
      </a>
    </>
  );
}
function Price(props) {
  // if (props.book.price) {
  //   return <><p>{/*<span style={{textDecoration:"line-through"}}>{props.book.price}</span>*/} {"(Gratis)"}</p> </>;
  // }
  return <></>;
}

function ButtonItem(props) {
  let myBook = props.myBook;
  if (myBook.bookId) {
    return (
      <button
        className="button button--pill"
        style={{backgroundColor:"white",marginBottom:"0.2rem"}}
        onClick={(e) => {
          props.onClickReturn(myBook, e);
        }}
      >
        Devolver
      </button>
    );
  } else {
    return (
      <button
        className="button button--pill"
        style={{backgroundColor:"#F5B7B1",marginBottom:"0.2rem"}}
        onClick={(e) => {
          props.onClickRemove(myBook, e);
        }}
      >
        Eliminar
      </button>
    );
  }
}


### BookItemReadersGroup.js
import React from "react";
import { calculateNumberOfPages } from "../reading/controls/Controls";

export default (props) => {
  const { readersGroup } = props
  let book;
  if(readersGroup){
    book = readersGroup.book
  }
  if(!book){
    return <></>
  }  
  return (
    <div style={{width:"12rem", marginBottom:"0.5rem", display:"flex",flexDirection:"column",justifyContent:"center"}}>
      <div className="book-item" style={{textAlign:"center"}}>        
        <div>
          <Title book={book} />
        </div>
        <div>
          <p></p>
        </div>
        <div>
          <Author book={book} />      
        </div>
        <div>
        <div>{calculateNumberOfPages(book.length)} páginas</div>
          <Price book={book} />        
        </div>

      </div>
      {/* <div style={{width:"10rem",flexDirection:"column",display:"flex",bottom:"0px",backgroundColor:"white",justifyContent:"spaceAround"}}>
      </div>       */}
    </div>
  );
};

function Title(props) {
  const {book} = props
  return (
    <>
      <span
        style={{ textDecoration: "none" }}
        className="book-item__title"
        
      >
        {book.title}
      </span>
    </>
  );
}

function Author(props) {
  const {book} = props
  return (
    <>
      <span
        className="book-item__author"        
      >
        {book.author}
      </span>
    </>
  );
}
function Price(props) {
  // if (book.price) {
  //   return <><p>{/*<span style={{textDecoration:"line-through"}}>{book.price}</span>*/} {"(Gratis)"}</p> </>;
  // }
  return <></>;
}



### BooksList.js
import React, { useState, useEffect } from "react";
import { Tracker } from "meteor/tracker";
import { Books, BOOKS } from "../../api/books";
import { MyBooks, MY_BOOKS } from "../../api/myBooks";
import { Meteor } from "meteor/meteor";
import BookItem from "./BookItem";
import FlipMove from "react-flip-move";
import { browserHistory } from "../../routes/routes";

export default function BooksList(props) {
  const [books, setBooks] = useState([]);
  const { author, title } = props;
  const [searchTerm, setSearchTerm] = useState("");

  // const localUser = useLocalUser();

  useEffect(() => {
    Meteor.subscribe(MY_BOOKS.PUBLISH_NAMES.USER);
    Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOKS);
    console.log(props.author);

    let booksTracker = Tracker.autorun(() => {
      let regexSearch = new RegExp(searchTerm, "i");
      let query = {
        $or: [{ title: regexSearch }, { author: regexSearch }],
      };

      if (title) {
        _books = Books.find(query).fetch();
      } else if (author) {
        _books = Books.find(query).fetch();
      } else {
        myBooks = _.pluck(MyBooks.find({ active: true }).fetch(), "bookId");
        query._id = { $nin: myBooks };
        _books = Books.find(query).fetch();
      }
      setBooks(_books);
    });

    return () => {
      booksTracker.stop();
    };
  }, [searchTerm]);

  function localRead(book, e) {
    browserHistory.push(`/book/reading/${book._id}`);
  }
  function onClickRead(book, e) {
    console.log("book._id:" + book._id);
    Meteor.call(BOOKS.METHOD_NAMES.GO_TO_READ, book._id, (err, res) => {
      console.log(res);
      if (res) {
        browserHistory.push(`/rooms/${book._id}`);
      }
      console.log(err);
    });
  }

  function onClickAdd(book, e) {
    console.log("onClickAdd:" + book._id);
    Meteor.call(BOOKS.METHOD_NAMES.TAKE, book._id, (err, res) => {
      console.log(err);
      if (res) {
        setTimeout(() => {
          browserHistory.push("/my_books");
        }, 500);
      }
    });
  }

  function renderBooksListItems() {
    return books.map((book) => {
      if (!!Meteor.user()) {
        return (
          <div key={book._id}>
            <BookItem
              book={book}
              onClickAdd={onClickAdd}
              onClickRead={onClickRead}
            />
          </div>
        );
      }
      return (
        <div key={book._id}>
          <BookItem book={book} onClickRead={localRead} />
        </div>
      );
    });
  }

  return (
    <div>
      <h2>Libros</h2>
      <div className="search-bar">
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder="Buscar por título o autor..."
          style={{
            padding: "10px",
            fontSize: "16px",
            width: "60%", // or some other value less than 100%
            boxSizing: "border-box",
            marginBottom: "20px",
            borderRadius: "4px",
            border: "1px solid #ccc",
          }}
        />
      </div>
      {/* <div>La mayoría de los libros han sido obtenidos de las webs:</div>
      <a target="_blank" href="https://www.elejandria.com">
        {" "}
        www.elejandria.com
      </a>{" "}
      y{" "}
      <a target="_blank" href="https://www.freeditorial.com">
        www.freeditorial.com
      </a>{" "}
      .<div>Muchas gracias por compartir el conocimiento.</div> */}
      <FlipMove className="book-list" maintainContainerHeight={true}>
        {renderBooksListItems()}
      </FlipMove>
    </div>
  );
}


### BooksPage.js
import React from "react";
import { useTracker } from 'meteor/react-meteor-data'
import { withRouter } from 'react-router'
import { Meteor } from 'meteor/meteor'
import { Link, useParams } from "react-router-dom";
import BooksList from "./BooksList";
import { PrivateHeader } from "../PrivateHeader";
import FullChat from "../reading/chat/FullChat";
import { BOOKS, Books } from "../../api/books";
import Footer from "../Footer";
import ListReadersGroup from "../readersGroup/ListReadersGroup";

export const BooksPage = () => {  
  const { author, title } = useParams();
  const { book } = useTracker(()=>{
    subs = Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOKS)
    const book = Books.findOne({title})
    return {book}
  });

  function showAuthor() {
    if (author) {
      return <h1>{author}</h1>;
    } else {
      return <></>;
    }
  }
  function showMyBooks() {
    if (true) {
      return (
        <>
          <div>
            <Link className="button button--link" 
            style={{margin:"0rem"}}
            to="/my_books">
              Mis Libros
            </Link>
          </div>          
        </>
      );
    } else {
      return <></>;
    }
  }
  if(title && !book){
    return <p>Cargando...</p>
  }
  function selectChat(){
    if(book){
      return <FullChat roomId={book._id} textButton="Comentar"/>
    }else{
      return <FullChat />
    }
  }

  
  return (
    <div>
      <PrivateHeader title="La Librería Mágica"/>
      <div className="page-content">        
        {/* <FullChat /> */}
        {/* <ListReadersGroup /> */}
        <div>{showMyBooks()}</div>        
        {showAuthor()}
        <BooksList author={author} title={title} />
      </div>
      <Footer />
    </div>
  );
};

export default withRouter(BooksPage)


### ChatGPTWithJesus.js
import React, { useState, useEffect } from "react";
import styled from "styled-components";
import { MESSAGES_GPT } from "../../api/chatGPTwithJesus";
import Loading from "../commons/Loading";
import { CSSTransition, TransitionGroup } from "react-transition-group";
import FixedHeader from "./FixedHeader";
import "./styles.css";

const ChatContainer = styled.div`
  display: flex;
  flex-direction: column;
  flex: 1;
  justify-content: space-between;
  height: 100%; // Cambiar a 100% para ocupar todo el espacio disponible
  width: 95vw;
  margin: auto;
  margin-top: 60px;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 3rem;
  background-color: #f5f5f5; // añadimos un color de fondo suave
`;

const MainContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  min-height: 100vh; // asegura que el contenedor principal tiene al menos la altura de la ventana
`;

const FixedFooter = styled.div`
  position: sticky;
  bottom: 0;
  background-color: #f5f5f5;
  height: 60px; // altura definida para el pie de página
`;

const MessagesContainer = styled.div`
  overflow-y: auto;
  margin: 0;
  flex: 1;
`;

const Message = styled.div`
  margin-bottom: 10px;
  font-size: 3rem;
  white-space: pre-wrap;
  overflow: hidden;

  max-width: 100%;
`;
const AnimatedMessage = styled.div`
  margin-bottom: 10px;
  font-size: 3rem;
  white-space: pre-wrap;
  overflow: hidden;
  max-width: 100%;
`;

const Suggerence = styled.button`
  margin-bottom: 10px;
  font-size: 2.5rem;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: #e5e5e5;
  }

  &:focus {
    outline: none;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
  }
`;

const MessageSender = styled.span`
  font-weight: bold;
  margin-right: 5px;
  font-size: 3rem;
`;

const InputContainer = styled.div`
  display: flex;
  margin-top: 20px;
`;

const TextInput = styled.input`
  flex: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 3rem;
`;

const SendButton = styled.button`
  margin-left: 10px;
  padding: 10px;
  color: white;
  background-color: #007bff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 3rem;
  transition: background-color 0.3s ease; // añadimos transiciones al botón
  box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.1); // añadimos sombras para un toque estético

  &:hover {
    background-color: #0056b3;
    box-shadow: 0px 15px 20px rgba(46, 229, 157, 0.4); // cambiamos la sombra al pasar el ratón
  }
`;
const TypingMessage = ({ text, sender, doneTyping }) => {
  const [displayedText, setDisplayedText] = useState("");
  const messagesEndRef = React.useRef(null);

  useEffect(() => {
    let i = 0;
    const intervalId = setInterval(() => {
      if (i < text.length) {
        setDisplayedText((prevText) => prevText + text.charAt(i));
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
        i += 1;
      } else {
        clearInterval(intervalId);
        doneTyping();
      }
    }, 100);

    return () => {
      clearInterval(intervalId);
    };
  }, [text, doneTyping]);

  return (
    <AnimatedMessage>
      <MessageSender>{sender}:</MessageSender> {displayedText}
      <div ref={messagesEndRef} />
    </AnimatedMessage>
  );
};

const MessageComponent = React.memo(
  ({ text, sender, isTyping, doneTyping }) => {
    return isTyping && sender === "bot" ? (
      <TypingMessage text={text} sender={sender} doneTyping={doneTyping} />
    ) : (
      <Message>
        <MessageSender>{sender}:</MessageSender> {text}
      </Message>
    );
  }
);

export const ChatGPTWithJesus = () => {
  const [messages, setMessages] = useState([
    {
      text: "¡Bienvenido(a)! Es un placer tenerte aquí. En este espacio, nos dedicamos a compartir la sabiduría de la fe católica y a buscar la paz interior. Juntos, podemos explorar las enseñanzas y valores que nos ayudarán a vivir mejor, a superar los obstáculos y a encontrarnos con nuestra espiritualidad. ¡Adelante! Estoy aquí para ayudarte en tu camino de auto-descubrimiento y crecimiento. Dime ¿En que te puedo ayudar?",
      sender: "bot",
    },
  ]);
  const [newMessage, setNewMessage] = useState("");
  const [suggerences, setSuggerences] = useState([]);
  const [loading, setLoading] = useState(false);
  const [typing, setTyping] = useState(false);

  const suggeresEndRef = React.useRef(null);

  useEffect(() => {
    suggeresEndRef.current.scrollIntoView({});
  }, [suggerences]);

  const handleKeyPress = (event) => {
    if (event.key === "Enter") {
      handleSendMessage();
    }
  };

  const callWithPromise = (method, ...myParameters) => {
    return new Promise((resolve, reject) => {
      Meteor.call(method, ...myParameters, (err, res) => {
        if (err) reject("Error", err);
        resolve(res);
      });
    });
  };

  const handleSendMessage = async () => {
    setLoading(true);
    try {
      const result = await callWithPromise(
        MESSAGES_GPT.METHOD_NAME.SEND_MESSAGES,
        newMessage
      );
      const filteredMessages = result.filter(
        (message) => message.role !== "system"
      );
      const updatedMessages = filteredMessages.map((message) => ({
        text: message.content,
        sender: message.role === "assistant" ? "bot" : message.role,
      }));
      setTyping(true);
      setMessages((prevMessages) => [...prevMessages, ...updatedMessages]);
    } catch (err) {
      console.error(err);
    }
    setNewMessage("");
  };

  const doneTyping = async () => {
    setTyping(false);
    setLoading(false);
    // try {
    //   const suggerencesResult = await callWithPromise(
    //     MESSAGES_GPT.METHOD_NAME.GET_SUGGERENCES,
    //     messages[messages.length - 1]?.text
    //   );
    //   setSuggerences(suggerencesResult.split(","));
    //   setLoading(false);
    // } catch (err) {
    //   console.error(err);
    //   setLoading(false);
    // }
  };

  return (
    <MainContainer>
      {/* <FixedHeader appName="ChatWithJesus" /> */}
      <ChatContainer>
        <MessagesContainer>
          {messages.map((message, index) => (
            <MessageComponent
              key={index}
              text={message.text}
              sender={message.sender}
              isTyping={index === messages.length - 1 && typing}
              doneTyping={doneTyping}
            />
          ))}
          <TransitionGroup>
            {suggerences.map((suggerence, index) => (
              <CSSTransition key={index} timeout={500} classNames="fade">
                <Suggerence
                  onClick={() => {
                    setSuggerences([]);
                    setNewMessage(suggerence);
                  }}
                >
                  {suggerence}
                </Suggerence>
              </CSSTransition>
            ))}
          </TransitionGroup>
          <div ref={suggeresEndRef} />
        </MessagesContainer>
        <FixedFooter>
          <InputContainer>
            <TextInput
              type="text"
              value={newMessage}
              onChange={(event) => setNewMessage(event.target.value)}
              onKeyPress={handleKeyPress}
            />
            {loading && <Loading />}
            {!loading && (
              <SendButton onClick={handleSendMessage}>Enviar</SendButton>
            )}
          </InputContainer>
        </FixedFooter>
      </ChatContainer>
    </MainContainer>
  );
};


### FixedHeader.js
import styled from "styled-components";
import React from "react";

// Crear un componente de estilo para el encabezado
const Header = styled.header`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #007bff;
  color: white;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2);
  z-index: 1000;
`;

// Crear un componente de estilo para el título
const Title = styled.h1`
  font-size: 1.5rem;
  font-weight: bold;
  margin: 0;
`;

// Definir el componente FixedHeader
const FixedHeader = ({ appName }) => (
  <Header>
    <Title>{appName}</Title>
  </Header>
);

export default FixedHeader;


### styles.css
/* styles.css */
.fade-enter {
  opacity: 0.01;
}

.fade-enter.fade-enter-active {
  opacity: 1;
  transition: opacity 500ms ease-in;
}

.fade-exit {
  opacity: 1;
}

.fade-exit.fade-exit-active {
  opacity: 0.01;
  transition: opacity 300ms ease-in;
}


### Suggerences.js
import { React } from "react";

export const Suggerences = (props) => {
  const { suggerences } = props;

  return (
    <div>
      <h1>Suggerences</h1>
      <div>
        {suggerences.map((suggerence) => {
          return <button>{suggerence}</button>;
        })}
      </div>
    </div>
  );
};


### Column.js
import React from "react";

export default (props) => {
  let style = { display: "flex", flexDirection: "column", ...props.style };
  return <div style={style}>{props.children}</div>;
};


### CommonsFunctions.js
import { PRICE_PER_CHARACTER } from "../../constants";

export function isEmail(email){
    var re = /\S+@\S+\.\S+/;
    return re.test(email);
}

export function calculatePrice(length){
    return (length*PRICE_PER_CHARACTER).toFixed(2);
}

### Loading.js
import { CircularProgress } from '@material-ui/core';
import React from 'react'

export default ({style}) =>{
    return <div style={style}><CircularProgress /></div>;
}

### Row.js
import React from "react";

export default (props) => {
  let style = { display: "flex", flexDirection: "row", ...props.style };
  return <div style={style}>{props.children}</div>;
};


### SimpleAlert.js
import { Dialog, DialogContent, DialogTitle } from '@material-ui/core';
import React, { useState, useEffect } from 'react'

let openSimpleAlertFunction;

export default function SimpleAlert(){
    const TITLE_BY_DEFAULT = "Mensaje"
    const [open, setOpen] = useState(false)
    const [message, setMessage] = useState("")
    const [title, setTitle] = useState(TITLE_BY_DEFAULT)
    function openSimpleAlert(message,title){
        setMessage(message)
        if(title){
            setTitle(title)
        }else{
            setTitle(TITLE_BY_DEFAULT)
        }
        setOpen(true)
        setTimeout(()=>{setOpen(false)},1000)
    }
    function handleClose(){  
        setMessage("")      
        setOpen(false)
    }

    useEffect(() => {
        openSimpleAlertFunction = openSimpleAlert        
    }, [])

    return (<>
        <Dialog open={open} onClose={handleClose}>
            <DialogTitle style={{textAlign:"center"}}>{title}</DialogTitle>
            <DialogContent>
                {message}
            </DialogContent>
        </Dialog>
    </>)
}

export function openSimpleAlert(message,title){
    openSimpleAlertFunction(message,title)
}

### SimpleConfirm.js
import { Button, Dialog, DialogActions, DialogContent, DialogTitle } from '@material-ui/core';
import React, { useState, useEffect, useRef } from 'react'

let openSimpleConfirmFunction;

export default function SimpleConfirm(){
    const [open, setOpen] = useState(false)
    const [message, setMessage] = useState("")
    const [title, setTitle] = useState("Mensaje")
    const acceptFunction = useRef(null)
    const cancelFunction = useRef(null)

    function openSimpleConfirm(message,title,accept,cancel){
        setMessage(message)
        if(title){
            setTitle(title)
        }
        acceptFunction.current = accept        
        cancelFunction.current = cancel
        setOpen(true)
    }
    function handleClose(){
        setMessage("")
        setOpen(false)
    }

    useEffect(() => {
        openSimpleConfirmFunction = openSimpleConfirm        
    }, [])

    return (<>
        <Dialog open={open} onClose={handleClose}>
            <DialogTitle style={{textAlign:"center"}}>{title}</DialogTitle>
            <DialogContent>
                {message}
            </DialogContent>
            <DialogActions>                
                <Button color="primary" onClick={()=>{acceptFunction.current(),setOpen(false)}}>Aceptar</Button>
                <Button color="secondary" onClick={()=>{cancelFunction.current(),setOpen(false)}}>Cancelar</Button>
            </DialogActions>
        </Dialog>
    </>)
}

export function openSimpleConfirm(message,title,accept,cancel){
    if(!cancel){
        openSimpleConfirmFunction(message,title,accept,()=>{})    
    }else{
        openSimpleConfirmFunction(message,title,accept,cancel)    
    }
}

### SimpleDialog.js
import { Button, Dialog, DialogActions, DialogContent, DialogTitle } from '@material-ui/core';
import React, { useState, useEffect } from 'react'

let openSimpleDialogFunction;

export default function SimpleDialog(){
    const TITLE_BY_DEFAULT = "Mensaje"
    const [open, setOpen] = useState(false)
    const [message, setMessage] = useState("")
    const [title, setTitle] = useState(TITLE_BY_DEFAULT)
    function openSimpleDialog(message,title){
        setMessage(message)
        if(title){
            setTitle(title)
        }else{
            setTitle(TITLE_BY_DEFAULT)
        }
        setOpen(true)
    }
    function handleClose(){  
        setMessage("")      
        setOpen(false)
    }

    useEffect(() => {
        openSimpleDialogFunction = openSimpleDialog        
    }, [])

    return (<>
        <Dialog open={open} onClose={handleClose}>
            <DialogTitle style={{textAlign:"center"}}>{title}</DialogTitle>
            <DialogContent>
                <span style={{whiteSpace:"pre-wrap"}}>{message}</span>
            </DialogContent>
            <DialogActions>
                <Button onClick={()=>{setOpen(false)}}>Cerrar</Button>
            </DialogActions>
        </Dialog>
    </>)
}

export function openSimpleDialog(message,title){
    openSimpleDialogFunction(message,title)
}

### CountDownToDate.js
import React, { useState, useEffect } from 'react'
import { compareDesc, formatDuration, intervalToDuration } from 'date-fns'
import locale  from 'date-fns/locale/es'
import { useNow } from './useNow'


export default function CountDownToDate(props){
    const { date, startDateToShow, prefix } = props    
    const [ now ] = useNow() 
    
    const [duration, setDuration] = useState(intervalToDuration({
        start: date,
        end: now,
    }))    
    
    useEffect(() => {
        setDuration(intervalToDuration({
            start: date,
            end: now,
        }))        
    }, [now])    

    if(startDateToShow && compareDesc(startDateToShow,now)===-1){
        return <></>
    }
    if(compareDesc(now,date)===1){
        return (<span>{prefix}{formatDuration(duration, {delimiter: ' ',locale})}</span>)
    }    
    
        
    return <></>
        
}


### NowCallBack.js
import React, { useEffect } from 'react'

export default function NowCallBack(props){
    const { onTimeChanged } = props
    
    useEffect(() => {
        const intervalId = setInterval(()=>{
            onTimeChanged(Date.now())
        },1000)
        return () => {
            clearInterval(intervalId)
        }
    }, [])
    return (<></>)
}

### useNow.js
import React from 'react'

export const useNow = () => {    
    const [now, setNow] = React.useState(new Date()); // Save the current date to be able to trigger an update
  
    React.useEffect(() => {
        const timer = setInterval(() => { // Creates an interval which will update the current data every minute
        // This will trigger a rerender every component that uses the useDate hook.
        setNow(new Date());
        }, 1000);
      return () => {
        clearInterval(timer); // Return a funtion to clear the timer so that it will stop being called on unmount
      }
    }, []);
      
    return [now]
  };

### DonacionCancelada.js
import React from "react";

export default function DonacionCancelada() {
  return (
    <div style={{ textAlign: "center" }}>
      ¡Sentimos mucho que no hayas donado finalmente, Gracias de todos modos!
    </div>
  );
}


### DonationButton.js
import React from "react";

export default function DonationButton() {
  return (
    <div
      style={{
        position: "fixed",
        right: "5%",
        bottom: "16vh",
        zIndex: "1000",
        opacity: "0.7",
      }}
    >
      <form action="https://www.paypal.com/donate" method="post" target="_top">
        <input type="hidden" name="hosted_button_id" value="NU2N6FLWTSYMJ" />
        <input
          type="image"
          src="https://www.paypalobjects.com/es_ES/ES/i/btn/btn_donate_LG.gif"
          border="0"
          name="submit"
          title="PayPal - The safer, easier way to pay online!"
          alt="Donate with PayPal button"
        />
        <img
          alt=""
          border="0"
          src="https://www.paypal.com/es_ES/i/scr/pixel.gif"
          width="1"
          height="1"
        />
      </form>
    </div>
  );
}


### Gracias.js
import React from "react";

export default function Gracias() {
  return <div style={{ textAlign: "center" }}>¡Gracias por tu donación!</div>;
}


### DropboxCarousel.js
import React, { useEffect, useState } from "react";
import { Meteor } from "meteor/meteor";
import Carousel from "react-material-ui-carousel";
import { Paper, Button } from "@material-ui/core";
import { Photos } from "../../api/dropWall";

export function DropboxCarousel(props) {
  const [items, setItems] = useState(null);
  useEffect(() => {
    let dropWallSubscribe = Meteor.subscribe("photos.dropWall");
    let dropWallTracker = Tracker.autorun(() => {
      const photos = Photos.find({}).fetch();
      setItems(photos);
    });

    return () => {};
  }, []);
  if (items === null) {
    return <p>Cargando...</p>;
  }
  return (
    <div
      style={{
        height: "300px",
        backgroundColor: "black",
        marginBottom: "1rem",
      }}
    >
      <Carousel indicators={false} animation="fade">
        {items.map((item) => (
          <Item item={item} />
        ))}
      </Carousel>
    </div>
  );
}

function Item(props) {
  return (
    <>
      <img src={props.item.url} />
    </>
  );
}


### LocalIndex.js
import React from 'react';
import lodash from 'lodash'

export default function LocalIndex(){
    const PREFIX = "llm-bookId:"
    function getLocaIndex(bookId){
        return localStorage.getItem(PREFIX + bookId)
    }
    function setLocalIndex(index,bookId){
        localStorage.setItem(PREFIX+bookId,index)
    }
    function getAllBooksIndexs(){
        let _ = lodash
        let booksAndIndexs = []        
        _.forIn(localStorage,(value,objKey)=>{
            if(_.startsWith(objKey,PREFIX)){
                console.log(objKey)
                let bookWithIndex = {bookId: objKey.split(":")[1],currentIndex: value}
                booksAndIndexs.push(bookWithIndex)
            }
        })        
        return booksAndIndexs
    }
    function clearAllBooksIndexs(){        
        let _ = lodash
        let keysToRemove = []        
        _.forIn(localStorage,(value,objKey)=>{
            if(_.startsWith(objKey,PREFIX)){                                
                keysToRemove.push(objKey)
            }
        })        
        keysToRemove.map((key)=>{
            localStorage.removeItem(key)
        })
    }
    return {getLocaIndex,setLocalIndex,getAllBooksIndexs,clearAllBooksIndexs}
}

### LocalUser.js
import React, { useState } from "react";

export function useLocalUser() {
    const names = ["Paco", "Migue", "Fernando", "Andrea", "Pepe"];
    const adjebtive = ["Saltamontes", "Ninja", "Destroyer", "Genial"];
    const [userId, setUserId] = useState(null);
    const [nick, setNick] = useState(null);

    getOrGenerateUser();

    function getOrGenerateUser() {
        let userId = localStorage.getItem("userId");
        let userNick = localStorage.getItem("userNick");
        if (!userId) {
            userId = randomString(17);
            userNick = generateRandomNick();
            localStorage.setItem("userId", userId);
            localStorage.setItem("userNick", userNick);
        }
        setUserId(userId);
        setNick(userNick);
    }

    function generateRandomNick() {
        return "hola";
    }
    function randomString(len) {
        var str = ""; // String result
        for (var i = 0; i < len; i++) {
            // Loop `len` times
            var rand = Math.floor(Math.random() * 62); // random: 0..61
            var charCode = (rand += rand > 9 ? (rand < 36 ? 55 : 61) : 48); // Get correct charCode
            str += String.fromCharCode(charCode); // add Character to str
        }
        return str; // After all loops are done, return the concatenated string
    }

    return {
        userId,
        nick,
    };
}


### MyBooks.js
import React from "react";
import { Link, useParams} from "react-router-dom";
import MyBooksList from "./MyBooksList";
import { PrivateHeader } from "../PrivateHeader";
import AddBook from "../books/AddBook";
import FullChat from "../reading/chat/FullChat";
import Footer from "../Footer";
import ListReadersGroup from "../readersGroup/ListReadersGroup";

export const MyBooks = (props) => {
  const { folder } = useParams();
  return (
    <div>
      <PrivateHeader title="La Librería Mágica" />
      <div className="page-content">
        {/* <FullChat /> */}
        {/* <ListReadersGroup /> */}
        <div>
          {/* <div style={{marginBottom:"0.6rem"}}>
            <div style={{fontSize:"1.6rem",backgroundColor:"white",width:"50%",margin:"auto",borderColor:"green",borderStyle:"solid"}}>
              ¡Coge más libros yendo a la Librería!
            </div>
          </div> */}
          <Link to="/books" className="button button--link">
            Ir a la Librería 
          </Link>
        </div>
        <AddBook
          folder={folder}
          myBooks={true}
          title="Sube un libro que quieras leer en la Librería Mágica"
        />        
        {/* <DropboxCarousel /> */}
        <MyBooksList folder={folder} />
      </div>
      <Footer />
    </div>
  );
};


### MyBooksList.js
import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import { MyBooks, MY_BOOKS } from "../../api/myBooks";
import { Meteor } from "meteor/meteor";
import BookItem from "../books/BookItem";
import FlipMove from "react-flip-move";
import { openSimpleConfirm } from "../commons/SimpleConfirm";

const MyBooksList = ({ folder }) => {
  const [myBooks, setMyBooks] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    const myBooksSubscription = Meteor.subscribe(
      MY_BOOKS.PUBLISH_NAMES.USER,
      fetchBooks
    );

    return () => {
      myBooksSubscription.stop();
    };
  }, [searchTerm, folder]);

  const fetchBooks = () => {
    const regexSearch = new RegExp(searchTerm, "i");
    const fetchedBooks = MyBooks.find({
      userId: Meteor.userId(),
      active: true,
      folder: folder,
      $or: [
        { title: { $regex: regexSearch } },
        { author: { $regex: regexSearch } },
      ],
    }).fetch();

    setMyBooks(fetchedBooks);
  };

  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };

  const onClickReturn = (myBook) => {
    console.log("onClickReturn:" + myBook._id);
    Meteor.call(MY_BOOKS.METHOD_NAMES.SET_ACTIVE, myBook._id, false);
  };

  const onClickRemove = (myBook) => {
    console.log("onClickRemove:" + myBook._id);
    openSimpleConfirm(
      "¿Desea eliminar el libro: " +
        myBook.title +
        "? Perderá todo el progreso de su lectura.",
      "Eliminar mi libro",
      () => {
        Meteor.call(MY_BOOKS.METHOD_NAMES.REMOVE, myBook._id);
      }
    );
  };

  const renderBooksListItems = () => {
    if (myBooks.length === 0) {
      return (
        <div className="no-books-container">
          <div className="no-books-message">
            <p>No has cogido ningún libro aún.</p>
            <p>
              ¡Ve a la
              <span>
                {" "}
                <Link to={{ pathname: `/books` }}>Librería</Link>{" "}
              </span>
              y coge tu primer libro!
            </p>
          </div>
        </div>
      );
    }
    return myBooks.map((book) => (
      <div key={book._id}>
        <BookItem
          myBook={book}
          onClickReturn={() => onClickReturn(book)}
          onClickRemove={() => onClickRemove(book)}
        />
      </div>
    ));
  };

  return (
    <div>
      <h2 style={{ color: "white" }}>Mi Libros</h2>
      <input
        type="text"
        value={searchTerm}
        onChange={handleSearchChange}
        placeholder="Buscar por título..."
        style={{
          padding: "10px",
          fontSize: "16px",
          width: "60%",
          boxSizing: "border-box",
          marginBottom: "20px",
          borderRadius: "4px",
          border: "1px solid #ccc",
        }}
      />
      <FlipMove className="book-list" maintainContainerHeight={true}>
        {renderBooksListItems()}
      </FlipMove>
    </div>
  );
};

export default MyBooksList;


### MessageViewer.js
import React, { useEffect } from "react";

export default function MessageViewer(props) {
  useEffect(() => {
    window.scrollTo(0, document.body.scrollHeight);
    return () => {};
  }, []);

  return (
    <div
      className="message-viewer"
      style={{ borderStyle: "groove", color: props.fontColor }}
    >
      {props.text}
    </div>
  );
}


### NaturalChatUI.js
import React, { useState, useEffect } from "react";
import { withRouter } from "react-router";
import { Link, useParams } from "react-router-dom";
import { Meteor } from "meteor/meteor";
import MessageViewer from "./MessageViewer";
import { NATURAL_CHAT, NaturalChat } from "../../api/naturalchat";

export const NaturalChatUI = () => {
  const { roomId } = useParams();
  const [room, setRoom] = useState({ currentUser: "Cargando..." });

  useEffect(() => {
    let handle = Meteor.subscribe("naturalchat", roomId);
    let tracker = Tracker.autorun(() => {
      if (handle.ready()) {
        let _room = NaturalChat.findOne();
        if (!_room) {
          Meteor.call(NATURAL_CHAT.METHODS.CREATE_ROOM, roomId, (err, res) => {
            console.log(res);
            setRoom(res);
          });
        } else {
          setRoom(_room);
          console.log(_room);
        }
      }
    });

    return () => {
      tracker.stop();
    };
  }, []);

  function showMessageViewer() {
    if (room) {
      return (
        <MessageViewer
          fontColor={room.fontColor}
          text={room.text}
          style={{ flex: 10 }}
        />
      );
    } else {
      return <div>Cargando...</div>;
    }
  }

  function showUserWritting() {
    if (room.currentUser === "") {
      return <div>¡Vía libre para escribir!</div>;
    } else if (room.currentUser === Meteor.userId()) {
      return (
        <>
          <span>
            Usuario escribiendo:{room.currentUsername}{" "}
            <button
              onClick={() => {
                Meteor.call(
                  NATURAL_CHAT.METHODS.CLEAN_CURRENT_USER,
                  roomId,
                  (err, res) => {
                    $("#inputText").val("");
                    console.log(res);
                    console.log(err);
                  }
                );
              }}
            >
              ¡Dar turno!
            </button>
          </span>
        </>
      );
    } else {
      return (
        <>
          <span>Usuario escribiendo:{room.currentUsername}</span>
        </>
      );
    }
  }

  function isAllowedToWrite() {
    if (room.currentUser === Meteor.userId() || room.currentUser === "") {
      return true;
    } else {
      return false;
    }
  }

  function handleMessageKeyPress(e) {
    //e.preventDefault();
    if (!isAllowedToWrite()) {
      alert("Espera que termine de escribir.");
      return;
    }
    console.log("target" + e.target.value);

    if (e.charCode === 13) {
      console.log("enter");
      Meteor.call(
        NATURAL_CHAT.METHODS.CLEAN_CURRENT_USER,
        roomId,
        (err, res) => {
          $("#inputText").val("");
          console.log("clean result:" + res);

          console.log(err);
        }
      );
    } else {
      Meteor.call(
        NATURAL_CHAT.METHODS.SEND_MESSAGE,
        roomId,
        e.target.value,
        (err, res) => {
          console.log(res);
          console.log(err);
        }
      );
    }
  }

  return (
    <div
      className="wrapper"
      style={{ display: "flex", flexDirection: "column", height: "100%" }}
    >
      <h1>NaturalChat</h1>
      {showMessageViewer()}
      {showUserWritting()}
      <div style={{ flexGrow: 1 }}>
        <input
          id="inputText"
          type="text"
          placeholder="Escribe aquí"
          onChange={handleMessageKeyPress} // update the state when typing
          onKeyPress={handleMessageKeyPress}
        />
      </div>
    </div>
  );
};

export default withRouter(NaturalChat);


### FechaHasta.js
import React from 'react'
import { formatDistance } from 'date-fns'
import locale  from 'date-fns/locale/es'

export default function FechaHasta(props){
    const {prefix, suffix, date} = props
    if(date>new Date()){
        return <div>
            {prefix}
                <span style={{textTransform:"capitalize"}}>{formatDistance(new Date(),date,{locale:locale})}</span>  
                <span> {suffix}</span>           
        </div>
    }else{
        return <></>
    }
}

### FechaYHora.js
import React from 'react'
import { format } from 'date-fns'
import locale  from 'date-fns/locale/es'

export default function FechaYHora(props){
    const {prefix, date} = props
    return <div>                   
        {prefix} 
            <span style={{textTransform:"capitalize"}}>{format(date,"EEEE dd ",{locale:locale})}</span>
             <span> de </span> 
             <span style={{textTransform:"capitalize"}}>{format(date," LLLL",{locale:locale})}</span>
             <span> a las </span>
             <span style={{textTransform:"capitalize"}}>{format(date," H:mm (O)",{locale:locale})}</span>
    </div>
}

### ListReadersGroup.js
import React from 'react'
import { Meteor } from "meteor/meteor";
import { useTracker } from "meteor/react-meteor-data";
import { ReadersGroups, READERS_GROUPS } from '../../api/readersGroups';
import { Card, CardContent, CircularProgress } from '@material-ui/core';
import Loading from '../commons/Loading';

export default function (){

    const { readersGroups, loading } = useTracker(()=>{
        const subs = Meteor.subscribe(READERS_GROUPS.PUBLISH_NAMES.ALL_NAMES)
        const readersGroups = ReadersGroups.find({}).fetch()
        return { readersGroups, loading:!subs.ready() }
    })

    if(loading){
        return <div><Loading style={{marginTop:"0.5rem"}} /></div>;
    }
    return <>
        <div style={{marginBottom:"1rem"}}>
            <Card style={{backgroundColor:"#E8F8F5"}}>                                
                <CardContent>                    
                    <h2 style={{color:"",margin:"0.5rem"}}>Clubs de lectura</h2>
                    {readersGroups.map((group)=>(
                        <ReadersGroupItem key={group._id} {...group}/>
                    ))}
                </CardContent>
            </Card>
        </div>
    </>
}
function ReadersGroupItem(props){
    const {name,_id} =  props
    return <h3><a className='reader_group_item' href={`/readersGroup/${_id}`}>{name}</a></h3>
}

### ReadersGroup.js
import React, { useEffect, useState } from 'react'
import { useParams } from 'react-router'
import { Meteor } from 'meteor/meteor'
import { useTracker } from 'meteor/react-meteor-data'
import { Button } from '@material-ui/core'
import { format, subDays } from 'date-fns'
import locale  from 'date-fns/locale/es'
import { ReadersGroups, READERS_GROUPS } from '../../api/readersGroups'
import { ROOMS, Rooms } from '../../api/rooms'
import { PrivateHeader } from '../PrivateHeader'
import FullChat from '../reading/chat/FullChat'
import BookItemReadersGroup from '../books/BookItemReadersGroup'
import { calculateNumberOfPages, calculateTimeToRead } from '../reading/controls/Controls'
import { Constants } from '../../constants'
import Footer from '../Footer'
import { BOOKS } from '../../api/books'
import { browserHistory } from '../../routes/routes'
import RoomsReadersGroup from './RoomsReadersGroup'
import { openSimpleDialog } from '../commons/SimpleDialog'
import { openSimpleConfirm } from '../commons/SimpleConfirm'
import SignUpForm from '../signup/SignUpForm'
import CountDownToDate from '../commons/date/CountDownToDate'
import ReadingMode from '../reading/ReadingMode'
import Loading from '../commons/Loading'
import NextMeetings from './meetings/NextMeetings'
import { Link } from 'react-router-dom'
import LoginForm from '../signup/LoginForm'


export default function ReadersGroup(){
    const { id, action } = useParams()
    const { readersGroup, isInGroup, isAuth } = useTracker(()=>{        
        Meteor.subscribe(READERS_GROUPS.PUBLISH_NAMES.BY_ID,id)
        let readersGroup;
        readersGroup = ReadersGroups.findOne({_id:id})
        let usersIds = []        
        if(readersGroup){
            usersIds = _.pluck(readersGroup.members,"userId")            
        }
        const isInGroup = _.contains(usersIds,Meteor.userId())
        return {readersGroup, isInGroup, isAuth:!!Meteor.userId()}
    })
    const {myCurrentIndex} = useTracker(()=>{
        const subRooms = Meteor.subscribe(ROOMS.PUBLISH_NAME.READERSGROUP_OF_USER,id);
        if(readersGroup){
            const rooms = Rooms.find({ participants:{$elemMatch:{userId:Meteor.userId()}}, readingId:readersGroup.readingId}).fetch()
            console.log(rooms)
            if(rooms.length>0){
                console.log(calculateNumberOfPages(rooms[0].currentIndex))
                return {myCurrentIndex: rooms[0].currentIndex}        
            }
        }
        return {myCurrentIndex:-1}
        

    })

    useEffect(() => {
        if(action==="unsubscribe"){
            openSimpleConfirm("¿Confirmas que deseas dejar de recibir emails del grupo?","Baja Emails",()=>{
                Meteor.call(READERS_GROUPS.METHODS_NAMES.UNSUBSCRIBE_EMAIL,id,(err,res)=>{
                    console.log("terminado")
                    console.log(res)
                    err && openSimpleDialog('Error en la baja del email, contacta con el administrador: fernandomorenoruiz@gmail.com. Disculpe las molestias.','Error en la baja')
                    res && openSimpleDialog('Gracias!Ya no recibirás más emails del grupo.','Baja Notificaciones por Email')                
                })
            })
        }
        
    }, [])

    return <div>        
        <PrivateHeader title="La Librería Mágica"/>
            <div className="page-content">   
                {(()=>{
                    if(readersGroup && !readersGroup.book.title){
                        return <>
                            <h2>Estamos configurando la nueva lectura. Prueba a entrar en 5 minutos para verla. </h2>
                            <h2>Disculpa las molestias.</h2>
                        </>

                    }
                    return <ReadersGroupView myCurrentIndex={myCurrentIndex} readersGroup={readersGroup} isInGroup={isInGroup} isAuth={isAuth}/>
                })()}
            </div>
        </div>
}

function ReadersGroupView(props){
    const { readersGroup, isInGroup, isAuth, myCurrentIndex } = props
    const [showLogin, setShowLogin] = useState(false)
    function showRegisterButton(){
        if(!isAuth){
            if(!showLogin){
                return <div style={{maxWidth:"300px", margin:"auto"}}>
                            <h2>Si quieres entrar en el grupo</h2>
                            <h2>Regístrate Gratis</h2>                        
                            <SignUpForm onSuccess={()=>{                    
                                joinToReading()
                            }}/>
                            <div>si ya tienes cuenta, <Link to="#" onClick={()=>setShowLogin(true)} >Inicia sensión</Link></div>
                            <div style={{marginBottom:"1rem"}}></div>
                        </div>
            }else{
                return <div style={{maxWidth:"300px", margin:"auto"}}>                            
                            <h2>Iniciar Sesión</h2>                        
                            <LoginForm onSuccess={()=>{     
                                openSimpleDialog("Has iniciado sesión correctamente.","Inicio de Sesión")               
                                // joinToReading()
                            }}/>
                            <div>si no tienes cuenta, <Link to="#" onClick={()=>setShowLogin(false)}>Registrate</Link></div>
                            <div style={{marginBottom:"1rem"}}></div>
                        </div>
            }
        }else{
            return <></>
        }
    }
    function showJoinButton(){
        if(!isAuth){
            return <></>
        }
    
        if(!isInGroup){
            return <Button onClick={
                ()=>{
                    openSimpleConfirm("¿Deseas unirte al grupo?","Unirse al grupo",()=>{
                        joinToReading()
                    })
                }
            } style={{marginBottom:"1rem"}} variant="contained" color="primary">Unirme al Grupo</Button>
        }else{
            return <></>
        }
    }

    function goToRead(bookId,readersGroupId, readingId){
        console.log(readingId)
        Meteor.call(BOOKS.METHOD_NAMES.GO_TO_READ_GROUP_READING, bookId,readersGroupId, readingId,  (err, res) => {
            console.log(res);
            if (res) {
              browserHistory.push(`/room/reading/${res}`);        
            }
            console.log(err);
          });
    }
    function goToTraditionalRead(bookId,readersGroupId, readingId){
        console.log(readingId)
        Meteor.call(BOOKS.METHOD_NAMES.GO_TO_READ_GROUP_READING, bookId,readersGroupId, readingId,  (err, res) => {
            console.log(res);
            if (res) {
              browserHistory.push(`/room/fullreading/${res}`);        
            }
            console.log(err);
          });
    }
    
    function joinToReading(){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.JOIN,readersGroup._id,(err,res)=>{
            if(res){
                openSimpleDialog("¡Ya puedes empezar a leer y a chatear con nosotros!","¡Felicidades!")
            }
            err && openSimpleDialog(err.message,"Error")
        })
    }
        
    if(!readersGroup){
        return <div><Loading style={{marginTop:"0.5rem"}} /></div>;
    }
    return (
        <>
            {/* <Link to="/my_books" className="button button--link" style={{margin:"0.5rem"}}>
              Ir a Mis Libros
            </Link>        
            <Link to="/books" className="button button--link">
              Ir a la Librería
            </Link>  */}
            <h1 className='reader_group_title'>Club de Lectura: {readersGroup.name}</h1>
            {showJoinButton()}
            {showRegisterButton()}
            <FullChat currentIndex={myCurrentIndex} readingId={readersGroup.readingId} roomId={readersGroup._id} readingId={readersGroup.readingId} antiSpoiler={true} viewOnly={!isInGroup}/> 
            <h2>Lectura Actual</h2>
            <CurrentReading readersGroup={readersGroup} />
            <div style={{ margin:"auto",marginTop:"0.5rem"}}>
                <ReadingMode conditionToRead={isInGroup} 
                    onClickRead={
                        ()=>{
                            if(isInGroup){                    
                                goToRead(readersGroup.book._id,readersGroup._id, readersGroup.readingId)
                            }else{
                                openSimpleDialog("Haz click en 'Unirme al grupo' y empieza a leer y chatear.","Únete al grupo")
                            }
                        }
                    }         
                    onClickTraditional={
                        ()=>{
                            if(isInGroup){                    
                                goToTraditionalRead(readersGroup.book._id,readersGroup._id, readersGroup.readingId)
                            }else{
                                openSimpleDialog("Haz click en 'Unirme al grupo' y empieza a leer y chatear.","Únete al grupo")
                            }
                        }
                    }
                />
                
            </div>            
            <NextMeetings readersGroup={readersGroup} isInGroup={isInGroup} />
            <RoomsReadersGroup book_id={readersGroup.book._id} readingId={readersGroup.readingId} readersGroupId={readersGroup._id} readOnly={!isAuth}/>
            <Footer />
        </>
    )
}




function CurrentReading(props){
    const { readersGroup } = props
    return (
        <div style={{display:"flex", flexDirection:"row", justifyContent:"center", backgroundColor:"#E9F5F7",padding:"0.5rem", borderRadius:"1rem"}}>                   
            <BookItemReadersGroup readersGroup={readersGroup} />                                 
            <div style={{display:"flex", flexDirection:"column", marginLeft:"3rem", marginTop:"1rem"}}>
                <h3>
                    <span style={{textDecoration:"underline"}}>Fecha de Comienzo:</span> <FechaLectura date={readersGroup.startDate}/>
                </h3>                    
                    <CountDownToDate date={readersGroup.startDate}/>
                <br/>                    
                <h3>
                    <span style={{textDecoration:"underline"}}>Fecha de Fin:</span><FechaLectura date={readersGroup.endDate}/>
                </h3>                        
                    <CountDownToDate date={readersGroup.endDate} startDateToShow={readersGroup.startDate}/>
                <br/>                                                                
                <br/>
                <PaginasLeidasNecesarias readersGroup={readersGroup} />
                <br/>
                <LecturaTerminada readersGroup={readersGroup} />
                <div>Tiempo estimado de lectura:</div>                    
                <div>{calculateTimeToRead(readersGroup.book.length,Constants.READING.READING_TIME_INTERVAL)}</div>                    
            </div>
        </div>
    )
}

function FechaLectura(props){
    const {prefix, date} = props
    return <div>
        {prefix} 
            <span style={{textTransform:"capitalize"}}>{format(date,"EEEE dd",{locale:locale})}</span>
             <span> de </span> 
             <span style={{textTransform:"capitalize"}}>{format(date,"LLLL",{locale:locale})}</span>
    </div>
}



function PaginasLeidasNecesarias(props){
    const { book, startDate, endDate } = props.readersGroup
    const readTime = Date.now()-startDate;
    const timeToRead = subDays(endDate,0) - startDate
    let percentage;
    if(readTime<timeToRead){
        percentage = readTime/timeToRead   
    }else{
        percentage = 1
    }
    const currentIndex = percentage * book.length
    const currentPage = calculateNumberOfPages(currentIndex)
    if(Date.now() > startDate && Date.now() < endDate && percentage<1){
        return <div>                    
                    Si vas por la <span style={{textDecoration:"underline"}}>página: {currentPage}</span> vas bien!
                </div>
    }else{
        return <></>
    }
}

function LecturaTerminada(props){
    const { endDate } = props.readersGroup
    if(Date.now()>endDate){
        return <div>Lectura Finalizada</div>
    }else{
        return <></>
    }
}

### RoomReadersGroup.js
import React, { useState } from "react";
import Button from "@material-ui/core/Button";
import {
  Typography,
  LinearProgress,
} from "@material-ui/core";
import { Meteor } from "meteor/meteor";
import Card from "@material-ui/core/Card";
import CardActions from "@material-ui/core/CardActions";
import CardContent from "@material-ui/core/CardContent";
import { Link } from "react-router-dom";
import { ROOMS } from "../../api/rooms";
import { Constants } from "../../constants";
import { browserHistory } from "../../routes/routes";
import { openSimpleDialog } from "../commons/SimpleDialog";
import { openSimpleConfirm } from "../commons/SimpleConfirm";
import User from "../users/User";

export default function Room(props) {  
  const { readOnly } = props
  
  function remove() {
    openSimpleConfirm(
      "¿Desea eliminar al sala: " + props.title + "?",
      "Eliminar Sala",
      ()=>{
        Meteor.call(ROOMS.METHOD_NAMES.REMOVE, props._id, (err, res) => {
          err && openSimpleDialog(err.reason,"Error");
          res && console.log(res);
        });
      }
    )
  }

  function showRemoveButton() {
    if(!Meteor.user()){return <></>}
    if (props.ownerId === Meteor.user()._id) {
      return (
        <Button variant="contained" color="secondary" onClick={remove}>
          Eliminar
        </Button>
      );
    }
    return <></>;
  }

  function urlReadingRoom(){    
    if(readOnly){
      return ""
    }
    if(!Meteor.user()){return <></>}
    if (props.ownerId === Meteor.user()._id) {
      return `/room/reading/${props._id}`
    }else{
      return `/room/reading/${props._id}/false`
    }
  }

  function isOwner(){
    if(!Meteor.user()){ return false}
    return props.ownerId === Meteor.user()._id
  }
  function showRestartButton() {
    if(!Meteor.user()){return <></>}
    if (isOwner()) {
      return (
        <Button
            variant="contained"
            color="secondary"
            onClick={() => {
              openSimpleConfirm(
                "¿Desea reiniciar la sala: " + props.title + "?",
                "Reiniciar Sala",
                ()=>{
                  Meteor.call(ROOMS.METHOD_NAMES.UPDATE_INDEX, props._id, 10);
                }
              )
            }}
          >
            Reiniciar
          </Button>
      );
    }
    return <></>;
  }

  function showReadsButtons(){
    if(!Meteor.user()){return <></>}
    if(!isOwner()){
      return (<>
        <Button
          variant="contained"
          onClick={() => {
            browserHistory.push(urlReadingRoom());
          }}
        >
          Ver Sala
        </Button>
        <Button
          variant="contained"
          onClick={() => {
            browserHistory.push(`/room/fullreading/${props._id}`);
          }}
        >
          Ver Sala Texto Completo
        </Button>
      </>)
    }else{
      return (<>
        <Button
          variant="contained"
          color="primary"
          style={{ backgroundColor: '#357a38' }}
          onClick={() => {
            browserHistory.push(urlReadingRoom());
          }}
        >
          Entrar a Leer
        </Button>
        <Button
          variant="contained"
          color="primary"
          style={{ backgroundColor: '#357a38' }}
          onClick={() => {
            browserHistory.push(`/room/fullreading/${props._id}`);
          }}
        >
          Lectura Tradicional
        </Button>
      </>)
    }
  }
  function showIsOwnControl(isOwn) {
    if (isOwn) {
      return <span>Own Control</span>;
    } else {
      return <></>;
    }
  }

  function calculateProgress(index, length) {
    if (index > length) {
      return 100;
    }
    return (index * 100) / length;
  }
  function calculateNumberOfPages(index) {
    return Math.floor(index / Constants.READING.LETTERS_PER_PAGE);
  }

  function Participants(participants){
    return participants.map((participant)=>{
      return <User key={participant._id} user={participant} />
    })
  }

  function Invitations(invitations){
    return invitations.map((invitation)=>{
      let invitationValue;
      if(invitation.username){
        invitationValue = invitation.username
      }else{
        invitationValue = invitation.email
      }
      return <p style={{color:"blue", textAlign:"center"}}>{invitationValue}</p>
    })
  }

  function showInvitadosButton(invitations){    
    if(invitations.length>0){
      return (<Button
                variant="contained"             
                onClick={() => {              
                   openSimpleDialog(Invitations(invitations),"Lectores Invitados a la Sala");
                }}
              >
                Invitados: {invitations.length}
              </Button>)
    }else{
      return <></>
    }
  }  
  function getCardStyle(){
    if(isOwner()){
      return {backgroundColor:"#D0F8CF"}
    }else{
      return {}
    }
  }
  return (
    <div style={styles.room}>
      <Card style={getCardStyle()}>
        {showIsOwnControl(props.isOwnControl)}
        <CardContent>
          <Typography variant="h5" component="h2">
            <Link
              className="button button--pill button--link"
              to={{ pathname:urlReadingRoom() }}
            >
              {props.title}
            </Link>
            <div style={{ fontSize: "1.5rem", backgroundColor: "#F9EBE2" }}>
              <span style={{ fontWeight: "bold" }}>
                {calculateNumberOfPages(props.currentIndex)}
              </span>{" "}
              Páginas leídas
              {" de  "}
              {calculateNumberOfPages(props.length)}
            </div>
            <LinearProgress
              variant="determinate"
              value={calculateProgress(props.currentIndex, props.length)}
            />
          </Typography>
        </CardContent>
        <CardActions style={{display:"flex",justifyContent:"center"}}>            
            {showReadsButtons()}
        </CardActions>
        <CardActions style={{display:"flex",justifyContent:"center"}}>
            <div>
              <h3>Lector:</h3>
              {Participants(props.participants)}
            </div>
            {showInvitadosButton(props.invitations)}        
        </CardActions>
        <CardActions style={{display:"flex",justifyContent:"center"}}>
          {showRestartButton()}
          {showRemoveButton()}          
        </CardActions>
      </Card>
      {/*/<!-- -->*/}
    </div>
  );
}
function Lectores(props){
  const {  } = props
}

const styles = {
  title: {
    fontWeight: "bold",
  },
  room: {
    marginBottom: "1rem",
  },
};


### RoomsReadersGroup.js
import React from "react";
import { useTracker } from "meteor/react-meteor-data";
import { Meteor } from 'meteor/meteor'
import { Rooms, ROOMS } from "../../api/rooms";
import RoomReadersGroup from "./RoomReadersGroup"
import Loading from "../commons/Loading";

export default (props) => {
  const { readingId, readersGroupId, readOnly } = props  
  const { rooms, loading } = useTracker(()=>{
    const subRooms = Meteor.subscribe(ROOMS.PUBLISH_NAME.READERSGROUP,readersGroupId);
    return {loading:!subRooms.ready() ,rooms:Rooms.find({readingId},{sort:{currentIndex:-1}}).fetch()}
  });  
  if (loading) {
    return <Loading style={{marginTop:"0.5rem"}} />
  }
  
  return (
    <>
      <h2 style={{marginTop:"0.5rem"}}>Salas de Lectores ({rooms.length})</h2>        
      {rooms.map((room) => {
        return <RoomReadersGroup key={room._id} readOnly={readOnly} {...room} />;
      })}
    </>
  );
   
};


### Meeting.js
import { Button } from '@material-ui/core'
import React from 'react'
import { Link } from 'react-router-dom'
import { READERS_GROUPS } from '../../../api/readersGroups'
import CountDownToDate from '../../commons/date/CountDownToDate'
import { openSimpleConfirm } from '../../commons/SimpleConfirm'
import { openSimpleDialog } from '../../commons/SimpleDialog'
import User from '../../users/User'
import FechaYHora from '../FechaYHora'

export default function Meeting(props){
    
    const {meeting, readersGroupId, isInGroup } = props

    function joinToMeeting(readersGroupId, meetingId){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.JOIN_TO_MEETING, readersGroupId, meetingId, (err,res)=>{
            err && openSimpleDialog(err.message)
            res && openSimpleDialog("Se apuntado correctamente al encuentro de lectura.","Encuentro de lectura.")

        })
    }
    function quitToMeeting(readersGroupId, meetingId){
        Meteor.call(READERS_GROUPS.METHODS_NAMES.QUIT_TO_MEETING, readersGroupId, meetingId, (err,res)=>{
            err && openSimpleDialog(err.message)
            res && openSimpleDialog(res)

        })
    }
    function showAsistirButton(){    
        if(_.contains(_.pluck(meeting.people,"userId"),Meteor.userId())){
            // return <Button onClick={()=>{
            //     quitToMeeting(readersGroupId, meeting._id)
            // }}>Salir</Button>
            return <span style={{color:"green"}}>Estoy apuntado.</span>
        }else{            
            return <Button variant="contained" onClick={()=>{
                if(!isInGroup){
                    openSimpleDialog("Haz click en 'Unirme al grupo' y empieza a leer y chatear.","Únete al grupo")
                    return;
                }
                openSimpleConfirm(
                    "¿Confirma que desea asistir a este encuentro de lectura?",
                    "Asistir"
                    ,()=>{
                        joinToMeeting(readersGroupId, meeting._id)
                    })
            }}>Asistir</Button>
        }
    }
    function showPeople(people){
        console.log(people)
        return (           
            <div style={{textAlign:"center"}}>
                {people.map((p)=>(<User key={p._id} user={p} />))}
            </div> 
        )
    }
    function showCoordinators(people){
        if(people.length===0) return <></>
        return (
            <div>
                Coordinado por:  <span>{people.map((p)=>{if(p.admin===true){return <span style={{color:"blue"}}>{p.username} </span>}})}</span>
            </div>
        )
    }
    return <div style={{margin:"1rem"}}>
            <div style={{display:"flex",flexDirection:"row", justifyContent:"center",verticalAlign:"center"}}>            
                <div style={{display:"flex",flexDirection:"column", justifyContent:"center", fontWeight:"bold",fontSize:"1.5rem"}}>
                    <FechaYHora date={meeting.date} />
                    <span style={{fontWeight:"normal"}}><CountDownToDate prefix="Comienza en " date={meeting.date} /></span>
                </div>
                </div>
                <div>
                    <Link onClick={()=>{
                        openSimpleDialog(showPeople(meeting.people),"Asistentes")
                    }}>{meeting.people.length} Lectores</Link> asistirán. {showAsistirButton()}
                </div>
                {showCoordinators(meeting.people)}
            </div>
}

### NextMeetings.js
import React from 'react'
import Meeting from './Meeting'
import { compareAsc } from 'date-fns'


export default function NextMeetings(props){
    const { isInGroup } = props
    const { meetingTimes, _id } = props.readersGroup      
    let filteredMeetings = meetingTimes.filter(
        (meeting)=>{ 
            return compareAsc(meeting.date, new Date()) === 1 
            || (compareAsc(meeting.date, new Date()) === 1 && compareAsc(now, new Date()) === 1)  })
    filteredMeetings.sort((a,b)=>{ return compareAsc(a.date,b.date)})        
    if(filteredMeetings.length === 0) {
        return <></>
    }
    if(filteredMeetings.length > 3){
        filteredMeetings = filteredMeetings.slice(0,2)
    }
    console.log(filteredMeetings)
    return (
        <div>            
            <h2>Siguientes Encuentros de Lectura</h2>
            <p>Apuntaros al turno de lectura que queráis para leer en compañía.</p>
            <div style={{display:"flex", flexDirection:"column", justifyContent:"center", backgroundColor:"#E9F5F7",padding:"0.5rem", borderRadius:"1rem"}}>
                <div style={{textAlign:"center"}}>(Fecha y hora de tu país)</div>
                {filteredMeetings.map((meeting)=>{
                    return <Meeting key={meeting._id} meeting={meeting} readersGroupId={_id} isInGroup={isInGroup}/>
                })}
                
            </div>
        </div> )

}

### CommonsReader.js
import { useState } from "react";
export function goDown() {
  const endBlock = document.getElementById("end-block");
  endBlock.scrollIntoView({
    behavior: "auto",
    block: "start",
    inline: "nearest",
  });
}

export function useAvoidScrollModal() {
  const [scrollY, setScrollY] = useState(null);

  function beforeShowModal() {
    // console.log(new Error("I was called").stack);
    document.body.style.overflowY = "hidden";
    document.body.style.paddingRight = "15px";
    setScrollY(window.scrollY);
    // console.log("setScrollY(window.scrollY);:" + scrollY);
  }
  function afterCloseModal() {
    document.body.style.overflowY = "";
    document.body.style.paddingRight = "0px";
    window.scrollTo(0, scrollY);
    goDown();
  }
  return {
    beforeShowModal,
    afterCloseModal,
  };
}


### FullReader.js
import React, { useEffect } from "react";
import { Helmet } from "react-helmet";
import { useLocalCommands } from "./controls/Commands";
import FullVisualizer from "./FullVisualizer";

export const READER_STATUS = {
  PAUSED: "paused",
  RUNNING: "running",
};
/**
 *
 * @param {string} content content of reader
 * @param {string} title title of book
 * @param {int} index set index to see the text until this index
 * @param {string} id roomId or myBookId.
 * @param {function} commands hook of commands to execute the commands (remote ones from now)
 * @param {function} onFinished function that is triggered when the reading is finished
 */
export default function FullReader(props) {
  const {
    content,
    index,
    title,
    id,
    timeInterval,
    status,
    onFinished,
    room,
    stopIndex
  } = props;
  // console.log("timeInterval:" + props.timeInterval);
  //  this variable get a hook that store functions to play, pause and do all commands
  //  of the reader
  let commands = null;

  if (props.commands) {
    commands = props.commands(
      content.length,
      id,
      timeInterval,
      status,
      onFinished
    );
  } else {
    console.log("useLocalCommands")
    commands = useLocalCommands(
      content.length,
      id,
      timeInterval,
      status,
      stopIndex,
      onFinished
    );
  }


  /* When the component receive a new index, the componet set the new
  index in command to update the index in the reader.*/
  try {
    useEffect(() => {
      if (
        (room && room.participants.length > 1) ||
        index > commands.currentIndex ||
        (room && room.state !== READER_STATUS.RUNNING)
      ) {
        commands.setCurrentIndex(index);
      }
    }, [index]);
  } catch (e) {
    // the exception happens when participants changes
    location.reload();
  }

  /* When component receives a new timeInterval, the component set the new
  timeInterval in command to update the speed of the reader */
  useEffect(() => {
    commands.setTimeInterval(timeInterval);
  }, [timeInterval]);

  return (
    <>
      {/* This component change the title of the page */}
      <Helmet>
        <meta charSet="utf-8" />
        <title>{title + " - La Librería Mágica"}</title>
      </Helmet>

      {/* the place where words appears */}
      <FullVisualizer
        content={content}
        currentIndex={commands.currentIndex}
        progress={room.progress?room.progress:-1}
        roomId={room._id}
        status={status}
      />

      {/* controls of play, pause and the title and time left */}
      
    </>
  );
}


### FullReadingRoom.js
import React from "react";
import { Tracker } from "meteor/tracker";
import { withRouter } from "react-router-dom";
import { Rooms, ROOMS } from "../../api/rooms";
import { ContentBooks } from "../../api/contentBooks";
import { useRemoteCommands } from "./controls/CommandsRemote";
import { Commons } from "../../api/commons";
import { useLocalRoomCommands } from "./controls/CommandsLocalRoom";
import { Snackbar, SnackbarContent } from "@material-ui/core";
import { openSimpleDialog } from "../commons/SimpleDialog";
import FullReader from "./FullReader";
import Row from "../commons/Row";
import CloseButton from "./roomButtons/CloseButton";
import SaveProgress from "./roomButtons/SaveProgess";
import Chat from "./chat/Chat";
import FabAmigosConnected from "../users/FabAmigosConnected";
import Loading from "../commons/Loading";

class FullReadingRoom extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      id: this.props.match.params.id,
      room: null,
      timeInterval: -1,
      content: "",
      currentIndex: null,
      allReady: false,
      anchorEl: null,
      isAuthenticated: !!Meteor.user(),
    };
  }
  pauseReading() {
    if (!this.state.room) return;
    Meteor.call(ROOMS.METHOD_NAMES.PAUSE_READING, this.state.room._id);
  }
  componentDidMount() {
    const handleRooms = Meteor.subscribe(
      ROOMS.PUBLISH_NAME.BY_ID_WITH_CONTENT,
      this.state.id
    );

    if (this.state.isAuthenticated) {
      this.setUserStatus(ROOMS.USER_STATUS.OFF.value);
    }
    this.trackerRooms = Tracker.autorun(() => {
      this.setState({ isAuthenticated: !!Meteor.user() });
      if (handleRooms.ready()) {
        let room = Rooms.findOne({ _id: this.state.id });
        if (!room.progress) {
          room.progress = 0.00001;
        }
        if (_.isEqual(room, this.state.room)) {
          return;
        }
        this.setState({ room });
        this.setState({ timeInterval: room.speedReading });
        if (!this.state.content) {
          const content = ContentBooks.findOne({
            _id: room.contentId,
          });
          if (content && content.sharedUrl) {
            this.setState({ content: "Cargando.." });
            Commons.getTextFromUrl(content.sharedUrl, (text) => {
              this.setState({ content: text });
            });
          } else if (content) {
            this.setState({ content: content.content });
          }

          setTimeout(() => {
            window.scrollTo(
              0,
              document.body.offsetHeight * this.state.room.progress
            );
          }, 1000);
        }
      }
    });
  }
  showChat() {
    if (this.state.room.readersGroupId) {
      return (
        <Chat
          style={{
            position: "fixed",
            top: "2vh",
            right: "2vw",
            opacity: "0.7",
            zIndex: 10000,
          }}
          roomId={this.state.room.readersGroupId}
          readingId={this.state.room.readingId}
          currentIndex={this.state.room.currentIndex}
          antiSpoiler={true}
          onInputFocus={() => {
            let roomPercentage = window.scrollY / document.body.offsetHeight;
            Meteor.call(
              ROOMS.METHOD_NAMES.UPDATE_PROGRESS,
              this.state.room._id,
              roomPercentage,
              (this.state.room.length * roomPercentage).toFixed(),
              (err, res) => {
                err && openSimpleDialog(err.message, "Error");
                res &&
                  openSimpleAlert(
                    "Guardado correctamente.",
                    "Progreso Guardado."
                  );
                console.log(res);
              }
            );
          }}
          // onChatCreated={()=>{
          //   openSimpleDialog("Cuando escribes desde el Chat de esta sala, solo podrán ver tus mensaje las personas que ya hayan llegado a la página por la que vas del libro para evitar que lean algo indebido. ¡Así que escribe libremente sobre el tema que estés leyendo sin miedo! \n\nSi escribes algo que no es sobre la lectura, sal de esta sala y escribe desde el grupo de lectura para que todos te puedan leer.", "AntiSpoiler Activado")
          // }}
        />
      );
    } else if (this.state.room.participants.length > 1) {
      return (
        <Chat
          style={{
            position: "fixed",
            top: "2vh",
            right: "2vw",
            opacity: "0.7",
            zIndex: 10000,
          }}
          roomId={this.state.room.readersGroupId}
          readingId={this.state.room.readingId}
          currentIndex={this.state.room.currentIndex}
          antiSpoiler={true}
        />
      );
    }

    return <></>;
  }
  componentWillUnmount() {
    this.trackerRooms.stop();
    this.pauseReading();
  }

  setUserStatus(status) {
    Meteor.call(
      ROOMS.METHOD_NAMES.SET_USERSTATUS,
      this.state.id,
      status,
      (err, res) => {
        err && console.log(err) && openSimpleDialog(err);
        res && console.log(res);
      }
    );
  }
  allParticipantIsReady(participants) {
    let result = true;
    participants.forEach((p) => {
      if (p.status !== "on") {
        result = false;
      }
    });
    return result;
  }

  getCommands(room) {
    if (room.participants.length > 1) {
      return useRemoteCommands;
    } else {
      return useLocalRoomCommands;
    }
  }

  render() {
    if (this.state.room === null) {
      return <Loading style={{ textAlign: "center", marginTop: "5rem" }} />;
    }
    return (
      <div
        onScroll={() => {
          console.log("hola");
        }}
      >
        <FullReader
          content={this.state.content}
          index={this.state.currentIndex}
          title={this.state.room.title}
          timeInterval={this.state.timeInterval}
          commands={this.getCommands(this.state.room)}
          id={this.state.room._id}
          room={this.state.room}
          participants={this.state.room.participants}
          status={this.state.room.state}
        />
        <Row
          style={{
            position: "fixed",
            top: "5vh",
            left: "2vw",
          }}
        >
          <FabAmigosConnected style={{ color: "white" }} />
        </Row>
        <Row
          style={{
            position: "fixed",
            bottom: "16vh",
            left: "2vw",
            opacity: "0.9",
          }}
        >
          <SaveProgress room={this.state.room} />
          <CloseButton room={this.state.room} />
        </Row>
        {this.showChat()}
        <Snackbar
          anchorOrigin={{ vertical: "top", horizontal: "center" }}
          open={this.state.showMessage}
          autoHideDuration={2000}
          onClose={() => {
            this.setState({ showMessage: false });
          }}
        >
          <SnackbarContent
            style={{
              backgroundColor: "green",
              fontSize: "3rem",
            }}
            message={this.state.message}
          ></SnackbarContent>
        </Snackbar>
      </div>
    );
  }
}

export default withRouter(FullReadingRoom);


### FullVisualizer.js
import React, { useEffect } from "react";
import DonationButton from "../donate/DonationButton";


export default (props) => {

  const { progress } = props

  useEffect(() => {
    window.scrollTo(0,document.body.offsetHeight*progress)    
  }, [progress])

  return (
    <div>
      <div id="visualizer__content">
        <TextReading 
          text={props.content}
        />        
        <div id="end-block"></div>
      </div>
      <div id="hide-text"></div>
      <DonationButton />
      <div id="hide-end-block"></div>
    </div>
  );
};

function TextReading(props) {
  return (
    <span
      id="nextChar"
      style={{ whiteSpace: "pre-wrap" }}
      className="magic-text"       
    >
      {props.text}
    </span>
  );
}


### Reader.js
import React, { useEffect } from "react";
import { Helmet } from "react-helmet";
import Visualizer from "./Visualizer";
import Controls from "./controls/Controls";
import { useLocalCommands } from "./controls/Commands";

export const READER_STATUS = {
  PAUSED: "paused",
  RUNNING: "running",
};
/**
 *
 * @param {string} content content of reader
 * @param {string} title title of book
 * @param {int} index set index to see the text until this index
 * @param {string} id roomId or myBookId.
 * @param {function} commands hook of commands to execute the commands (remote ones from now)
 * @param {function} onFinished function that is triggered when the reading is finished
 */
export default function Reader(props) {
  const {
    content,
    index,
    title,
    id,
    timeInterval,
    status,
    onFinished,
    room,
    showControls,
    stopIndex,
  } = props;
  // console.log("timeInterval:" + props.timeInterval);
  //  this variable get a hook that store functions to play, pause and do all commands
  //  of the reader
  let commands = null;

  if (props.commands) {
    commands = props.commands(
      content.length,
      id,
      timeInterval,
      status,
      onFinished
    );
  } else {
    console.log("useLocalCommands");
    commands = useLocalCommands(
      content.length,
      id,
      timeInterval,
      status,
      stopIndex,
      onFinished
    );
  }

  function showControlsReader() {
    if (showControls) {
      return (
        <Controls
          id={id}
          title={title}
          length={content.length}
          currentIndex={commands.currentIndex}
          timeInterval={timeInterval}
          room={room}
          commands={commands}
        />
      );
    } else {
      return <></>;
    }
  }

  /* When the component receive a new index, the componet set the new
  index in command to update the index in the reader.*/
  try {
    useEffect(() => {
      if (
        (room && room.participants.length > 1) ||
        index > commands.currentIndex ||
        (room && room.state !== READER_STATUS.RUNNING)
      ) {
        commands.setCurrentIndex(index);
      }
    }, [index]);
  } catch (e) {
    // the exception happens when participants changes
    location.reload();
  }

  /* When component receives a new timeInterval, the component set the new
  timeInterval in command to update the speed of the reader */
  useEffect(() => {
    commands.setTimeInterval(timeInterval);
  }, [timeInterval]);

  return (
    <>
      {/* This component change the title of the page */}
      <Helmet>
        <meta charSet="utf-8" />
        <title>{title + " - La Librería Mágica"}</title>
      </Helmet>

      {/* the place where words appears */}
      <Visualizer
        content={content}
        currentIndex={commands.currentIndex}
        status={status}
        showStars={false}
      />

      {/* controls of play, pause and the title and time left */}
      {showControlsReader()}
    </>
  );
}


### ReadingBook.js
import React, { useState, useEffect } from "react";
import { Tracker } from "meteor/tracker";
import { withRouter } from "react-router-dom";
import { BOOKS, Books } from "../../api/books";
import { ContentBooks } from "../../api/contentBooks";
import Reader from "./Reader";
import { useAnalytics } from "../../analytics/Analytics";
import { Commons } from "../../api/commons";
import { goDown } from "./CommonsReader";
import { Constants } from "../../constants";
import Row from "../commons/Row";
import FreeRegistration from "./roomButtons/FreeRegistration";
import LocalIndex from "../localStorage/LocalIndex";
import { CircularProgress } from "@material-ui/core";
import Loading from "../commons/Loading";

function ReadingBook(props) {
  const [id, setId] = useState(props.match.params.id);
  const [book, setBook] = useState(null);
  const [content, setContent] = useState("");
  const [currentIndex, setCurrentIndex] = useState(10);
  const {startIndex,stopIndex} = props.match.params
  const { analytics, cookie } = useAnalytics();

  useEffect(() => {
    console.log("reading book:" + !!analytics);
    console.log(cookie);
    analytics && analytics.page();
  }, [cookie]);

  contentInit = (book)=>{

    // get content
    const _content = ContentBooks.findOne({
      _id: book.contentId,
    });

    // if content has an url
    if (_content.sharedUrl) {
      
      setContent("Cargando...");

      // load content from the url
      Commons.getTextFromUrl(_content.sharedUrl, (text) => {
        setContent(text);
        goDown();
      });
    
    // content has not url
    } else {

      // load content directly
      setContent(_content.content);
      goDown();
    }

  }


  bookInit = () => {

     // get the book
     const book = Books.findOne({ _id: id });

     // set book in react component
     setBook(book);

     // contentInit
     contentInit(book)
     
  }
  
 
  currentIndexInit = ()=> {

    // if url has startIndex param
    if (startIndex) {
      setCurrentIndex(parseInt(startIndex));
    
    // if url has not startIndex param
    } else {            

      // get current index from LocalStorage
      let _currentIndex = LocalIndex().getLocaIndex(book._id);

      // if LocalStorage has index saved
      if (_currentIndex) {
        _currentIndex = parseInt(_currentIndex);
        setCurrentIndex(_currentIndex);
      }
    }
  }


  useEffect(() => {  

    const handleBook = Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOK_BY_ID_WITH_CONTENT, id);

    let trackerBook = Tracker.autorun(() => {
      
      if (handleBook.ready()) {

        bookInit()                  
        
        currentIndexInit()
        
      }
    });
    return () => {
      initState();
      trackerBook.stop();
    };
  }, []);

  function initState() {
    setId(props.match.params.id);
    setBook(null);
    setContent("");
    setCurrentIndex(10);
  }

  if (book === null) {
    return <Loading style={{textAlign:"center", marginTop:"5rem"}} />;      
  }
  return (
    <div>
      <Reader
        id={id}
        title={book.title}
        content={content}
        index={currentIndex}
        stopIndex={stopIndex}
        timeInterval={Constants.READING.READING_TIME_INTERVAL}
        showControls={true}
      />
      <Row
           style={{
            position: "fixed",
            right: "5%",
            top: "5vh",
            zIndex: "1000",
            opacity: "0.7"            
          }}
        >
          <FreeRegistration bookId={book._id} />
        </Row>
    </div>
  );
}

export default withRouter(ReadingBook);


### ReadingDocument.js
import React, { useState, useRef } from "react";
import {
  Button,
  Dialog,
  DialogContent,
  TextareaAutosize,
  DialogTitle,
  DialogActions,
  Fab,
} from "@material-ui/core";
import DescriptionIcon from "@material-ui/icons/Description";
import Reader from "./Reader";
import { Constants } from "../../constants";
import { openSimpleDialog } from "../commons/SimpleDialog";

export default () => {
  const [content, setContent] = useState("La Librería mágica");
  const [showDialog, setShowDialog] = useState(false);
  const [index, setIndex] = useState(10);
  const contentTextAreaRef = useRef("");    

  function resetIndex() {
    setIndex(0);
    // patch fixe to reset index
    setTimeout(() => {
      setIndex(10);
    }, 100);
  }

  return (
    <>
      <Dialog
        open={showDialog}
        onClose={() => {
          setShowDialog(false);
        }}
      >
        <DialogTitle>Introduzca el texto que desea leer</DialogTitle>
        <DialogContent>
          <TextareaAutosize
            ref={contentTextAreaRef}
            rowsMin={3}
            style={{ height: "30vh", width: "50vw" }}
          ></TextareaAutosize>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setContent(contentTextAreaRef.current.value);
              setShowDialog(false);
              resetIndex();
            }}
            color="primary"
          >
            Aceptar
          </Button>
          <Button
            onClick={() => {
              setShowDialog(false);
            }}
            color="secondary"
          >
            Cancelar
          </Button>
        </DialogActions>
      </Dialog>
      <div
        style={{
          position: "fixed",
          bottom: "22vh",
          left: "2vw",
          opacity: "0.5",
          zIndex: "3",
          flex: "1",
        }}
      >
        <Fab
          onClick={() => {
            if(!navigator.clipboard.readText){
              openSimpleDialog("El navegador no soporta el clipboard. Utiliza la otra opción para insertar el texto.", "Opción no válida")
              return;
            }
            navigator.clipboard
              .readText()
              .then((clipText) => setContent(clipText));
            resetIndex();
          }}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
          >
            <path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z" />
          </svg>
        </Fab>
        <Fab onClick={() => setShowDialog(true)}>
          <DescriptionIcon style={{ fontSize: "2.5rem" }} />
        </Fab>
      </div>

      <Reader
        title="Documento"
        content={content}
        index={index}
        timeInterval={Constants.READING.READING_TIME_INTERVAL}
        showControls={true}
      />
    </>
  );
};


### ReadingMode.js
import { Button, Dialog, DialogContent, DialogContentText, DialogTitle } from '@material-ui/core'
import React, { useState } from 'react'
import Column from '../commons/Column'

export default ({textButton, onClickRead, onClickTraditional})=>{

    const [open, setOpen] = useState(false)

    function handleClose(){
        setOpen(false)
    }
    function getTextButton(){
        if(textButton) return textButton
        else return "Comenzar a Leer"
    }
    return <>
        <Button id="start_reading" onClick={()=>{                            
                setOpen(true)
        }} 
        variant="contained" style={{margin:"0.5rem",backgroundColor:"#F3F330"}}>{getTextButton()}</Button>                
    
        <Dialog open={open} onClose={handleClose}>
            <DialogTitle style={{textAlign:"center"}}>Elige Modo de lectura</DialogTitle>
            <DialogContent>
                <Column>                                        
                    <div style={{textAlign:"center", marginBottom:"1rem"}}>
                        <div>Para una mejor concentración (remondendación):</div>                    
                        <Button color="primary" onClick={onClickRead} variant="contained">Lectura Mágica</Button>
                    </div>
                    <div style={{textAlign:"center", marginBottom:"1rem"}}>
                        <div>Si lees bien en libros físicos (remondendación):</div>                    
                        <Button onClick={onClickTraditional} color="primary" variant="contained">Lectura Tradicional</Button>
                    </div>
                </Column>
            </DialogContent>
        </Dialog>

    </>
}

### ReadingRoom.js
import React from "react";
import { Tracker } from "meteor/tracker";
import { withRouter } from "react-router-dom";
import { Rooms, ROOMS } from "../../api/rooms";
import { ContentBooks } from "../../api/contentBooks";
import Emoji from "./roomButtons/Emoji";
import Reader, { READER_STATUS } from "./Reader";
import { useRemoteCommands } from "./controls/CommandsRemote";
import { goDown } from "./CommonsReader";
import UserStatusModal from "./roomButtons/UserStatusModal";
import { Commons } from "../../api/commons";
import FormWords from "./roomButtons/FormWords";
import CommentsOption from "./roomButtons/CommentsOption";
import Row from "../commons/Row";
import { Comments, COMMENTS } from "../../api/comments";
import Chat from "./chat/Chat";
import { useLocalRoomCommands } from "./controls/CommandsLocalRoom";
import { Snackbar, SnackbarContent } from "@material-ui/core";
import CloseButton from "./roomButtons/CloseButton";
import { openSimpleDialog } from "../commons/SimpleDialog";
import FabAmigosConnected from "../users/FabAmigosConnected";
import Loading from "../commons/Loading";
import FullScreenButton from "./roomButtons/FullScreenButton";

class ReadingRoom extends React.Component {
  constructor(props) {
    super(props);
    const showControlsText = this.props.match.params.showControls;
    this.state = {
      id: this.props.match.params.id,
      showControls: showControlsText ? JSON.parse(showControlsText) : true,
      room: null,
      comments: [],
      timeInterval: -1,
      content: "",
      currentIndex: null,
      showUsers: true,
      showWords: false,
      showMessage: false,
      allReady: false,
      anchorEl: null,
      message: "",
      fullScreen: false,
      handleComments: {},
      isAuthenticated: !!Meteor.user(),
    };
  }
  pauseReading() {
    if (!this.state.room) return;
    Meteor.call(ROOMS.METHOD_NAMES.PAUSE_READING, this.state.room._id);
  }
  componentDidMount() {
    const handleRooms = Meteor.subscribe(
      ROOMS.PUBLISH_NAME.BY_ID_WITH_CONTENT,
      this.state.id
    );

    const handleComments = Meteor.subscribe(
      COMMENTS.PUBLISH_NAME.COMMENTS,
      this.state.id
    );

    if (this.state.isAuthenticated) {
      this.setUserStatus(ROOMS.USER_STATUS.OFF.value);
    }
    this.trackerRooms = Tracker.autorun(() => {
      this.setState({ isAuthenticated: !!Meteor.user() });
      if (handleRooms.ready()) {
        const room = Rooms.findOne(
          { _id: this.state.id },
          { fields: { currentIndex: 0, messages: 0 } }
        );
        if (_.isEqual(room, this.state.room)) {
          return;
        }
        this.setState({ room });
        this.setState({ timeInterval: room.speedReading });
        if (!this.state.content) {
          const content = ContentBooks.findOne({
            _id: room.contentId,
          });
          if (content && content.sharedUrl) {
            this.setState({ content: "Cargando.." });
            Commons.getTextFromUrl(content.sharedUrl, (text) => {
              this.setState({ content: text });
              goDown();
            });
          } else if (content) {
            this.setState({ content: content.content });
            goDown();
          }
        }
        if (
          !this.allParticipantIsReady(room.participants) &&
          !room.isOwnControl
        ) {
          this.setState({ showUsers: true, allReady: false });
          this.pauseReading();
        } else {
          if (room.state === READER_STATUS.RUNNING) {
            this.setState({ showUsers: false, allReady: true });
          } else {
            this.setState({ allReady: true });
          }
        }
      }
    });

    this.trackerIndex = Tracker.autorun(() => {
      if (handleRooms.ready()) {
        const room = Rooms.findOne(
          { _id: this.state.id },
          { fields: { currentIndex: 1 } }
        );
        if (this.state.currentIndex === null) {
          this.setState({ currentIndex: room.currentIndex });
          goDown();
        } else {
          this.setState({ currentIndex: room.currentIndex });
        }
        if (!this.state.allReady) {
          this.pauseReading();
          this.setState({ showUsers: true });
        }
        if (this.state.currentIndex > this.state.room.length) {
          this.pauseReading();
        }
      }
    });

    this.trackerComments = Tracker.autorun(() => {
      if (handleComments.ready()) {
        const comments = Comments.find({ roomId: this.state.id })
          .fetch()
          .reverse();
        this.setState({
          comments,
        });
      }
    });
  }

  componentWillUnmount() {
    this.trackerRooms.stop();
    this.trackerIndex.stop();
    this.trackerComments.stop();
    this.pauseReading();
    this.setUserStatus("off");
  }

  setUserStatus(status) {
    Meteor.call(
      ROOMS.METHOD_NAMES.SET_USERSTATUS,
      this.state.id,
      status,
      (err, res) => {
        err && console.log(err) && openSimpleDialog(err);
        res && console.log(res);
      }
    );
  }

  allParticipantIsReady(participants) {
    let result = true;
    participants.forEach((p) => {
      if (p.status !== "on") {
        result = false;
      }
    });
    return result;
  }

  showMessage(message) {
    console.log(message);
    if (Meteor.userId() != message.userId) {
      this.setState({ message: message.text });
      this.setState({ showMessage: true });
    }
  }
  showChat() {
    if (this.state.room.readersGroupId) {
      return (
        <Chat
          style={{
            position: "fixed",
            top: "2vh",
            right: "2vw",
            opacity: "0.7",
            zIndex: 10000,
          }}
          roomId={this.state.room.readersGroupId}
          readingId={this.state.room.readingId}
          currentIndex={this.state.currentIndex}
          antiSpoiler={true}
          // onChatCreated={()=>{
          //   openSimpleDialog("Cuando escribes desde el Chat de esta sala, solo podrán ver tus mensaje las personas que ya hayan llegado a la página por la que vas del libro para evitar que lean algo indebido. ¡Así que escribe libremente sobre el tema que estés leyendo sin miedo! \n\nSi escribes algo que no es sobre la lectura, sal de esta sala y escribe desde el grupo de lectura para que todos te puedan leer.", "AntiSpoiler Activado")
          // }}
        />
      );
    }
    if (this.state.room.participants.length == 1) return <></>;

    return (
      <Chat
        style={{
          position: "fixed",
          top: "2vh",
          right: "2vw",
          opacity: "0.7",
          zIndex: 10000,
          display: this.state.fullScreen ? "none" : "flex",
        }}
        roomId={this.state.room._id}
      />
    );
  }

  getCommands(room) {
    if (room.participants.length > 1) {
      return useRemoteCommands;
    } else {
      return useLocalRoomCommands;
    }
  }

  showUserStatusModal() {
    if (this.state.isAuthenticated) {
      return (
        <UserStatusModal
          show={this.state.showUsers}
          participants={this.state.room.participants}
          roomId={this.state.id}
          updateShowUser={(show) => {
            // console.log("show:" + show);
            if (show && !this.state.room.isOwnControl) {
              this.setUserStatus("onemoment");
            }
            this.setState({ showUsers: show });
          }}
        />
      );
    } else {
      return <></>;
    }
  }
  getEmojiIdRoom() {
    if (this.state.room) {
      if (this.state.room.readersGroupId) {
        return this.state.room.readersGroupId;
      } else {
        return this.state.room._id;
      }
    } else {
      return 0;
    }
  }
  render() {
    if (this.state.room === null) {
      return <Loading style={{ textAlign: "center", marginTop: "5rem" }} />;
    }
    return (
      <>
        <FullScreenButton
          onClick={() => {
            this.setState({ fullScreen: !this.state.fullScreen });
          }}
        />
        <Reader
          content={this.state.content}
          room={this.state.room}
          index={this.state.currentIndex}
          title={this.state.room.title}
          id={this.state.room._id}
          participants={this.state.room.participants}
          timeInterval={this.state.timeInterval}
          commands={this.getCommands(this.state.room)}
          status={this.state.room.state}
          showControls={
            !this.state.fullScreen &&
            this.state.showControls &&
            (!this.state.room.isOwnControl ||
              this.state.room.ownerId === Meteor.userId())
          }
        />
        <Row
          style={{
            position: "fixed",
            top: "5vh",
            left: "2vw",
            display: this.state.fullScreen ? "none" : "flex",
          }}
        >
          <Emoji
            id={this.getEmojiIdRoom()}
            currentIndex={this.state.currentIndex}
          />
          <CommentsOption
            id={this.state.id}
            currentIndex={this.state.currentIndex}
            comments={this.state.comments}
            roomState={this.state.room.state}
            bookId={this.state.room.bookId}
            content={this.state.content}
            room={this.state.room}
          />
          <FabAmigosConnected style={{ color: "white" }} />
        </Row>
        <Row
          style={{
            position: "fixed",
            bottom: "16vh",
            left: "2vw",
            opacity: "0.5",
            display: this.state.fullScreen ? "none" : "flex",
          }}
        >
          {this.showUserStatusModal()}
          <FormWords
            roomId={this.state.id}
            show={this.state.showWords}
            text={window.getSelection().toString()}
            currentIndex={this.state.currentIndex}
            updateShowUser={(show) => {
              console.log("show:" + show);
              this.setState({ showWords: show });
            }}
          />
          <CloseButton room={this.state.room} />
        </Row>
        {this.showChat()}
        {/* <span
          id="message"
          style={{
            position: "fixed",
            left: "0",
            right: "0",
            top: "29vh",
            fontSize: "3rem",

            opacity: "0.8",
            zIndex: "10000",
            display: "flex",
            justifyContent: "center",
          }}
        >
          <span style={{ backgroundColor: "white" }}>{this.state.message}</span>
        </span> */}
        <Snackbar
          anchorOrigin={{ vertical: "top", horizontal: "center" }}
          open={this.state.showMessage}
          autoHideDuration={2000}
          onClose={() => {
            this.setState({ showMessage: false });
          }}
        >
          <SnackbarContent
            style={{
              backgroundColor: "green",
              fontSize: "3rem",
            }}
            message={this.state.message}
          ></SnackbarContent>
        </Snackbar>
      </>
    );
  }
}

export default withRouter(ReadingRoom);


### Visualizer.js
import React, { useEffect } from "react";
import { Constants } from "../../constants";
import { goDown } from "./CommonsReader";
import StarryBackground from "./backgrounds/StarryBackground";
import LavaBackground from "./backgrounds/LavaBackground";

export default (props) => {
  const { currentIndex, showStars } = props;

  function startIndex(index) {
    let startIndex = index - 5000;

    if (startIndex < 0) {
      return 0;
    }
    if (props.content.length < startIndex) {
      return 0;
    }
    return startIndex;
  }

  function startEndIndex(index) {
    return (
      Math.trunc(index / Constants.READING.SCREEN_SIZE) *
      Constants.READING.SCREEN_SIZE
    );
  }

  useEffect(() => {
    if (currentIndex % 10 === 0) {
      goDown("visualizer");
    }
  }, [currentIndex]);

  return (
    <div>
      <div id="visualizer__content">
        <StarryBackground showStars={showStars} />
        <TextReading
          text={props.content.substring(
            startIndex(currentIndex),
            startEndIndex(currentIndex)
          )}
        />
        <TextReading
          text={props.content.substring(
            startEndIndex(currentIndex),
            currentIndex
          )}
        />
        <div id="end-block"></div>
      </div>
      <div id="hide-text"></div>
      <div id="hide-end-block"></div>
    </div>
  );
};

function TextReading(props) {
  return (
    <span
      id="nextChar"
      style={{ whiteSpace: "pre-wrap" }}
      className="magic-text"
    >
      {props.text}
    </span>
  );
}


### LavaBackground.js
import React, { useEffect, useRef } from "react";

function LavaBackground({ show = true }) {
  const canvasRef = useRef(null);
  const embers = [];
  const splashes = [];
  const maxSplashes = 5;

  useEffect(() => {
    if (!show) return;

    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");

    function resetEmber(ember) {
      ember.x = Math.random() * canvas.width;
      ember.y = canvas.height;
      ember.size = Math.random() * 3 + 1;
      ember.speed = Math.random() * 2 + 1;
      ember.drift = Math.random() * 1.5 - 0.75;
      ember.opacity = Math.random() * 0.5 + 0.5;
      ember.rotation = Math.random() * 360;
      ember.rotationSpeed = Math.random() * 5 - 2.5;
      const colors = ["#FF4500", "#FFD700", "#FF6347", "#B22222"];
      ember.color = colors[Math.floor(Math.random() * colors.length)];
    }

    function resetSplash(splash) {
      splash.x = Math.random() * canvas.width;
      splash.y = canvas.height;
      splash.size = Math.random() * 10 + 5;
      splash.speed = Math.random() * 4 + 4;
      splash.drift = Math.random() * 4 - 2;
      splash.opacity = 1;
      const colors = ["#FFA07A", "#FF4500"];
      splash.color = colors[Math.floor(Math.random() * colors.length)];
    }

    function createEmber() {
      const ember = {};
      resetEmber(ember);
      embers.push(ember);
    }

    function createSplash() {
      if (splashes.length < maxSplashes && Math.random() > 0.98) {
        const splash = {};
        resetSplash(splash);
        splashes.push(splash);
      }
    }

    for (let i = 0; i < 150; i++) {
      createEmber();
    }

    function animate() {
      context.fillStyle = "#000000";
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Fondo con gradiente de luz de la lava con oscilación
      const gradient = context.createRadialGradient(
        canvas.width / 2,
        canvas.height,
        0,
        canvas.width / 2,
        canvas.height,
        canvas.height / 2 + Math.sin(Date.now() * 0.001) * 20
      );
      gradient.addColorStop(0, "rgba(255, 69, 0, 1)");
      gradient.addColorStop(1, "#000000");
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);

      createSplash();

      splashes.forEach((splash, index) => {
        splash.y -= splash.speed;
        splash.x += splash.drift;
        splash.opacity -= 0.01;

        if (splash.y < 0 || splash.opacity <= 0) {
          splashes.splice(index, 1);
          return;
        }

        context.fillStyle = splash.color;
        context.globalAlpha = splash.opacity;
        context.beginPath();
        context.arc(splash.x, splash.y, splash.size, 0, 2 * Math.PI, false);
        context.fill();
      });

      embers.forEach((ember) => {
        ember.y -= ember.speed;
        ember.x += ember.drift;
        ember.opacity *= 0.995; // slowly fade out
        ember.rotation += ember.rotationSpeed;

        if (ember.y < 0 || ember.opacity <= 0) {
          resetEmber(ember);
        }

        context.fillStyle = ember.color;
        context.globalAlpha = ember.opacity;
        context.save();
        context.translate(ember.x, ember.y);
        context.rotate((ember.rotation * Math.PI) / 180);
        context.beginPath();
        context.arc(0, 0, ember.size, 0, 2 * Math.PI, false);
        context.fill();
        context.restore();
      });

      context.globalAlpha = 1; // Reset opacity

      requestAnimationFrame(animate);
    }

    animate();
  }, [show]);

  return (
    <>
      <canvas
        ref={canvasRef}
        style={{ position: "fixed", top: 0, left: 0, zIndex: -1 }}
        width={window.innerWidth}
        height={window.innerHeight}
      ></canvas>
    </>
  );
}

export default LavaBackground;


### StarryBackground.js
import React, { useEffect, useRef } from "react";

function StarryBackground(props) {
  const canvasRef = useRef(null);
  const { showStars = true, showShootingStars = true } = props; // Valor predeterminado en true si no se pasa
  const shootingStars = [];

  useEffect(() => {
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");
    const stars = [];

    function createStar() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const size = Math.random() * 3;
      const speed = Math.random() * 0.5;
      const colors = ["#FFF", "#FFFFCC"];
      const color = colors[Math.floor(Math.random() * colors.length)];
      stars.push({ x, y, size, speed, color });
    }

    function createShootingStar() {
      const x = Math.random() * canvas.width;
      const y = 0;
      const length = (30 + Math.random() * 70) / 2; // Dividir por 2 para reducir la longitud a la mitad
      const speed = 4 + Math.random() * 3;
      const angle = Math.random() * 2 * Math.PI; // ángulo completo (360 grados)
      const colors = ["#FFFFFF", "#FFFFCC"];
      const color = colors[Math.floor(Math.random() * colors.length)];
      shootingStars.push({ x, y, length, speed, angle, color });
    }

    for (let i = 0; i < 150; i++) {
      createStar();
    }

    if (showShootingStars) {
      setInterval(createShootingStar, 10000); // Solo crea estrellas fugaces si showShootingStars es verdadero
    }

    function animate() {
      context.fillStyle = "#000";
      context.fillRect(0, 0, canvas.width, canvas.height);

      stars.forEach((star) => {
        star.y += star.speed;
        if (star.y > canvas.height) {
          star.y = 0;
        }
        context.fillStyle = star.color;
        context.fillRect(star.x, star.y, star.size, star.size);
      });

      shootingStars.forEach((star, index) => {
        star.x += star.speed * Math.cos(star.angle);
        star.y += star.speed * Math.sin(star.angle);

        if (
          star.y > canvas.height ||
          star.y < 0 ||
          star.x > canvas.width ||
          star.x < 0
        ) {
          shootingStars.splice(index, 1);
          return;
        }

        const gradient = context.createLinearGradient(
          star.x,
          star.y,
          star.x - star.length * Math.cos(star.angle),
          star.y - star.length * Math.sin(star.angle)
        );
        gradient.addColorStop(0, star.color);
        gradient.addColorStop(1, "transparent");
        context.strokeStyle = gradient;
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(star.x, star.y);
        context.lineTo(
          star.x - star.length * Math.cos(star.angle),
          star.y - star.length * Math.sin(star.angle)
        );
        context.stroke();

        // Brillo en la punta
        const brightnessRadius = Math.random() * 2 + 1; // Radio del círculo entre 1 y 3
        context.beginPath();
        context.arc(star.x, star.y, brightnessRadius, 0, 2 * Math.PI, false);
        context.fillStyle = star.color;
        context.globalAlpha = 0.8; // Un poco transparente
        context.fill();
        context.globalAlpha = 1.0; // Restaurar la opacidad
      });

      requestAnimationFrame(animate);
    }

    animate();
  }, [showShootingStars]);

  if (showStars) {
    return <></>;
  }
  return (
    <canvas
      ref={canvasRef}
      style={{ position: "fixed", top: 0, left: 0, zIndex: -1 }}
      width={window.innerWidth}
      height={window.innerHeight}
    ></canvas>
  );
}

export default StarryBackground;


### Chat.js
import React, { useRef, useEffect, useState } from "react";
import SendIcon from "@material-ui/icons/Send";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import ExpandLessIcon from "@material-ui/icons/ExpandLess";
import Row from "../../commons/Row";
import { useTracker } from 'meteor/react-meteor-data'
import { Messages, MESSAGES } from "../../../api/messages";
import Message from "./Message";

export function sendMessage(message,roomId,currentIndex,readingId) {
  Meteor.call(MESSAGES.METHOD_NAMES.SEND, roomId, currentIndex, message, readingId,(err, res) => {
    err && openSimpleDialog(err);
    res && console.log("messages.send:" + res);
  });  
}

export default function Chat(props){
  const { roomId, currentIndex, readingId, antiSpoiler, onChatCreated, onInputFocus } = props
  const { messages } = useTracker(()=>{
    Meteor.subscribe(MESSAGES.PUBLISH_NAMES.BY_ROOM_ID, roomId);
    const messages = Messages.find(
      {
        roomId: roomId,
      },
      {sort:{date:-1},limit: 100 }
    ).fetch().reverse();    
    return { messages }
  });

  const [expanded, setExpanded] = useState(false);
  const chatMessage = useRef("");
  let style = {
    display: "flex",
    flexDirection: "column",
    backgroundColor: "white",
    width: "25vw",
    height: "20vh",
    paddingLeft: "2px",
    overflowY: "auto",
    
    ...props.style,
  };
  if (expanded) {
    style.height = "70vh";
    style.width = "80vw";
    style.opacity = "1.0";
  }
  function goDownChat() {
    console.log("goDownChat");
    const chatView = document.getElementById("chatView");
    chatView.scrollTop = chatView.scrollHeight - chatView.clientHeight;
  }

  useEffect(() => {
    goDownChat();
  }, [messages]);
  
  useEffect(() => {
    if(onChatCreated) onChatCreated()
  }, [])
  function showInput() {
    if (Boolean(Meteor.user())) {
      return (
        <input
          placeholder="Escribe aquí..."
          onFocus={()=>{
            if(onInputFocus)onInputFocus()
            setExpanded(true)
          }}
          onBlur={()=>{setExpanded(false)}}
          style={{ width: "100%" }}          
          ref={chatMessage}
        />
      );
    } else {
      return (
        <div>
          <a href="/signup">Regístrate</a> para poder escribir.
        </div>
      );
    }
  }

  return (
    <div style={style}>
      <div id="chatView" style={{overflowY: "scroll",height:"100%" }}>
        <div style={{ height: "100%" }}>
          {messages.map((message) => {
            return <Message key={message._id} {...message} readingIdUser={readingId} currentIndexUser={currentIndex} antiSpoiler={antiSpoiler} />;
          })}
        </div>
      </div>
      <div style={{  width: "100%" }}>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            if(chatMessage.current.value.trim()!==""){
              sendMessage(chatMessage.current.value,roomId, currentIndex, readingId);
              chatMessage.current.value = "";
            }
          }}
        >
          <Row style={{position:"relative",bottom:"0"}}>
            {showInput()}
            <button><SendIcon style={{ opacity: "0.7" }} /></button>
            <button
              style={{ padding: "0" }}
              onClick={(e) => {
                setExpanded((value) => {
                  return !value;
                });
                setTimeout(() => {
                  goDownChat();
                }, 100);
              }}
            >
              {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
            </button>
          </Row>
        </form>
      </div>
    </div>
  );
};



### FullChat.js
import React, { useEffect, useState, useRef } from 'react'
import { Meteor } from 'meteor/meteor'
import SendIcon from "@material-ui/icons/Send";
import { Messages, MESSAGES } from '../../../api/messages'
import { useTracker } from 'meteor/react-meteor-data'
import { Button } from '@material-ui/core'
import { browserHistory } from '../../../routes/routes'
import Message from './Message';
import Loading from '../../commons/Loading';


export default function FullChat(props){
    const { roomId, textButton, currentIndex, readingId, antiSpoiler, viewOnly } = props  
    const [expanded, setExpanded] = useState(false)  
    const { isLogged } = useTracker(()=>{        
        return {isLogged:!!Meteor.user()}
    })    
    let _textButton = textButton?textButton:"Chatear";    
    let _roomId = roomId?roomId:"1";

    function goDownChat() {        
        const chatView = document.getElementById("chatView");
        if(chatView){
            chatView.scrollTop = chatView.scrollHeight - chatView.clientHeight;
        }
    }
    function sendMessage(message) {
        Meteor.call(MESSAGES.METHOD_NAMES.SEND, _roomId, -1, message, (err, res) => {
          err && alert(err);
          res && console.log(MESSAGES.METHOD_NAMES.SEND + res);
        });        
    }
    
    const {messages,isLoading} = useTracker(()=>{
        const subsChat = Meteor.subscribe(MESSAGES.PUBLISH_NAMES.BY_ROOM_ID,_roomId)        
        const messages = Messages.find({roomId:_roomId},{ sort: { date: -1 }, limit: 100}).fetch().reverse()        
        goDownChat()
        return { 
            messages,
            isLoading:!subsChat.ready() 
        }
    })
    useEffect(() => {
        goDownChat();
        
    }, [messages])
    if(isLoading){
        return <Loading />
    }
    if(!expanded){        
        return (
        <>
            <div className="container" style={{display:"flex",flexDirection:"row",height:"50px",backgroundColor:"white",marginBottom:"0.5rem",width:"100%",borderRadius:"0.4rem"}}>
                <ChatView messages={messages} antiSpoiler={antiSpoiler} readingId={readingId} currentIndex={currentIndex} />  
                <div style={{width:"30%"}}>
                   <Button variant="contained" color="primary" onClick={()=>{setExpanded(true)}} style={{marginTop:"1rem"}}>{_textButton}</Button>
                </div>          
            </div>
        </>
        ) 
    }
    return (
        <>
            <div style={{display:"flex",flexDirection:"column"}}>
                <div className="container" style={{display:"flex",flexDirection:"row",height:"200px",backgroundColor:"white",marginBottom:"0.5rem",width:"100%",borderRadius:"0.4rem"}}>
                    <ChatView messages={messages} antiSpoiler={antiSpoiler} readingId={readingId} currentIndex={currentIndex}/>  
                    <div style={{width:"30%", display:"flex",flexDirection:"column-reverse"}}>
                         <Button variant="contained" color="primary" onClick={()=>{setExpanded(false)}} style={{margin:"1rem"}}>Cerrar</Button>
                     </div>   
                </div>
                <MessageInput isLogged={isLogged} viewOnly={viewOnly} onSubmit={(message)=>{
                    if(message.trim()!==""){
                        sendMessage(message);
                    }
                }} />
            </div>
        </>
    ) 
}

function MessageInput(props){
    const { onSubmit, isLogged, viewOnly } = props
    const chatMessage = useRef("")
    function submitMessage(){
        onSubmit(chatMessage.current.value) 
        chatMessage.current.value = "";  
    }
    function showInput(){
        if(viewOnly){
            return <></>
        }
        if(isLogged){
            return <>
                    <input style={{width:"100%" ,borderRadius:"0.4rem"}} ref={chatMessage} type="text" placeholder="Escribe aquí.."/>  
                        <Button onClick={()=>{
                            submitMessage()
                        }} style={{height:"100%"}} variant="contained" ><SendIcon style={{ }} />
                        </Button>
                    </>
        }else{
            return <div style={{textAlign:"center",width:"100%"}}>
                        <Button onClick={()=>{
                            browserHistory.push("/signup")
                        }} style={{marginBottom:"0.5rem"}} variant="contained">
                            Regístrate y empieza a Chatear
                        </Button>
                    </div>
        }
    }
    return <>
        <form style={{width:"100%"}} onSubmit={(e)=>{
            e.preventDefault()
            submitMessage()
        }}>
            <div style={{verticalAlign:"center",display:"flex",flexDirection:"row",width:"100%"}}>
                {showInput()}
            </div>
        </form>
    </>

}
function ChatView(props){
    const { messages, antiSpoiler, currentIndex, readingId } = props
    return <>
        <div id="chatView" style={{overflowY: "scroll",height:"100%",width:"70%"}}>
            <div style={{ height: "100%" }}>
            {messages.map((message) => {
                return <Message key={message._id} {...message} marginLeftOn={true}
                    antiSpoiler={antiSpoiler} currentIndexUser={currentIndex} readingIdUser={readingId} />;
            })}
            </div>    
        </div>
        
    </>
}

### Message.js
import React from 'react'
import { calculateNumberOfPages } from '../controls/Controls';

export default function Message(props) {
    const { userId, text, username, currentIndex, readingId, readingIdUser, currentIndexUser, antiSpoiler, marginLeftOn } = props;    
    let style = {textAlign:"left"};
    if(marginLeftOn){
        style.marginLeft = "0.5rem"
    }
    function showPage(currentIndex){
      if(currentIndex && currentIndex>0){
          return <span>(Pág {calculateNumberOfPages(currentIndex)})</span>
      }
  }
    if (Meteor.user() && Meteor.user()._id === userId) {
      style.opacity = "0.5";
    } else {
      style.opacity = "0.9";
    }  
    if(antiSpoiler && currentIndexUser<currentIndex){
      if(readingId === readingIdUser){
        return <div className="message_antiSpoiler" style={style} ><span style={{color:"blue"}}>{username}</span>: <span style={{color:"darkred"}}>// verás este mensaje cuando llegues a la página {calculateNumberOfPages(currentIndex)}</span></div>
      }
    }
    return <div style={style}><span style={{color:"blue"}}>{username}</span>: {text} {showPage(currentIndex)}</div>;
}

### Commands.js
import { useState, useRef } from "react";
import { Constants } from "../../../constants";
import { goDown } from "../CommonsReader";
import { READER_STATUS } from "../Reader";
import LocalIndex from "../../localStorage/LocalIndex";
/**
 * Commands execute the commands to reading
 */
export function useLocalCommands(
  length,
  id,
  _timeInterval,
  _status,
  _stopIndex,
  onFinished
) {
  const intervalId = useRef(null);
  const _onFinished = useRef(onFinished);
  const [textSize, setTextSize] = useState(2.75);
  const [currentIndex, setCurrentIndex] = useState(10);
  const [timeInterval, setTimeInterval] = useState(_timeInterval);
  const [nightOn, setNightOn] = useState(false);
  const [status, setStatus] = useState(_status);


  let startReading = () => {
    console.log("localllll: " + timeInterval);
    pauseReading();
    if (currentIndex < length) {
      intervalId.current = setInterval(() => {
        setCurrentIndex((index) => {
          if(_stopIndex && (index===_stopIndex || index > _stopIndex)){
            pauseReading()            
          }
          if (index < length) {
            if (!nightOn && id && index % 40 === 0) {              
              LocalIndex().setLocalIndex(index,id)              
            }
            return index + 1;
          } else {
            // onFinished
            pauseReading();
            if (_onFinished.current) {
              _onFinished.current();
            }
          }
        });
      }, timeInterval);
      setStatus(READER_STATUS.RUNNING);
    }
  };

  let rewind = () => {
    pauseReading();
    intervalId.current = setInterval(() => {
      setCurrentIndex((index) => {
        if (index < length) {
          if (id && index % 40 === 0) {
            LocalIndex().setLocalIndex(index,id)            
          }
          return index - 1;
        } else {
          // onFinished
          pauseReading();
          if (_onFinished.current) {
            _onFinished.current();
          }
        }
      });
    }, Constants.READING.STEP_TIME_INTERVAL);
    setStatus(READER_STATUS.RUNNING);
  };

  let pauseReading = () => {
    console.log("pause:" + intervalId.current);
    clearInterval(intervalId.current);
    setStatus(READER_STATUS.PAUSED);
  };

  let sizeUp = () => {
    console.log("sizeup");
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize + 0.1 + "rem");
    setTextSize(textSize + 0.1);
    goDown("sizeUp");
  };

  let sizeDown = () => {
    console.log("sizeDown");
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize - 0.1 + "rem");
    setTextSize(textSize - 0.1);
    goDown("sizeDown");
  };

  let speedDown = () => {
    console.log("speedDown");
    if (timeInterval <= 10) {
      // Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 1);
      setTimeInterval(timeInterval + 1);
    } else {
      // Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 10);
      setTimeInterval(timeInterval + 10);
    }
    console.log(timeInterval);

    startReading();
  };

  let speedUp = () => {
    console.log("speedUp");
    if (timeInterval === 1) {
      return;
    }
    if (timeInterval <= 10) {
      setTimeInterval(timeInterval - 1);
      // Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -1);
    } else {
      setTimeInterval(timeInterval - 10);
      // Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -10);
    }
    console.log(timeInterval);

    startReading();
  };
  let setNight = function (value) {
    setNightOn(value);
  };
  return {
    currentIndex,
    timeInterval,
    length,
    status,
    startReading,
    pauseReading,
    rewind,
    sizeUp,
    sizeDown,
    speedDown,
    speedUp,
    setCurrentIndex,
    setTimeInterval,
    setNight,
  };
}


### CommandsLocalRoom.js
import { useState, useRef } from "react";
import { Constants } from "../../../constants";
import { goDown } from "../CommonsReader";
import { READER_STATUS } from "../Reader";
import { ROOMS } from "../../../api/rooms";
import { setUserStatus } from "./CommandsRemote";
import LocalIndex from "../../localStorage/LocalIndex";

export function setRoomStatus(roomId, status) {
  Meteor.call(
    ROOMS.METHOD_NAMES.CHANGE_STATUS,
    roomId,
    status,
    (err, result) => {
      err && console.log(err);
      console.log(result);
    }
  );
}
/**
 * Commands execute the commands to reading
 */
export function useLocalRoomCommands(
  length,
  id,
  _timeInterval,
  _status,
  onFinished
) {
  const intervalId = useRef(null);
  const _onFinished = useRef(onFinished);
  const [textSize, setTextSize] = useState(2.75);
  const [currentIndex, setCurrentIndex] = useState(10);
  const [timeInterval, setTimeInterval] = useState(_timeInterval);
  const [nightOn, setNightOn] = useState(false);
  const [status, setStatus] = useState(_status);

  let startReading = () => {
    console.log("localllll: " + timeInterval);
    pauseReading();
    setUserStatus("on", id);
    if (currentIndex < length) {
      setRoomStatus(id, READER_STATUS.RUNNING);
      setStatus(READER_STATUS.RUNNING);
      intervalId.current = setInterval(() => {
        setCurrentIndex((index) => {
          if (index < length) {
            if (!nightOn && id && index % 40 === 0) {
              if (Meteor.user()) {
                Meteor.call(
                  ROOMS.METHOD_NAMES.UPDATE_PROGRESS,
                  id,
                  index / length,
                  index,
                  (err, res) => {
                    err && console.log(err);
                    // show a toast if err
                    console.log(res);
                  }
                );
              }
            }
            return index + 1;
          } else {
            // onFinished
            pauseReading();
            if (_onFinished.current) {
              _onFinished.current();
            }
          }
        });
      }, timeInterval);
    }
  };
  let rewind = () => {
    pauseReading();
    setUserStatus("on", id);
    intervalId.current = setInterval(() => {
      setCurrentIndex((index) => {
        if (index < length) {
          if (id && index % 40 === 0) {
            if (Meteor.user()) {
              // Meteor.call(
              //   ROOMS.METHOD_NAMES.UPDATE_INDEX,
              //   id,
              //   index,
              //   (err, res) => {
              //     err && console.log(err);
              //     // show a toast if err
              //     console.log(res);
              //   }
              // );
            } else {
              console.log("funciona2");
              LocalIndex().setLocalIndex(index, id);
              // localStorage.setItem(id, index);
            }
          }
          return index - 1;
        } else {
          // onFinished
          pauseReading();
          if (_onFinished.current) {
            _onFinished.current();
          }
        }
      });
    }, Constants.READING.STEP_TIME_INTERVAL);
    setRoomStatus(id, READER_STATUS.RUNNING);
    setStatus(READER_STATUS.RUNNING);
  };
  let pauseReading = () => {
    console.log("pause:" + intervalId.current);
    clearInterval(intervalId.current);
    setStatus(READER_STATUS.PAUSED);
    setRoomStatus(id, READER_STATUS.PAUSED);
  };
  let sizeUp = () => {
    console.log("sizeup");
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize + 0.1 + "rem");
    setTextSize(textSize + 0.1);
    goDown("sizeUp");
  };
  let sizeDown = () => {
    console.log("sizeDown");
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize - 0.1 + "rem");
    setTextSize(textSize - 0.1);
    goDown("sizeDown");
  };

  let speedDown = () => {
    console.log("speedDown");
    if (timeInterval <= 10) {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 1);
    } else {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 10);
    }
    console.log(timeInterval);

    startReading();
  };

  let speedUp = () => {
    console.log("speedUp");
    if (timeInterval === 1) {
      return;
    }
    if (timeInterval <= 10) {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -1);
    } else {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -10);
    }
    console.log(timeInterval);

    startReading();
  };
  let setNight = function (value) {
    setNightOn(value);
  };
  let nextPage = () => {
    pauseReading();
    Meteor.call(
      ROOMS.METHOD_NAMES.UPDATE_INDEX,
      id,
      currentIndex + Constants.READING.LETTERS_PER_PAGE
    );
  };
  let backPage = () => {
    pauseReading();
    Meteor.call(
      ROOMS.METHOD_NAMES.UPDATE_INDEX,
      id,
      currentIndex - Constants.READING.LETTERS_PER_PAGE
    );
  };

  let setPaid = (room) => {
    console.log(room);
    Meteor.call(
      ROOMS.METHOD_NAMES.SET_LAST_PAID_INDEX,
      room._id,
      currentIndex,
      (err, res) => {
        err && openSimpleDialog(err, "Error");
        res && console.log(res);
      }
    );
  };

  return {
    currentIndex,
    timeInterval,
    length,
    status,
    startReading,
    pauseReading,
    rewind,
    sizeUp,
    sizeDown,
    speedDown,
    speedUp,
    setCurrentIndex,
    setTimeInterval,
    setNight,
    nextPage,
    backPage,
    setPaid,
  };
}


### CommandsRemote.js
import { useState, useRef } from "react";
import { ROOMS } from "../../../api/rooms";
import { Constants } from "../../../constants";
import { openSimpleDialog } from "../../commons/SimpleDialog";

/**
 * Commands execute the commands to reading
 */
export function setUserStatus(status, id) {
  Meteor.call(ROOMS.METHOD_NAMES.SET_USERSTATUS, id, status, (err, res) => {
    err && openSimpleDialog(err, "Error");
    res && console.log(res);
  });
}
export function useRemoteCommands(length, id, _timeInterval, onFinished) {
  const intervalId = useRef(null);
  const _onFinished = useRef(onFinished);
  const [textSize, setTextSize] = useState(2.75);
  const [currentIndex, setCurrentIndex] = useState(10);
  const [timeInterval, setTimeInterval] = useState(_timeInterval);
  function goDown(message) {
    // console.log("goDown:" + message)
    const endBlock = document.getElementById("end-block");
    endBlock.scrollIntoView({
      behavior: "auto",
      block: "start",
      inline: "nearest",
    });
  }
  let startReading = () => {
    console.log("play");
    pauseReading();
    setUserStatus("on", id);
    Meteor.call(ROOMS.METHOD_NAMES.START_READING, id, timeInterval);
  };
  let pauseReading = () => {
    Meteor.call(ROOMS.METHOD_NAMES.PAUSE_READING, id);
  };
  let sizeUp = () => {
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize + 0.1 + "rem");
    setTextSize(textSize + 0.1);
    goDown("sizeUp");
  };
  let sizeDown = () => {
    let root = document.documentElement;
    root.style.setProperty("--size-text", textSize - 0.1 + "rem");
    setTextSize(textSize - 0.1);
    goDown("sizeDown");
  };
  let speedDown = () => {
    console.log("speedDown");
    if (timeInterval <= 10) {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 1);
    } else {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, 10);
    }
    console.log(timeInterval);

    startReading();
  };
  let speedUp = () => {
    console.log("speedUp");
    if (timeInterval === 1) {
      return;
    }
    if (timeInterval <= 10) {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -1);
    } else {
      Meteor.call(ROOMS.METHOD_NAMES.INC_TIMEINTERVAL, id, -10);
    }
    console.log(timeInterval);

    startReading();
  };
  let setNight = (value) => {
    Meteor.call(ROOMS.METHOD_NAMES.SET_NIGHTMODE, id, value);
  };
  let rewind = () => {
    pauseReading();
    setUserStatus("on", id);
    Meteor.call(ROOMS.METHOD_NAMES.REWIND, id);
  };
  let nextPage = () => {
    pauseReading();
    Meteor.call(
      ROOMS.METHOD_NAMES.UPDATE_INDEX,
      id,
      currentIndex + Constants.READING.LETTERS_PER_PAGE
    );
  };
  let backPage = () => {
    pauseReading();
    Meteor.call(
      ROOMS.METHOD_NAMES.UPDATE_INDEX,
      id,
      currentIndex - Constants.READING.LETTERS_PER_PAGE
    );
  };

  let setPaid = (room) => {
    console.log(room);
    Meteor.call(
      ROOMS.METHOD_NAMES.SET_LAST_PAID_INDEX,
      room._id,
      currentIndex,
      (err, res) => {
        err && openSimpleDialog(err, "Error");
        res && console.log(res);
      }
    );
  };

  return {
    currentIndex,
    timeInterval,
    length,
    startReading,
    pauseReading,
    rewind,
    sizeUp,
    sizeDown,
    speedDown,
    speedUp,
    setCurrentIndex,
    setTimeInterval,
    setNight,
    nextPage,
    backPage,
    setPaid,
  };
}


### Controls.js
import React, { useState, useEffect } from "react";
import { Constants } from "../../../constants";
import { Meteor } from "meteor/meteor";
import { LinearProgress } from "@material-ui/core";
import PlayButton from "./buttons/PlayButton";
import RewindButton from "./buttons/RewindButton";
import PauseButton from "./buttons/PauseButton";
import SizeUpButton from "./buttons/SizeUpButton";
import SizeDownButton from "./buttons/SizeDownButton";
import SpeedUpButton from "./buttons/SpeedUpButton";
import SpeedDownButton from "./buttons/SpeedDownButton";
import NextPage from "./buttons/NextPage";
import BackPage from "./buttons/BackPage";
import PaidButton from "./buttons/PaidButton";
import { openSimpleConfirm } from "../../commons/SimpleConfirm";

export function calculateNumberOfPages(index) {
  return Math.trunc(index / Constants.READING.LETTERS_PER_PAGE);
}

export function calculateTimeToRead(length, timeInterval) {
  var timeLeft = length * timeInterval;
  return (timeLeft / (3600 * 1000)).toFixed(1) + "horas";
}
/**
 *
 * Controls of Reader
 * id
 * title:
 * length:
 * currentIndex:
 *
 */
export default function Controls(props) {
  const { currentIndex, length, title, commands, timeInterval, room } = props;
  const [nightOn, setNightOn] = useState();
  if (room) {
    useEffect(() => {
      setNightOn(room.currentIndexBack !== -1);
    }, [room]);
  }
  function showNightButton() {
    if (room && room.participants.length > 1) {
      return (
        <button
          className="button-controls-big"
          onClick={() => {
            commands.setNight(!nightOn);
            setNightOn(!nightOn);
          }}
        >
          {nightOn ? " no night" : "night"}
        </button>
      );
    } else {
      return <></>;
    }
  }

  function setKeysBindding() {
    window.onkeydown = (e) => {
      console.log(e.code);
      switch (e.code) {
        case "ArrowLeft":
          commands.rewind();
          break;
        case "ArrowRight":
          commands.startReading();
          break;
        case "ArrowUp":
          e.preventDefault();
          commands.speedUp();
          break;
        case "ArrowDown":
          commands.speedDown();
          break;
        case "ControlLeft":
          commands.pauseReading();
          break;
        case "BracketRight":
          commands.sizeUp();
          break;
        case "NumpadAdd":
          commands.sizeUp();
          break;
        case "Slash":
          commands.sizeDown();
          break;
        case "NumpadSubtract":
          commands.sizeDown();
          break;
      }
    };
  }

  setKeysBindding();

  function calculateMoneyToPay(room, currentIndex) {
    let moneyToPay = 0;
    if (room && Meteor.user().admin) {
      let pricePerPage = room.pricePerPage;
      let lastPaidIndex = room.lastPaidIndex;
      let currentPage = calculateNumberOfPages(currentIndex);
      let lastPaidPage = calculateNumberOfPages(lastPaidIndex);
      let pagesToPay = currentPage - lastPaidPage;
      moneyToPay = pagesToPay * pricePerPage;
      return " - " + moneyToPay + "€";
    }
    return "";
  }

  return (
    <div className="controls-bottom">
      <Header
        title={title + " " + calculateMoneyToPay(room, currentIndex)}
        currentIndex={currentIndex}
        length={length}
        timeInterval={timeInterval}
      />

      <div className="controls-buttons-container">
        <PlayButton
          onClick={() => {
            commands.startReading();
          }}
        />
        <PauseButton
          onClick={() => {
            commands.pauseReading();
          }}
        />
        <BackPage
          onClick={() => {
            commands.backPage();
          }}
        />
        <NextPage
          onClick={() => {
            commands.nextPage();
          }}
        />
        <SizeUpButton
          onClick={() => {
            commands.sizeUp();
          }}
        />
        <SizeDownButton
          onClick={() => {
            commands.sizeDown();
          }}
        />
        <SpeedUpButton
          onClick={() => {
            commands.speedUp();
          }}
        />
        <SpeedDownButton
          onClick={() => {
            commands.speedDown();
          }}
        />
        {Meteor.user().admin && (
          <PaidButton
            onClick={() => {
              openSimpleConfirm("Te han pagado ya?", "Confirmar", () => {
                commands.setPaid(room);
              });
            }}
          />
        )}
        {showNightButton()}
      </div>
    </div>
  );
}
function Header({ title, currentIndex, length, timeInterval }) {
  function showElipsedTime(charactersLeft, timeInterval) {
    let fin = "-FIN-";
    if (!currentIndex) {
      return fin;
    }
    if (currentIndex >= length) {
      return fin;
    }
    var timeLeft = charactersLeft * timeInterval;
    return " -" + (timeLeft / (3600 * 1000)).toFixed(1) + "horas";
  }

  // calcula el porcentaje de la página por la que va
  function percentagePage(_currentIndex) {
    // console.log("currentIndex:" + _currentIndex);
    // el indice dentro de la página
    let localIndex = _currentIndex / Constants.READING.LETTERS_PER_PAGE;

    // tomo la parte decimal
    localIndex = localIndex % 1;
    return localIndex * 100;
  }
  return (
    <>
      <div>
        <span>{title}</span>

        <div>
          Pág: {parseInt(calculateNumberOfPages(currentIndex))} de{" "}
          {calculateNumberOfPages(length)}
          <span> </span>
          <TimeElapsed
            time={showElipsedTime(length - currentIndex, timeInterval)}
          />
        </div>
        <LinearProgress
          variant="determinate"
          value={percentagePage(currentIndex)}
          style={{ width: "50%", margin: "auto", marginBottom: "0.5rem" }}
        />
      </div>
    </>
  );
}
function TimeElapsed(props) {
  return <span>({props.time})</span>;
}


### BackPage.js
import React from "react";
import ButtonControl from "./ButtonControl";

export default function BackPage({ onClick }) {
  return (
    <>
      <ButtonControl onClick={onClick}>{"<<"}</ButtonControl>
    </>
  );
}


### ButtonControl.js
import React from 'react'

export default ({onClick, children}) => {
    return (
        <button className="button-controls-big" onClick={onClick}>            
            {children}
        </button>
    );
}

### NextPage.js
import React from "react";
import ButtonControl from "./ButtonControl";

export default function NextPage({ onClick }) {
  return (
    <>
      <ButtonControl onClick={onClick}>{">>"}</ButtonControl>
    </>
  );
}


### PaidButton.js
import React from "react";
import ButtonControl from "./ButtonControl";

export default function PaidButton({ onClick }) {
  return (
    <>
      <ButtonControl onClick={onClick}>{"$"}</ButtonControl>
    </>
  );
}


### PauseButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function PauseButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          <svg
            className="bi bi-pause-fill"
            viewBox="0 0 16 16"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M5.5 3.5A1.5 1.5 0 017 5v6a1.5 1.5 0 01-3 0V5a1.5 1.5 0 011.5-1.5zm5 0A1.5 1.5 0 0112 5v6a1.5 1.5 0 01-3 0V5a1.5 1.5 0 011.5-1.5z" />
          </svg>
        </ButtonControl>
    </>
}

### PlayButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function PlayButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          <svg
            className="bi bi-play-fill"
            viewBox="0 0 16 16"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 010 1.393z" />
          </svg>
        </ButtonControl>
    </>
}

### RewindButton.js
import React from 'react'
import FastRewindIcon from "@material-ui/icons/FastRewind";
import ButtonControl from './ButtonControl';

export default function RewindButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          <svg
            className="bi bi-play-fill"
            viewBox="0 0 16 16"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
          >
            <FastRewindIcon style={{ width: "100%", height: "100%" }} />
          </svg>
        </ButtonControl>
    </>
}

### SizeDownButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function SizeDownButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          <svg
            className="bi bi-dash"
            viewBox="0 0 16 16"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fillRule="evenodd"
              d="M3.5 8a.5.5 0 01.5-.5h8a.5.5 0 010 1H4a.5.5 0 01-.5-.5z"
              clipRule="evenodd"
            />
          </svg>
        </ButtonControl>
    </>
}

### SizeUpButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function SizeUpButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          <svg
            className="bi bi-plus"
            viewBox="0 0 16 16"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fillRule="evenodd"
              d="M8 3.5a.5.5 0 01.5.5v4a.5.5 0 01-.5.5H4a.5.5 0 010-1h3.5V4a.5.5 0 01.5-.5z"
              clipRule="evenodd"
            />
            <path
              fillRule="evenodd"
              d="M7.5 8a.5.5 0 01.5-.5h4a.5.5 0 010 1H8.5V12a.5.5 0 01-1 0V8z"
              clipRule="evenodd"
            />
          </svg>
        </ButtonControl>
    </>
}

### SpeedDownButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function SpeedDownButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          - rápido
        </ButtonControl>
    </>
}

### SpeedUpButton.js
import React from 'react'
import ButtonControl from './ButtonControl'

export default function SpeedUpButton({onClick}){
    return <>
        <ButtonControl onClick={onClick}>
          + rápido
        </ButtonControl>
    </>
}

### CloseButton.js
import { Fab } from "@material-ui/core";
import React from "react";
import { browserHistory } from "../../../routes/routes";
import { openSimpleConfirm } from "../../commons/SimpleConfirm";

export default function CloseButton(props) {
  const { room } = props  
  let url = "/books"
  if(room.readersGroupId){
    url = "/readersGroup/" + room.readersGroupId
  }
  return (
    <>
      <Fab
        onClick={() => {
          openSimpleConfirm("¿Desea salir de la sala?","Salir de la Sala",()=>{
            browserHistory.push(url);
          })             
        }}
      >
        Salir
      </Fab>
    </>
  );
}


### ColorSelector.js
import React, { useEffect } from "react";
import { DialogActions, Button } from "@material-ui/core";

export default () => {
  function changeColors(className) {
    let content = document.getElementById("visualizer__content");
    content.className = className;
  }

  useEffect(() => {
    changeColors("read-color-space");
  }, []);

  return (
    <>
      <DialogActions
        style={{
          flex: 1,
          flexDirection: "row",
          flexWrap: "wrap",
          justifyContent: "space-around",
        }}
      >
        <Button
          style={{
            backgroundColor: "#2ECCFA",
            color: "rgb(33, 9, 118)",
          }}
          onClick={() => {
            changeColors("animated-color-celeste-cielo");
          }}
        >
          Celeste Cielo
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(33, 9, 118)",
            color: "rgb(189, 234, 255)",
          }}
          onClick={() => {
            changeColors("animated-color-darkblue");
          }}
        >
          Azul Oscuro
        </Button>
        <Button
          style={{ backgroundColor: "rgb(96, 18, 145)", color: "white" }}
          onClick={() => {
            changeColors("animated-color-purple");
          }}
        >
          Morado
        </Button>
        <Button
          style={{ backgroundColor: "rgb(179, 11, 11)", color: "white" }}
          onClick={() => {
            changeColors("animated-color-red");
          }}
        >
          Rojo
        </Button>
        <Button
          style={{ backgroundColor: "#282c34", color: "#abb2bf" }}
          onClick={() => {
            changeColors("read-color-dark");
          }}
        >
          Dark
        </Button>
        <Button
          style={{ backgroundColor: "black", color: "#abb2bf" }}
          onClick={() => {
            changeColors("read-color-space");
          }}
        >
          Space
        </Button>
        <Button
          style={{ backgroundColor: "black", color: "#00ff00" }}
          onClick={() => {
            changeColors("read-color-space-terminal");
          }}
        >
          Space terminal
        </Button>
        <Button
          style={{ backgroundColor: "black", color: "white" }}
          onClick={() => {
            changeColors("read-color-black");
          }}
        >
          Negro
        </Button>
        <Button
          onClick={() => {
            changeColors("");
          }}
        >
          Blanco
        </Button>
        <Button
          className="animated-color-arcoiris"
          onClick={() => {
            changeColors("animated-color-arcoiris");
          }}
        >
          Arcoiris
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(250, 188, 90)",
            color: "black",
          }}
          onClick={() => {
            changeColors("read-color-orange");
          }}
        >
          Naranja
        </Button>
        <Button
          style={{
            backgroundColor: "#d35400",
            color: "rgb(205, 234, 235)",
          }}
          onClick={() => {
            changeColors("read-color-dark-orange");
          }}
        >
          Naranja Oscuro
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(5, 116, 29)",
            color: "rgb(189, 255, 216)",
          }}
          onClick={() => {
            changeColors("animated-color-green");
          }}
        >
          Verde
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(255, 253, 137)",
          }}
          onClick={() => {
            changeColors("animated-color-yellow");
          }}
        >
          Amarillo
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(210, 137, 255)",
          }}
          onClick={() => {
            changeColors("animated-color-violet");
          }}
        >
          Violeta
        </Button>
        <Button
          style={{
            backgroundColor: "rgb(247, 182, 242)",
            color: "rgb(126, 21, 118)",
          }}
          onClick={() => {
            changeColors("read-color-pink");
          }}
        >
          Rosa
        </Button>
      </DialogActions>
    </>
  );
};


### Comment.js
import React, { useRef } from "react";
import { TextareaAutosize, Button, Input } from "@material-ui/core";
import { COMMENTS } from "../../../api/comments";
import { ROOMS } from "../../../api/rooms";
import { browserHistory } from "../../../routes/routes";
import { openSimpleDialog } from "../../commons/SimpleDialog";
import { openSimpleConfirm } from "../../commons/SimpleConfirm";

export default (props) => {
  const PART_CONTENT_LENGHT = 300;
  const UPDATED_MESSAGE = "Comentario actualizado.";
  const REMOVED_MESSAGE = "Comentario eliminado.";
  const {
    text,
    firstIndex,
    endIndex,
    _id,
    email,
    content,
    partLength,
    roomId,
    bookId
  } = props;
  const textInput = useRef("");
  const partLengthInput = useRef("");

  function showButtons(comment) {
    if (Meteor.user() && comment.userId === Meteor.user()._id) {
      return (
        <>
          <Button
            style={{ backgroundColor: "white" }}
            onClick={() => {
              Meteor.call(
                COMMENTS.METHOD_NAME.UPDATE_TEXT,
                comment._id,
                textInput.current.value,
                (err) => {
                  err && openSimpleDialog(err,"Error");
                  openSimpleDialog(UPDATED_MESSAGE);
                }
              );
              console.log(textInput.current.value);
            }}
          >
            Actualizar
          </Button>
          <Button
            style={{ backgroundColor: "white" }}
            onClick={() => {
              console.log(endIndex);
              Meteor.call(
                ROOMS.METHOD_NAMES.UPDATE_INDEX,
                roomId,
                firstIndex,
                (err, res) => {
                  err && openSimpleDialog(err);
                  res && console.log("index updated:" + res);
                }
              );
            }}
          >
            Ir
          </Button>
          <Button
            style={{ backgroundColor: "white" }}
            onClick={() => {
              console.log(endIndex);
              browserHistory.push(`/book/reading/${bookId}/${firstIndex}/${endIndex}`)
            }}
          >
            Crear Sala Local
          </Button>
          <Button
            style={{ backgroundColor: "white" }}
            onClick={() => {
              openSimpleConfirm(
                "¿Desea borrar el comentario?",
                "Eliminar Comentario",
                ()=>{
                  Meteor.call(COMMENTS.METHOD_NAME.DELETE, comment._id, (err) => {
                    err && openSimpleDialog(err,"Error");
                    openSimpleDialog(REMOVED_MESSAGE);
                  });
                }
              )
            }}
          >
            Eliminar
          </Button>
          <div>
            <div>
              <span>Inicio Comentario</span>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_FIRST_INDEX,
                    comment._id,
                    parseInt(comment.firstIndex) - 10,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {"<<"}
              </Button>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_FIRST_INDEX,
                    comment._id,
                    parseInt(comment.firstIndex) + 10,
                    comment.currentIndex,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {">>"}
              </Button>

              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_FIRST_INDEX,
                    comment._id,
                    parseInt(comment.firstIndex) - 1,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {"<"}
              </Button>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_FIRST_INDEX,
                    comment._id,
                    parseInt(comment.firstIndex) + 1,
                    comment.currentIndex,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {">"}
              </Button>
            </div>
          </div>
        </>
      );
    } else {
      return <></>;
    }
  }

  function afterButtons(comment) {
    if (Meteor.user() && comment.userId === Meteor.user()._id) {
      return (
        <>
          <div>
            <div>
              <span>Fin Comentario </span>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_END_INDEX,
                    comment._id,
                    comment.endIndex - 10,
                    (err) => {
                      err && openSimpleDialog(err);                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {"<<"}
              </Button>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_END_INDEX,
                    comment._id,
                    comment.endIndex + 10,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {">>"}
              </Button>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_END_INDEX,
                    comment._id,
                    comment.endIndex - 1,
                    (err) => {
                      err && openSimpleDialog(err,"Error"); 
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {"<"}
              </Button>
              <Button
                style={{ backgroundColor: "white" }}
                onClick={() => {
                  console.log(partLengthInput.current.value);
                  Meteor.call(
                    COMMENTS.METHOD_NAME.UPDATE_END_INDEX,
                    comment._id,
                    comment.endIndex + 1,
                    (err) => {
                      err && openSimpleDialog(err,"Error");                      
                    }
                  );
                  console.log(textInput.current.value);
                }}
              >
                {">"}
              </Button>
            </div>
          </div>
        </>
      );
    } else {
      return <></>;
    }
  }
  function getPartLength() {
    return partLength ? partLength : PART_CONTENT_LENGHT;
  }
  console.log("firstIndex:" + firstIndex);
  return (
    <div style={{ backgroundColor: "#5AE5FA" }}>
      <p style={{ backgroundColor: "#D6D311" }}>{email}</p>
      <TextareaAutosize
        ref={textInput}
        style={{ width: "100%" }}
        defaultValue={text}
      ></TextareaAutosize>
      {showButtons(props)}
      <p style={{ backgroundColor: "#FABC5A" }}>
        {content.substring(firstIndex < 0 ? 0 : firstIndex, endIndex)}
      </p>
      {afterButtons(props)}
    </div>
  );
};


### CommentsOption.js
import React, { useState, useRef } from "react";
import {
  Fab,
  Dialog,
  DialogTitle,
  DialogContent,
  Input,
  Button,
  DialogActions,
  Snackbar,
  SnackbarContent,
} from "@material-ui/core";
import { COMMENTS } from "../../../api/comments";
import { useAvoidScrollModal } from "../CommonsReader";
import { sendMessage } from "./Emoji";
import Comment from "./Comment";
import { READER_STATUS } from "../Reader";
import { openSimpleDialog } from "../../commons/SimpleDialog";

export default (props) => {
  const { id, currentIndex, disabled, content, roomState, comments,bookId, room } = props;
  const [show, setShow] = useState(false);
  const [notificacion, setNotificacion] = useState(false);
  const comment = useRef("");

  function isParticipant(){
    const participants = room.participants
    usersIds = _.pluck(participants,"userId")
    return _.contains(usersIds,Meteor.userId())
  }
  // this hooks is to save the place of scroll before show something
  // that maybe move scroll after showing.
  const avoidScrollModal = useAvoidScrollModal();

  function createComment(text) {
    if(isParticipant()){
      Meteor.call(
        COMMENTS.METHOD_NAME.CREATE,
        id,
        currentIndex,
        text,
        (err, res) => {
          err && openSimpleDialog(err,"Error");
          res && console.log("comments.create:" + res);
        }
      );
    }
    avoidScrollModal.afterCloseModal();
  }

  function handleClose() {
    setShow(false);
    avoidScrollModal.afterCloseModal();
  }

  return (
    <div>
      <Fab
        id="comment_button"
        disabled={disabled}
        style={{ fontSize: "3rem", opacity: "0.5" }}
        onClick={(e) => {
          console.log(roomState);
          if (roomState === READER_STATUS.RUNNING && isParticipant()) {            
            createComment("Nuevo comentario para editar");
            setNotificacion(true);
            sendMessage("Nuevo comentario a editar");
          } else {
            avoidScrollModal.beforeShowModal();
            setShow(true);
          }
        }}
      >
        C
      </Fab>
      <Dialog open={show} onClose={handleClose}>
        <DialogTitle id="simple-dialog-title">Comentarios</DialogTitle>
        <DialogContent dividers>          
          <Input inputRef={comment} placeholder="Añadir comentario" />
          <Button
            onClick={() => {
              createComment(comment.current.value.trim());
            }}
          >
            Añadir
          </Button>
        </DialogContent>
        <DialogContent dividers>
          <CommentsList comments={comments} content={content} roomId={id} bookId={bookId}/>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              handleClose();
            }}
          >
            Cerrar
          </Button>
        </DialogActions>
      </Dialog>
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "center" }}
        open={notificacion}
        autoHideDuration={2000}
        onClose={() => {
          setNotificacion(false);
        }}
      >
        <SnackbarContent
          style={{ backgroundColor: "green" }}
          message="Comentario añadido para editar"
        ></SnackbarContent>
      </Snackbar>
    </div>
  );
};

function CommentsList(props) {
  const { comments, content, bookId } = props;

  if (!comments) {
    return <div>Cargando...</div>;
  }
  if (comments.length === 0) {
    return <div>No hay comentarios.</div>;
  }
  {
    return comments.map((_comment, index) => {
      return <Comment key={_comment._id} {..._comment} content={content} bookId={bookId} />;
    });
  }
}


### Emoji.js
import React, { useState, useRef } from "react";
import { Fab, Popover } from "@material-ui/core";
import { useAvoidScrollModal } from "../CommonsReader";
import { openSimpleDialog } from "../../commons/SimpleDialog";
import { MESSAGES } from "../../../api/messages";

// It's create a button that show a little Popover with emoji's
// and when you click one of them it is sended to the server
export default (props) => {
  // id is the roomId
  // currentIndex is used to save the index when it's send the emoji
  const { id, currentIndex, disabled } = props;

  // this set if the we show the Popover
  const [show, setShow] = useState(false);

  // the place to anchor the Popover
  const [anchorEl, setAnchorEl] = useState(null);

  const chatMessage = useRef("");
  // this hooks is to save the place of scroll before show something
  // that maybe move scroll after showing.
  const avoidScrollModal = useAvoidScrollModal();

  const emotis = [
    "😱",
    "😮",
    "",
    "💋",
    "",
    "😂",
    "😒",
    "😢",
    "🔥",
    "😵",
    "😤",
    "😕",
    "☠",
    "💀",
    "😈",
    "👊",
    "👎",
    "🙊",
    "🤗",
    "🤮",
    "🥳",
    "",
    "🤯",
    "🤖",
  ];
  export function sendMessage(message) {
    Meteor.call(MESSAGES.METHOD_NAMES.SEND, id, currentIndex, message, (err, res) => {
      err && openSimpleDialog(err);
      res && console.log("messages.send:" + res);
    });
    avoidScrollModal.afterCloseModal();
  }

  function handleClose() {
    setShow(false);
    avoidScrollModal.afterCloseModal();
  }

  return (
    <div>
      <Fab
        id="emoti_button"
        disabled={disabled}
        style={{ fontSize: "3rem", opacity: "0.5" }}
        onClick={(e) => {
          avoidScrollModal.beforeShowModal();
          setAnchorEl(e.currentTarget);
          setShow(true);
        }}
      >
        
      </Fab>
      <Popover
        style={{ zIndex: "10001", opacity: "0.8" }}
        anchorEl={anchorEl}
        open={show}
        onClose={handleClose}
      >
        {emotis.map((emoti) => {
          return (
            <EmojiButton
              key={emoti}
              char={emoti}
              setShow={setShow}
              sendMessage={sendMessage}
            />
          );
        })}
      </Popover>
    </div>
  );
};

function EmojiButton(props) {
  const { char, setShow, sendMessage } = props;
  return (
    <span
      onClick={() => {
        sendMessage(char);
        setShow(false);
      }}
      style={{ fontSize: "3rem" }}
    >
      {char}
    </span>
  );
}


### FormWords.js
import React, { useEffect, useRef, useState } from "react";
import { useTracker} from 'meteor/react-meteor-data'
import { Meteor } from 'meteor/meteor'
import { useAvoidScrollModal } from "../CommonsReader";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Fab,
  Input,
} from "@material-ui/core";
import { openSimpleDialog } from "../../commons/SimpleDialog";
import { WORDS, Words } from "../../../api/words";

/**
 * @param {string} roomId
 */
export default (props) => {
  const { roomId, updateShowUser, currentIndex, text } = props;
  const [isAuth] = useState(!!Meteor.user());
  const avoidScrollModal = useAvoidScrollModal();
  const word = useRef(text);
  const { words } = useTracker(()=>{
    Meteor.subscribe(WORDS.PUBLISH_NAMES.BY_ROOM_ID, roomId);
    const words = Words.find({
      roomId,
    }).fetch().reverse()
    return { words }
  }) 
  useEffect(() => {
    if (text) {
      word.current.value = text;
    }
  }, []);

  function insertWord(word) {
    Meteor.call(WORDS.METHOD_NAMES.SEND, roomId, currentIndex, word, (err, res) => {
      err && openSimpleDialog(err,"Error");
      res && console.log("words.send:" + res);
    });
    avoidScrollModal.afterCloseModal();
  }

  function showAddButton() {
    if (isAuth) {
      return (
        <>
          <Button
            onClick={() => {
              insertWord({
                word: word.current.value.trim(),
                meaning: "",
              });
            }}
          >
            Añadir
          </Button>
          <Input inputRef={word} defaultValue={text} placeholder="Palabra" />
        </>
      );
    } else {
      return (
        <>
          <Input inputRef={word} defaultValue={text} placeholder="Palabra" />
          <Button
            onClick={() => {
              openSimpleDialog("Debes registrarte para buscar palabras.");
            }}
          >
            Añadir
          </Button>
        </>
      );
    }
  }
  return (
    <>
      <Fab
        onClick={() => {
          avoidScrollModal.beforeShowModal();
          updateShowUser(true);
        }}
        style={{
          fontSize: "3rem",
          zIndex: "3",
        }}
      >
        W
      </Fab>
      <div>
        <Dialog
          open={props.show}
          onClose={() => {
            updateShowUser(false);
            console.log("avoidScrollModal.afterCloseModal();");
            avoidScrollModal.afterCloseModal();
          }}
          aria-labelledby="simple-dialog-title"
        >
          <DialogTitle id="simple-dialog-title">Palabras</DialogTitle>
          <DialogContent dividers>{showAddButton()}</DialogContent>
          <DialogContent dividers>
            {words.map((word) => {
              return (
                <p key={word._id}>
                  <a
                    target="_blank"
                    href={`https://www.google.com/search?q=${word.word}`}
                    style={{ fontWeight: "bold" }}
                  >
                    {word.word}
                  </a>{" "}
                  : {word.meaning}{" "}
                  <a
                    target="_blank"
                    href={`https://www.google.com/search?tbm=isch&q=${word.word}`}
                  >
                    Imagen
                  </a>
                </p>
              );
            })}
          </DialogContent>
          <DialogActions>
            <Button
              onClick={() => {
                updateShowUser(false);
                avoidScrollModal.afterCloseModal();
              }}
            >
              Cerrar
            </Button>
          </DialogActions>
        </Dialog>
      </div>
    </>
  );
};


### FreeRegistration.js
import { Button, Dialog, DialogContent, DialogTitle } from '@material-ui/core';
import React, {useState} from 'react';
import { browserHistory } from '../../../routes/routes';
import SignUpForm from '../../signup/SignUpForm';

export default function FreeRegistration(props){
    const { onSuccess, text } = props
    const [showModal, setShowModal] = useState(false)
    return (
    <>
        <Button variant="contained" style={{backgroundColor:"#000000",color:"white"}} onClick={()=>{setShowModal(true)}}>Regístrate Gratis</Button>
        <Dialog
            open={showModal}
            onClose={()=>{setShowModal(false)}}  
            aria-labelledby="simple-dialog-title"                    
            >
                <DialogTitle id="simple-dialog-title" style={{textAlign:"center"}}>{text?text:"REGISTRO GRATUITO"}</DialogTitle>
                <DialogContent dividers>
                    <SignUpForm onSuccess={()=>{  
                        if(onSuccess){
                            console.log("ejecuta onSuccess")
                            onSuccess()
                        } else{
                            browserHistory.push('/my_books')                        
                        }                                          
                    }}/>
                </DialogContent>
        </Dialog>
    </>)
}

### FullScreenButton.js
import React from "react";
import { Fab } from "@material-ui/core";

export default function FullScreenButton(props) {
  const { onClick } = props;
  return (
    <div
      style={{
        position: "fixed",
        right: "5%",
        bottom: "16vh",
        zIndex: "1000",
        opacity: "0.1",
      }}
    >
      <Fab
        onClick={() => {
          onClick();
        }}
      >
        F
      </Fab>
    </div>
  );
}


### SaveProgess.js
import { Fab } from '@material-ui/core';
import React from 'react'
import { ROOMS } from '../../../api/rooms';
import { openSimpleAlert } from '../../commons/SimpleAlert';
import { openSimpleDialog } from '../../commons/SimpleDialog';

export default function SaveProgress(props){
    const { room } = props
    return (
        <>
        <Fab
            onClick={() => {
                let roomPercentage = window.scrollY/document.body.offsetHeight            
                Meteor.call(ROOMS.METHOD_NAMES.UPDATE_PROGRESS, room._id,roomPercentage,(room.length*roomPercentage).toFixed(), (err,res)=>{
                    err && openSimpleDialog(err.message,"Error")
                    res && openSimpleAlert("Guardado correctamente.","Progreso Guardado.")
                    console.log(res)
                })
            }}
        >
            Guardar Progreso
        </Fab>
        </>
    );

}

### UserStatusModal.js
import React, { useEffect, useState } from "react";
import { useAvoidScrollModal } from "../CommonsReader";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  ButtonGroup,
  Fab,
} from "@material-ui/core";
import GroupIcon from "@material-ui/icons/Group";
import ColorSelector from "./ColorSelector";
import { statusToColor, userStatusToString, ROOMS } from "../../../api/rooms";
import AddParticipant from "../../rooms/AddParticipant";
import { openSimpleDialog } from "../../commons/SimpleDialog";

/**
 * @param {string} roomId
 * @param {int} trigger (little fixe)it is used to get the scroll position fine.
 * @param {array} participants
 */
export default (props) => {
  const { participants, roomId, updateShowUser } = props;
  const avoidScrollModal = useAvoidScrollModal();
  const [isOpenAddPaticipant, setIsOpenAddPaticipant] = useState(false)

  useEffect(() => {
    if (allParticipantReady(participants)) {
      setTimeout(() => {
        updateShowUser(false);
      }, 500);
      avoidScrollModal.afterCloseModal();
    }
  }, [participants]);

  function allParticipantReady(participants) {
    let result = true;
    participants.forEach((p) => {
      if (p.status !== "on") {
        result = false;
      }
    });
    return result;
  }
  function setUserStatus(status) {
    Meteor.call(
      ROOMS.METHOD_NAMES.SET_USERSTATUS,
      roomId,
      status,
      (err, res) => {
        err && openSimpleDialog(err);
        res && console.log(res);
      }
    );
  }

  function showReadyButton(participant) {
    if (participant.userId === Meteor.user()._id) {
      return (
        <>
          <ButtonGroup
            size="small"
            variant="contained"
            color="primary"
            aria-label="outlined primary button group"
          >
            <Button
              style={{ backgroundColor: "green" }}
              onClick={() => {
                setUserStatus("on");
              }}
            >
              {userStatusToString("on")}
            </Button>
            <Button
              onClick={() => {
                setUserStatus(ROOMS.USER_STATUS.RE_READING.value);
              }}
            >
              {userStatusToString(ROOMS.USER_STATUS.RE_READING.value)}
            </Button>
            <Button
              onClick={() => {
                setUserStatus(ROOMS.USER_STATUS.ONE_MOMENT.value);
                //TODO ...
              }}
            >
              {userStatusToString(ROOMS.USER_STATUS.ONE_MOMENT.value)}
            </Button>
            <Button
              onClick={() => {
                setUserStatus(ROOMS.USER_STATUS.OFF.value);
              }}
            >
              {userStatusToString(ROOMS.USER_STATUS.OFF.value)}
            </Button>
          </ButtonGroup>
        </>
      );
    }
    return <></>;
  }
  
  return (
    <>
      <Fab
        onClick={() => {
          avoidScrollModal.beforeShowModal();
          updateShowUser(true);
        }}
      >
        <GroupIcon style={{ fontSize: "3rem" }} />
      </Fab>
      <div>
        <Dialog disableEnforceFocus 
          open={props.show}
          onClose={() => {
            updateShowUser(false);
            console.log("avoidScrollModal.afterCloseModal();");
            avoidScrollModal.afterCloseModal();
          }}
          aria-labelledby="simple-dialog-title"
        >
          <DialogTitle id="simple-dialog-title">¿Estás listo?</DialogTitle>
          <DialogContent dividers>
            {participants.map((participant) => {
              return (
                <div key={participant.userId}>
                  <div style={{ marginBottom: ".3rem" }}>
                    <span
                      style={{
                        backgroundColor: statusToColor(participant.status),
                      }}
                    >
                      {userStatusToString(participant.status)}{" "}
                    </span>
                    <span>{participant.username?participant.username:participant.email}</span>
                  </div>
                  <div style={{ marginBottom: "1rem" }}>
                    {showReadyButton(participant)}
                  </div>
                </div>
              );
            })}
            <Button variant="contained" onClick={()=>{setIsOpenAddPaticipant(true)}}>+ Añadir Lector</Button>
            <AddParticipant isOpen={isOpenAddPaticipant} handleClose={()=>{setIsOpenAddPaticipant(false)}} roomId={roomId} />
          </DialogContent>
          <ColorSelector />
          <DialogActions>
            <Button
              onClick={() => {
                updateShowUser(false);
                avoidScrollModal.afterCloseModal();
              }}
            >
              Cerrar
            </Button>
          </DialogActions>
        </Dialog>
      </div>
    </>
  );
};


### AddParticipant.js
import React, { useRef, useState, useEffect } from 'react'
import { Button, Dialog, DialogActions, DialogContent, DialogTitle } from '@material-ui/core'
import ConnectedUserSelection from '../users/ConnectedUserSelection'
import { RoomFunctionsClient } from '../../client/functions/RoomFunctions'
import { openSimpleDialog } from '../commons/SimpleDialog'

export default function AddParticipant(props){
    const { isOpen,  handleClose, roomId } = props
    const [isOpenDialog, setIsOpenDialog] = useState(isOpen)

    useEffect(() => {
        setIsOpenDialog(isOpen)

    }, [isOpen])

    const email = useRef("");

    function invite() {
        let value = email.current.value.trim()
        let result = RoomFunctionsClient.inviteUserToRoom(roomId,value,()=>{
          openSimpleDialog("Se ha invitado a: " + value)
        })        
        if(result!==false){
          setIsOpenDialog(false);
          handleClose()
        }
    }

    return (
      <Dialog open={isOpenDialog} onClose={handleClose}>
        <DialogTitle>
          <span style={{fontWeight:"bold"}}>
            ¡Añade más lectores a tu sala!
          </span>
        </DialogTitle>
        <DialogContent>          
          <p>Añade otro lector para hacer una lectura en compañía a la misma vez.</p>          
          <ConnectedUserSelection 
            exceptMe={true} 
            onSelectUser={
              (user)=>{
                RoomFunctionsClient.inviteUsernameToRoom(
                  roomId,
                  user.username,
                  ()=>{
                    openSimpleDialog("¡Has invitado correctamente a " + user.username + " a la sala! Debes esperar a que acepte la invitación para leer con él.")
                  }
                )
              }
            } 
            textButton="Invitar" 
          />
          <p>Si no está conectado puedes escribir su nombre de usuario o correo electrónico aquí y le llegara la invitación cuando se conecte.</p>
          <div>
            <input ref={email} type="text" placeholder="Nombre de usuario o email" />
            <Button variant="contained" onClick={invite} autoFocus>
              Invitar
            </Button>
          </div>
        </DialogContent>
        <DialogActions>          
          <Button onClick={handleClose}>Cerrar</Button>
        </DialogActions>
      </Dialog>
    )
}

### BookRooms.js
import React from "react";
import { Link, useParams } from "react-router-dom";
import { PrivateHeader } from "../PrivateHeader";
import FullChat from "../reading/chat/FullChat";
import RoomsOfBook from "./RoomsOfBook";
import { useTracker } from 'meteor/react-meteor-data'
import { BOOKS, Books } from "../../api/books";
import { Meteor } from 'meteor/meteor'
import Footer from "../Footer";

export const BookRooms = (props) => {
  const { book_id } = useParams();
  const { book } = useTracker(()=>{
    Meteor.subscribe(BOOKS.PUBLISH_NAMES.BOOKS,book_id)    
    return {book:Books.findOne({_id:book_id})}
  });
  return (
    <div>
      <PrivateHeader title="La Librería Mágica" />
      <div className="page-content">
        <FullChat roomId={book_id} textButton="Comentar"/>
        <div>
          <div>
            <Link to="/my_books" className="button button--link" style={{margin:"0.5rem"}}>
              Ir a Mis Libros
            </Link>
            
            <Link to="/books" className="button button--link">
              Ir a la Librería
            </Link>          
          </div>
          
        {/* <h2>{book?book.title:"Cargando..."}</h2> */}
        </div>       
        <RoomsOfBook book_id={book_id}/>        
      </div>
      <Footer />
    </div>
  );
};


### Invitation.js
import React from 'react';
import Button from '@material-ui/core/Button'
import { Meteor } from 'meteor/meteor';
import { openSimpleDialog } from '../commons/SimpleDialog';
import { openSimpleConfirm } from '../commons/SimpleConfirm';

export default (props) => {
    function reject() {
        openSimpleConfirm(
            "¿Desea rechazar la invitación?",
            "Rechazar Invitación",
            ()=>{
                Meteor.call('rooms.rejectInvitation', props._id, (err, res) => {
                    err && openSimpleDialog(err,"Error")
                    res && console.log(res)
                });
            }
        )        
    }
    function accept() {
        openSimpleConfirm(
            "¿Desea aceptar la invitación?",
            "Aceptar Invitación",
            ()=>{
                Meteor.call('rooms.acceptInvitation', props._id, (err, res) => {
                    err && openSimpleDialog(err,"Error")
                    res && console.log(res)
                });
            }
        )        
    }
    return (
        <div style={{backgroundColor:"white"}}>
            <p>Libro: {props.title}</p>
            <p>de: {props.ownerEmail}</p>
            <div>
                <Button color="primary" onClick={accept}>Aceptar</Button>
                <Button color="secondary" onClick={reject}>Rechazar</Button>
            </div>
        </div>
    );
}

### InvitationsList.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { useTracker } from 'meteor/react-meteor-data'
import { Meteor } from "meteor/meteor";
import { Rooms, ROOMS } from "../../api/rooms";
import Invitation from "./Invitation";

export default () => {  
  const { invitations } = useTracker(()=>{
    Meteor.subscribe(ROOMS.PUBLISH_NAME.INVITATIONS);              
    if(Meteor.user()){
      const invitations =  Rooms.find({
          invitations: {
            $elemMatch: {
              email: Meteor.user().emails[0].address,
            },
          },
        }).fetch()
        return {invitations}
    }
    return {invitations:[]}     
  })

  if (invitations !== null && invitations.length > 0) {
    return (
      <>
        <h2>Invitaciones</h2>

        {invitations.map((i) => {
          return (
            <div key={i._id}>
              <Invitation {...i} />
            </div>
          );
        })}
      </>
    );
  } else if (invitations === null) {
    return <p>Cargando...</p>;
  }
  return <></>;
};


### MyBookRooms.js
import React from "react";
import { Link, useParams } from "react-router-dom";
import { PrivateHeader } from "../PrivateHeader";
import RoomsOfMyBook from "./RoomsOfMyBook";

export const MyBookRooms = (props) => {
  const { myBookId } = useParams();
  return (
    <div>
      <PrivateHeader title="La Librería Mágica" />
      <div className="page-content">
        <div>
          <div>
            <Link to="/my_books" className="button button--link">
              Mis Libros
            </Link>
          </div>
          <div>
            <Link to="/books" className="button button--link">
              Ir a la Librería
            </Link>
          </div>
        </div>       
        <RoomsOfMyBook myBookId={myBookId}/>        
      </div>
    </div>
  );
};


### Room.js
import React, { useState } from "react";
import Button from "@material-ui/core/Button";
import {
  Typography,
  LinearProgress,
} from "@material-ui/core";
import { Meteor } from "meteor/meteor";
import Card from "@material-ui/core/Card";
import CardActions from "@material-ui/core/CardActions";
import CardContent from "@material-ui/core/CardContent";
import { Link } from "react-router-dom";
import { ROOMS } from "../../api/rooms";
import { Constants } from "../../constants";
import { browserHistory } from "../../routes/routes";
import AddParticipant from "./AddParticipant";
import { openSimpleDialog } from "../commons/SimpleDialog";
import { openSimpleConfirm } from "../commons/SimpleConfirm";
import User from "../users/User";

export default function Room(props) {
  const [isOpen, setIsOpen] = useState(false);
  
  function handleClose() {
    setIsOpen(false);
  }

  function remove() {
    openSimpleConfirm(
      "¿Desea eliminar al sala: " + props.title + "?",
      "Eliminar Sala",
      ()=>{
        Meteor.call(ROOMS.METHOD_NAMES.REMOVE, props._id, (err, res) => {
          err && openSimpleDialog(err.reason,"Error");
          res && console.log(res);
        });
      }
    )
  }

  function exit(){
    openSimpleConfirm(
       <>
         <p>¿Deseas salir de la sala de:{props.title}?</p>
         <p>No podrás leer en esta sala a no ser que te vuelvan a invitar</p>
       </>
      ,
      "Salir de la Sala",
      ()=>{
        Meteor.call(ROOMS.METHOD_NAMES.EXIT, props._id, (err, res) => {
          err && openSimpleDialog(err.reason,"Error");
          res && console.log(res);
        });
      }
    )
  }

  function showExitButton() {
    if (props.ownerId !== Meteor.user()._id) {
      return (
        <Button variant="contained" color="secondary" onClick={exit}>
          Salir de la Sala
        </Button>
      );
    }
    return <></>;
  }
  function showRemoveButton() {
    if (props.ownerId === Meteor.user()._id) {
      return (
        <Button variant="contained" color="secondary" onClick={remove}>
          Eliminar
        </Button>
      );
    }
    return <></>;
  }

  function showIsOwnControl(isOwn) {
    if (isOwn) {
      return <span>Own Control</span>;
    } else {
      return <></>;
    }
  }

  function calculateProgress(index, length) {
    if (index > length) {
      return 100;
    }
    return (index * 100) / length;
  }
  function calculateNumberOfPages(index) {
    return Math.floor(index / Constants.READING.LETTERS_PER_PAGE);
  }

  function Participants(participants){
    return participants.map((participant)=>{      
      return <User user={participant} />
    })
  }

  function Invitations(invitations){
    return invitations.map((invitation)=>{
      let invitationValue;
      if(invitation.username){
        invitationValue = invitation.username
      }else{
        invitationValue = invitation.email
      }
      return <p style={{color:"blue", textAlign:"center"}}>{invitationValue}</p>
    })
  }

  function showInvitadosButton(invitations){    
    if(invitations.length>0){
      return (<Button
                variant="contained"             
                onClick={() => {              
                   openSimpleDialog(Invitations(invitations),"Lectores Invitados a la Sala");
                }}
              >
                Invitados: {invitations.length}
              </Button>)
    }else{
      return <></>
    }
  }  
  return (
    <div style={styles.room}>
      <Card>
        {showIsOwnControl(props.isOwnControl)}
        <CardContent>
          <Typography variant="h5" component="h2">
            <Link
              className="button button--pill button--link"
              to={{ pathname: `/room/reading/${props._id}` }}
            >
              {props.title}
            </Link>
            <div style={{ fontSize: "1.5rem", backgroundColor: "#F9EBE2" }}>
              <span style={{ fontWeight: "bold" }}>
                {calculateNumberOfPages(props.currentIndex)}
              </span>{" "}
              Páginas leídas
              {" de  "}
              {calculateNumberOfPages(props.length)}
            </div>
            <LinearProgress
              variant="determinate"
              value={calculateProgress(props.currentIndex, props.length)}
            />
          </Typography>
        </CardContent>
        <CardActions style={{display:"flex",justifyContent:"center"}}>
            <Button
              variant="contained"
              color="primary"
              style={{ backgroundColor: '#357a38' }}
              onClick={() => {
                browserHistory.push(`/room/reading/${props._id}`);
              }}
            >
              Entrar a Leer
            </Button>
            <Button
              variant="contained"
              color="primary"
              style={{ backgroundColor: '#357a38' }}
              onClick={() => {
                browserHistory.push(`/room/fullreading/${props._id}`);
              }}
            >
              Lectura Tradicional
            </Button>
        </CardActions>
        <CardActions style={{display:"flex",justifyContent:"center"}}>
            <div>
              <h3>Lectores:</h3>
              {Participants(props.participants)}
            </div>
            {showInvitadosButton(props.invitations)}
            <Button
              variant="contained"            
              onClick={() => {
                setIsOpen((pv) => !pv);
              }}
            >
              + Añadir lector
            </Button>          
        </CardActions>
        <CardActions style={{display:"flex",justifyContent:"center"}}>
          <Button
            variant="contained"
            color="secondary"
            onClick={() => {
              openSimpleConfirm(
                "¿Desea reiniciar la sala: " + props.title + "?",
                "Reiniciar Sala",
                ()=>{
                  Meteor.call(ROOMS.METHOD_NAMES.UPDATE_INDEX, props._id, 10);
                }
              )
            }}
          >
            Reiniciar
          </Button>
          {/* <Button
            variant="contained"
            color="primary"
            onClick={() => {
              browserHistory.push(`/rooms/myBook/${props.myBookId}`);
            }}
          >
            Salas
          </Button> */}
          {showRemoveButton()}
          {showExitButton()}
        </CardActions>
      </Card>
      <AddParticipant 
        isOpen={isOpen} 
        handleClose={handleClose}
        roomId={props._id} />
      {/*/<!-- -->*/}
    </div>
  );
}
function Lectores(props){
  const {  } = props
}

const styles = {
  title: {
    fontWeight: "bold",
  },
  room: {
    marginBottom: "1rem",
  },
};


### Rooms.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { Rooms, ROOMS } from "../../api/rooms";
import Room from "./Room";
import { Button, CircularProgress } from "@material-ui/core";
import Loading from "../commons/Loading";

export default (props) => {
  const subRooms = Meteor.subscribe(ROOMS.PUBLISH_NAME.ROOMS);  
  const [rooms, setRooms] = useState(null);
  const [archived, setArchived] = useState(false);
  const [folder, setFolder] = useState(props.folder);
  const {book_id} = props

  function getRoomsByIdFolder(){
    return Rooms.find({bookId:book_id,
      folder,
      participants: {
        // why this fail? $elemMatch: { userId: Meteor.userId(), archived: archived },
        $elemMatch: { archived: archived, userId: Meteor.userId() },
      },
    }).fetch()
  }
  function getRoomsByFolder(){
    return Rooms.find({
      folder,
      participants: {
        // why this fail? $elemMatch: { userId: Meteor.userId(), archived: archived },
        $elemMatch: { archived: archived, userId: Meteor.userId() },
      },
    }).fetch()
  }

  useEffect(() => {
    const tracker = Tracker.autorun(() => {
      if (subRooms.ready()) {
        console.log(Meteor.userId());
        if(book_id){
          setRooms(
            getRoomsByIdFolder(book_id,folder)
          );

        }else{
          setRooms(
            getRoomsByFolder(folder)
          );
        }
      }
    });

    return function cleanup() {
      tracker.stop();
    };
  }, [archived]);

  if (rooms === null) {
    return <Loading style={{textAlign:"center", marginTop:"5rem"}} />;      
  }
  if (rooms.length > 0) {
    return (
      <>
        <h2 style={{ color: "white" }}>Salas</h2>
        <ArchivedButtons setArchived={setArchived} />
        {rooms.map((room) => {
          return <Room key={room._id} {...room} archived={archived} />;
        })}
      </>
    );
  } else {
    return (
      <>
        <h2>Salas de Lectura</h2>
        <ArchivedButtons setArchived={setArchived} />
      </>
    );
  }
};
function ArchivedButtons(props) {
  return (
    <div style={{ marginBottom: "1rem" }}>
      <Button
        variant="contained"
        color="secondary"
        onClick={() => {
          props.setArchived(false);
        }}
      >
        Ver Salas No Archivadas
      </Button>
      <Button
        variant="contained"
        onClick={() => {
          props.setArchived(true);
        }}
      >
        Ver Salas Archivadas
      </Button>
    </div>
  );
}


### RoomsOfBook.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { Rooms, ROOMS } from "../../api/rooms";
import Room from "./Room";
import { Button } from "@material-ui/core";
import { openSimpleDialog } from "../commons/SimpleDialog";

export default (props) => {
  const subRooms = Meteor.subscribe(ROOMS.PUBLISH_NAME.ROOMS);
  const [rooms, setRooms] = useState(null);
  const [archived] = useState(false);  
  const {book_id} = props

  function createRoomButton(){
    return (
      <div>
          <Button style={{marginBottom:"1rem",fontSize:"1rem"}} variant="contained" onClick={()=>{Meteor.call(
            ROOMS.METHOD_NAMES.CREATE_FROM_BOOK,
            book_id,
            false,
            (err,res) => {
              err && openSimpleDialog(err.reason,"Error");
              res && openSimpleDialog("Busca la sala en la lista de salas abajo.","Sala creada");
            }
            );}}>Crear Nueva Sala</Button>
        </div>
    )
  }
  useEffect(() => {
    const tracker = Tracker.autorun(() => {
      if (subRooms.ready()) {
        console.log(Meteor.userId());        
        setRooms(
          Rooms.find({bookId:book_id,            
            participants: {          
              $elemMatch: { userId: Meteor.userId() },
            },
          }).fetch()
        );
      }
    });

    return function cleanup() {
      tracker.stop();
    };
  }, [archived]);

  if (rooms === null) {
    return <p>Cargando...</p>;
  }
  if (rooms.length === 0) {

  }
  if (rooms.length > 0) {
    return (
      <>                
        <h2 style={{width:"auto",marginTop:"1rem",color:"#00006B"}}>
          <span>{rooms[0].title}</span>
          <span> - {rooms[0].author}</span>
        </h2>                
        <p></p>
        {createRoomButton()}
        <hr />
      
        {rooms.map((room) => {
          return <Room key={room._id} {...room} />;
        })}
      </>
    );
  } else {
    return (
      <>
        <h2>Salas de Lectura</h2>  
        {createRoomButton()}      
      </>
    );
  }
};





### RoomsOfMyBook.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { Rooms, ROOMS } from "../../api/rooms";
import Room from "./Room";
import { Button, CircularProgress } from "@material-ui/core";
import { openSimpleDialog } from "../commons/SimpleDialog";
import Loading from "../commons/Loading";

export default (props) => {
  const subRooms = Meteor.subscribe(ROOMS.PUBLISH_NAME.ROOMS);
  const [rooms, setRooms] = useState(null);
  const [archived, setArchived] = useState(false);
  const [folder, setFolder] = useState(props.folder);
  const {myBookId} = props

  useEffect(() => {
    const tracker = Tracker.autorun(() => {
      if (subRooms.ready()) {
        console.log(Meteor.userId());
        
        setRooms(
          Rooms.find({myBookId,            
            participants: {
              // why this fail? $elemMatch: { userId: Meteor.userId(), archived: archived },
              $elemMatch: { userId: Meteor.userId() },
            },
          }).fetch()
        );
      }
    });

    return function cleanup() {
      tracker.stop();
    };
  }, [archived]);

  if (rooms === null) {
    return <Loading style={{textAlign:"center", marginTop:"5rem"}} />;      
  }
  if (rooms.length >= 0) {
    return (
      <>
        <div>
          <Button style={{marginBottom:"1rem",fontSize:"1rem"}} variant="contained" onClick={()=>{Meteor.call(
          ROOMS.METHOD_NAMES.CREATE_FROM_MY_BOOK,
          myBookId,
          false,
          (err) => {
            err && openSimpleDialog(err.reason,"Error");
          }
        );}}>Crear Nueva Sala</Button>
        </div>
        <div>
          <Button style={{marginBottom:"1rem",fontSize:"1rem"}} variant="contained" onClick={()=>{Meteor.call(
            ROOMS.METHOD_NAMES.CREATE_FROM_MY_BOOK,
            myBookId,
            true,
            (err) => {
              err && openSimpleDialog(err.reason,"Error");
            }
          );}}>Crear Nueva Sala Control Del Propietario</Button>
        </div>
      
        <h2 style={{ color: "white" }}>Salas de Lectura</h2>        
        {rooms.map((room) => {
          return <Room key={room._id} {...room} />;
        })}
      </>
    );
  } else {
    return (
      <>
        <h2>Salas de Lectura</h2>        
      </>
    );
  }
};




### SexyGame.js
import React, { useState,useRef } from 'react'

export default () => {
    const COUNT_DOWN_TIME= 5;
    const zones = 
    ["cara",
    "mano",
    "planta del pie",
    "cuello",
    "oreja",
    "boca",
    "pecho",
    "dedos pie",
    "espalda",
    "brazos",
    "culo",
    "genitales",
    "piernas",
    "barriga",
    "hombros",
    "cadera"]
    const actions = 
    ["acariciar",
    "lamer",
    "chupar",
    "morder",
    "besar", 
    "masajear",
    "soplar",
    "azotar"]
    const [resultado, setResultado] = useState("Dale caña!")    
    const counter = useRef(COUNT_DOWN_TIME)
    function momentGenerator(){
        counter.current = COUNT_DOWN_TIME
        var timer = setInterval(()=>{
            if(counter.current>0){
                setResultado(counter.current)
                counter.current = counter.current-1
            }else{
                
                let zone = _.sample(zones)
                let action = _.sample(actions)
                setResultado(zone + " " + action)
                clearInterval(timer)
            }
        },1000)
    }
    return (<div align="center">
                <p  style={{marginTop:"20%"}}>
                    <button style={{fontSize:"3rem"}} onClick={()=>momentGenerator()}>Lanzar!</button>
                </p>
                <p style={{color:"white",fontSize:"3rem"}}>{resultado}</p>
            </div>);
}

### ForgotPassword.js
import { Accounts } from 'meteor/accounts-base'
import {isEmail} from "../commons/CommonsFunctions"
import React, {useRef} from 'react'
import { openSimpleDialog } from "../commons/SimpleDialog";


export default function ForgotPassword(){
    
    const refs = {  email: useRef("") };

    var onSubmit = (event) => {
        event.preventDefault();
        let email = refs.email.current.value.trim();
        if(email===""){
            openSimpleDialog("El email no puede estar vacío")
        }else if(!isEmail(email)){
            openSimpleDialog("Comprueba que el email está bien introducido.")
        }
        Accounts.forgotPassword({email},(error)=>{
            if(error && error.error===403){
                openSimpleDialog("El email que has introducido no pertenece a ningún usuario registrado.")
            }else{
                error && openSimpleDialog(error.message)                
            }
            if(!error){
                openSimpleDialog("Te hemos enviado un email a tu correo. Comprúebalo por favor.")
            }
        })

    };
    return (
        <div className="boxed-view">
          <div className="boxed-view__box">
            <h1><a href="/">La Librería Mágica</a></h1>
            <h3>Escribe tu email y te enviaremos un enlace para que recuperes tu cuenta.</h3>
            <form
                onSubmit={(e) => {
                    onSubmit(e);
                }}
                className="boxed-view__form"
                >
                <input
                    id="input_email"
                    name="email"
                    ref={refs.email}
                    type="email"
                    placeholder="Email"
                />
                <button className="button">Enviar enlace</button>
            </form>
            
          </div>
        </div>
      );
}

### Login.js
import React from "react";
import { Link } from "react-router-dom";


import LoginForm from "./LoginForm";

export const Login = () => {
  

  return (
    <div className="boxed-view">
      <div className="boxed-view__box">
        <h1><a href="/">La Librería Mágica</a></h1>
        <LoginForm />
        <Link to="/signup">Crear una cuenta</Link>
      </div>
    </div>
  );
};


### LoginForm.js
import { Meteor } from "meteor/meteor";
import {isEmail} from "../commons/CommonsFunctions"
import React, {useState,useRef} from 'react'
import { Link } from "react-router-dom";
import { browserHistory } from "../../routes/routes";

export default function LoginForm(props){

    const [error, setError] = useState("");
    const refs = { username: useRef(""), email: useRef(""), password: useRef("") };
    const { onSuccess } = props
    var onSubmit = (event) => {
        event.preventDefault();
        let username = refs.username.current.value.trim();
        let email = ""
        if(isEmail(username)){
        email = username
        username = ""
        }
        let password = refs.password.current.value.trim();
        let select;
        if(username){
          select = {username}
        }else if(email){
          select = {email}
        }
        console.log(select)
        Meteor.loginWithPassword( select , password, (err) => {
          console.log("Login callback", err);
          err ? setError(err.reason) : setError("");
          if(!err){
            onSuccess && onSuccess()
          }
        });
    };
    return (<>
    {error ? <p>{error}</p> : undefined}
        <form
          onSubmit={(e) => {
            onSubmit(e);
          }}
          className="boxed-view__form"
        >
           <input
            id="input_username"
            name="username"
            ref={refs.username}
            type="username"
            placeholder="Usuario o Email"
          />
          <input
            name="password"
            ref={refs.password}
            type="password"
            placeholder="Password"
          />
          <button className="button">Iniciar Sesión</button>
          <Link onClick={()=>{
          browserHistory.push('/forgot-password')
        }}>Has ovidado tu contraseña?</Link>
        </form>
    </>)
}

### ResetPassword.js
import React, { useRef } from "react";
import { Accounts } from 'meteor/accounts-base'
import { openSimpleDialog } from "../commons/SimpleDialog";
import { useParams } from "react-router";
import { browserHistory } from "../../routes/routes";


export const ResetPassword = () => {
      
    const refs = { password: useRef(""), passwordConfirmation: useRef("") };
    const { token } = useParams()
    var onSubmit = (event) => {
        event.preventDefault();
        let password = refs.password.current.value.trim();
        let passwordConfirmation = refs.passwordConfirmation.current.value.trim();
        if(!password){
            openSimpleDialog("Debes introducir un email","Email vacio")
        }
        if(!passwordConfirmation){
            openSimpleDialog("Debes introducir la confirmación del email","Email vacio")
        }
        if(password!==passwordConfirmation){
            openSimpleDialog("Las contraseñas introducidas no coinciden","Contraseñas no coinciden")
        }
        Accounts.resetPassword(token,password,(err)=>{
            err && openSimpleDialog(err.message)
            if(!err){
                openSimpleDialog("Has cambiado correctamente tu contraseña.","Contraseña cambiada.")
                browserHistory.push('/')
            }
        })
        
    };


  return (
    <div className="boxed-view">
      <div className="boxed-view__box">
        <h1><a href="/">La Librería Mágica</a></h1>
        <h3>Introduce una nueva contraseña</h3>
        <form
        style={{marginTop:"1rem"}}
          onSubmit={(e) => {
            onSubmit(e);
          }}
          className="boxed-view__form"
        >
          <input
            name="password"
            ref={refs.password}
            type="password"
            placeholder="Password"
          />
          <input
            name="password"
            ref={refs.passwordConfirmation}
            type="password"
            placeholder="Confirma el password"
          />
          <button className="button">Cambiar contraseña</button>        
        </form>        
      </div>
    </div>
  );
};


### Signup.js
import React from "react";
import { Link } from "react-router-dom"
import SignUpForm from "./SignUpForm";

export const Signup = () => {

  return (
    <div className="boxed-view">
      <div className="boxed-view__box">
        <h1><a href="/">La Librería Mágica</a></h1>
        <SignUpForm />
        <Link to="/login">Iniciar Sesión</Link>
      </div>
    </div>
  );
};


### SignUpForm.js
import { Meteor } from 'meteor/meteor'
import React, {useState, useRef} from 'react';
import { ROOMS } from '../../api/rooms';
import { isEmail } from '../commons/CommonsFunctions';
import { openSimpleDialog } from '../commons/SimpleDialog';
import LocalIndex from '../localStorage/LocalIndex';

export default function SignUpForm(props){
    const {onSuccess} = props
    const [error, setError] = useState("");
    const refs = {
        username: useRef(""),
        email: useRef(""),
        password: useRef(""),
    };

    var onSubmit = (event) => {      
        event.preventDefault();        
        let username = refs.username.current.value.trim();
        let email = refs.email.current.value.trim();
        let password = refs.password.current.value.trim();
        console.log(!username)
        if(!username){      
          openSimpleDialog("Debes insertar un Nombre de Usuario para continuar.")
        return;
        }
        if(isEmail(username)){
          openSimpleDialog("El Nombre de Usuario no puede ser un correo electrónico.")
          return;
        }
        if(!email){      
          openSimpleDialog("Debes insertar un Email para continuar.")
        return;
        }
        if(!isEmail(email)){
          openSimpleDialog("Comprueba si el correo electrónico está bien introducido.")
          return;
        }
        if(!password){      
          openSimpleDialog("Debes insertar una Contraseña para continuar.")
          return;
        }        
        email = email.toLowerCase()
        Accounts.createUser(
        { username: username, email: email, password: password },
        (err) => {
            console.log("Signup callback", err);   
            err && openSimpleDialog(err.message)
            
            if(!err){
              let booksIndexs = LocalIndex().getAllBooksIndexs()
              if(booksIndexs.length==0){
                if(onSuccess){
                  onSuccess()
                }
                return;
              }
              Meteor.call(ROOMS.METHOD_NAMES.CREATE_FROM_BOOKS,booksIndexs,(err,res)=>{
                if(err){                  
                  openSimpleDialog(err.reason,"Error")
                }else{
                  if(onSuccess){
                    onSuccess()
                  }
                }

                console.log(res)
              })              
            }
        }
        );
    };
    return (<>
    {error ? <p>{error}</p> : undefined}
    <form
          onSubmit={(e) => {
            onSubmit(e);
          }}
          className="boxed-view__form"
        >
          <input
            name="username"
            ref={refs.username}
            type="username"
            placeholder="Nombre de Usuario"
          />

          <input
            name="email"
            ref={refs.email}
            type="email"
            placeholder="Email"
          />
          <input
            name="password"
            ref={refs.password}
            type="password"
            placeholder="Password"
          />
          <button className="button">Crear Cuenta</button>
    </form>
    </>)
}

### AmigosConnected.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { Meteor } from "meteor/meteor";
import { useTracker } from 'meteor/react-meteor-data'
import { Button} from "@material-ui/core";
import Modal from "react-modal";
import { USERS } from "../../api/users";
import User from "./User";

export default () => {  
  const [showUsers, setShowUsers] = useState(false) 
  const { users } = useTracker(()=>{
    let userStatusSubs = Meteor.subscribe(USERS.PUBLISH_NAMES.ALL_USERS_NAMES);
    return {users:Meteor.users.find({"status.online":true}).fetch()}
  })
 
  function handleModalClose() {    
    setShowUsers(false);
  }
  return <div>
      <div style={{textAlign:"center",marginTop:"0.5rem"}}><a onClick={(e)=>{console.log(showUsers);setShowUsers(true)}}>Usuarios online: {users.length}</a> <Button onClick={()=>{setShowUsers(true)}}>Mostrar Usuarios</Button></div>
      <Modal
        isOpen={showUsers}
        contentLabel="Usuarios Conectados"
        ariaHideApp={false}
        onRequestClose={handleModalClose.bind(this)}
        overlayClassName="boxed-view boxed-view--modal"        
      >
          <div style={{textAlign:"center"}}>
            <h3 style={{marginBottom:"1rem"}}>Usuarios Conectados:</h3>
            {users.map((user)=>(<User key={user._id} user={user}/>))}
          </div>
      </Modal>
    </div>;
};


### ConnectedUserSelection.js
import React from 'react'
import { useTracker } from 'meteor/react-meteor-data'
import { Meteor } from 'meteor/meteor' 
import { Button } from '@material-ui/core'
import { UsersFunctionsClient } from '../../client/functions/UsersFuntions'


export default function ConnectedUserSelection(props){
    const { textButton, exceptMe, onSelectUser } = props
    const { users } = useTracker(()=>{        
        if(exceptMe){
            return {users:Meteor.users.find({_id:{$ne:Meteor.userId()},"status.online":true}).fetch()}
        }else{
            return {users:Meteor.users.find({"status.online":true}).fetch()}
        }
    })
    console.log(users)
    if(!users){
        return <p>Cargando...</p>
    }
    if(users.length===0){
        return <></>
    }
    return(
        <div style={{textAlign:"center"}}>
            <p style={{marginBottom:"1rem", fontWeight:"bold"}}>Usuarios Conectados:</p>
            {                                
                users.map((user)=>{
                    if(!UsersFunctionsClient.isMe(user._id)){
                        return <UserSelection key={user._id} onSelectUser={onSelectUser} textButton={textButton} {...user} />
                    }
                })
            }
        </div>
    )
}

function UserSelection(props){
    const { username, onSelectUser, textButton } = props
    return <p><span style={{color:"darkblue"}}>{username}</span> <Button variant="contained" onClick={()=>{onSelectUser(props)}}>{textButton}</Button></p>
}

### FabAmigosConnected.js
import React, { useEffect, useState } from "react";
import { Tracker } from "meteor/tracker";
import { Meteor } from "meteor/meteor";
import { useTracker } from 'meteor/react-meteor-data'
import { Button, Fab} from "@material-ui/core";
import Modal from "react-modal";
import { USERS } from "../../api/users";
import User from "./User";

export default (props) => {  
  const { style } = props
  const [showUsers, setShowUsers] = useState(false) 
  const { users } = useTracker(()=>{
    let userStatusSubs = Meteor.subscribe(USERS.PUBLISH_NAMES.ALL_USERS_NAMES);
    return {users:Meteor.users.find({"status.online":true}).fetch()}
  })
 
  function handleModalClose() {    
    setShowUsers(false);
  }
  return <div>
      <Fab id="fabUserConnected" style={{ opacity: "0.7" }} onClick={()=>{setShowUsers(true)}}>Usuarios online: {users.length}</Fab>      
      <Modal
        isOpen={showUsers}
        contentLabel="Usuarios Conectados"
        ariaHideApp={false}
        onRequestClose={handleModalClose.bind(this)}
        overlayClassName="boxed-view boxed-view--modal"        
      >
          <div style={{textAlign:"center"}}>
            <h3 style={{marginBottom:"1rem"}}>Usuarios Conectados:</h3>
            {users.map((user)=>(<User key={user._id} user={user}/>))}
          </div>
      </Modal>
    </div>;
};


### User.js
import React from 'react'

export default ({user})=>{
    function showAdminStar(){
        if(user.admin){
            return <span className='admin_icon'>🌟</span>
        }else{
            return <></>
        }
    }
    function showName(){
        if(user.username) return user.username
        if(user.email) return user.email
        if(user.emails) return user.emails[0].address
    }
    
    return (
        <div className='user_item_view' style={{color:"blue", textAlign:"center"}}>{showAdminStar()}{showName()}</div>
    )
        
}

